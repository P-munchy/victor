#include <sipp.h>


//#############################################################################
//Given a 5x5 typical conv matrix, this routine
//packs the coefficients as required by HW reg layout
//the ccm is a fp16 matrix
void packConv5x5CCM(ConvParam *cfg, UInt16 *ccm5x5)
{
    cfg->kernel[ 0] = (ccm5x5[ 1]<<16) | ccm5x5[ 0];
    cfg->kernel[ 1] = (ccm5x5[ 3]<<16) | ccm5x5[ 2];
    cfg->kernel[ 2] =                    ccm5x5[ 4];
    cfg->kernel[ 3] = (ccm5x5[ 6]<<16) | ccm5x5[ 5];
    cfg->kernel[ 4] = (ccm5x5[ 8]<<16) | ccm5x5[ 7];
    cfg->kernel[ 5] =                    ccm5x5[ 9];
    cfg->kernel[ 6] = (ccm5x5[11]<<16) | ccm5x5[10];
    cfg->kernel[ 7] = (ccm5x5[13]<<16) | ccm5x5[12];
    cfg->kernel[ 8] =                    ccm5x5[14];
    cfg->kernel[ 9] = (ccm5x5[16]<<16) | ccm5x5[15];
    cfg->kernel[10] = (ccm5x5[18]<<16) | ccm5x5[17];
    cfg->kernel[11] =                    ccm5x5[19];
    cfg->kernel[12] = (ccm5x5[21]<<16) | ccm5x5[20];
    cfg->kernel[13] = (ccm5x5[23]<<16) | ccm5x5[22];
    cfg->kernel[14] =                    ccm5x5[24];
}

//#############################################################################
//Given a 3x3 typical conv matrix, this routine
//packs the coefs as required by HW reg layout
//NOTE: the convolution coefs are 5x5, and the outer coefs need to be set as ZERO
void packConv3x3CCM(ConvParam *cfg, UInt16 *ccm3x3)
{
   //To check.. never tested...
    cfg->kernel[ 0] = 0;
    cfg->kernel[ 1] = 0;
    cfg->kernel[ 2] = 0;

    cfg->kernel[ 3] = (ccm3x3[0]<<16);
    cfg->kernel[ 4] = (ccm3x3[2]<<16) | ccm3x3[1];
    cfg->kernel[ 5] = 0;

    cfg->kernel[ 6] = (ccm3x3[3]<<16);
    cfg->kernel[ 7] = (ccm3x3[5]<<16) | ccm3x3[4];
    cfg->kernel[ 8] = 0;

    cfg->kernel[ 9] = (ccm3x3[6]<<16);
    cfg->kernel[10] = (ccm3x3[8]<<16) | ccm3x3[7];
    cfg->kernel[11] = 0;

    cfg->kernel[12] = 0;
    cfg->kernel[13] = 0;
    cfg->kernel[14] = 0;
}

//#############################################################################
//packing a typical 3x3 CCM into Octave format (as CC-HW expects)
#define CCM_COEF(x) (UInt16)(x*1024)
void packColCombCCM(ColCombParam *cfg, float *ccm3x3)
{
   cfg->ccm[0]  = CCM_COEF(ccm3x3[0]) | (CCM_COEF(ccm3x3[3])<<16);
   cfg->ccm[1]  = CCM_COEF(ccm3x3[6]) | (CCM_COEF(ccm3x3[1])<<16);
   cfg->ccm[2]  = CCM_COEF(ccm3x3[4]) | (CCM_COEF(ccm3x3[7])<<16);
   cfg->ccm[3]  = CCM_COEF(ccm3x3[2]) | (CCM_COEF(ccm3x3[5])<<16);
   cfg->ccm[4]  = CCM_COEF(ccm3x3[8]);
}

//#############################################################################
//Packing a 5x5 UInt8 gauss
void packLumaDnsGaussLut(YDnsParam *cfg, UInt8 *lut)
{
   UInt32 i;
   for(i=0; i<4; i++) 
   {
      cfg->gaussLut[i] = (lut[i*8 + 0]      ) |
                         (lut[i*8 + 1] << 4 ) |
                         (lut[i*8 + 2] << 8 ) |
                         (lut[i*8 + 3] << 12) |
                         (lut[i*8 + 4] << 16) |
                         (lut[i*8 + 5] << 20) |
                         (lut[i*8 + 6] << 24) |
                         (lut[i*8 + 7] << 28);
   
   }
}

//#############################################################################
void sippUtilComputeFp16Lut(half (*formula)(half input), half *outLut, UInt32 lutSize)
{
  #if defined(SIPP_PC)
    UInt32 i;
    UInt32 offLsbTab[11] = {0, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
    UInt32 offLsb;
    UInt32 epr = lutSize/16;        //Entries / Range
    UInt32 rsi = logf(epr)/logf(2); //Range Size Indicator
    half   fpNum;

    offLsb = offLsbTab[rsi];
   
    for(i=0; i<lutSize; i++)
    {
      //Build the fp16 number that corresponds to Range, Offset, Interp=0
      //Meaning: the number that would cause lut to select cell "i"
        *((UInt16*)&fpNum) = i<<offLsb;

      //Get the user transform result, and store it to location "i"
        outLut[i] = formula(fpNum);
    }
  #endif
}

//#############################################################################
// Generate a 7x1 1D guassian kernel for a given sigma.  Only 4 values
// are returned.  The rest can be generated by mirroring the coefficients.
// Values returned in "coeffs" array are register-ready FP16 values.
void sharpenSigmaToCoefficients(float sigma, int *coeffs)
{
  #if defined(SIPP_PC)
    int    i, j;
    float    denom = 2 * sigma*sigma;
    float    k[4], sum = 0;
    fp16    f16;

    for (i = 0; i < 4; i++) {
        j = 3 - i;
        k[i] = expf(-(float)(j*j) / denom);
        sum += k[i];
    }

    // Coefficients should sum to 1
    sum = sum + (sum - k[3]);
    for (i = 0; i < 4; i++) {
        f16 = k[i] / sum;
        coeffs[i] = f16.getPackedValue();
    }
  #endif
}

//#############################################################################
#if defined(_WIN32)
    //stupid visual c++ ...
    double log2( double n )  
    {  
        return logf(n)/logf(2);  
    }
#endif

//#############################################################################
// Generate Luma Denoise register settings (lut and bitpos) based on strength
void lumaGenLut(float strength, UInt8 *lut, int *bitpos)
{
  #if defined(SIPP_PC)
    float    alpha, divisor, sigma, npot, l;
    int    i;

    if (strength < .001f) {
        // Avoid division by 0
        strength = .001f;
    }
    if (strength > 2047.0f) {
        // Limit to prevent 'bitpos' > 11
        strength = 2047.0f;
    }
    *bitpos = floor(log2(strength));    // MSB position
    if (*bitpos < 0) {
        *bitpos = 0;
    }
    npot = 1<<*bitpos;        // nearest power of two (rounding down)
    alpha = (strength - npot) / npot;
    divisor = 4*(1-alpha) + 8*(alpha);
    sigma = .05;
    if (strength < 1) {
        // Reduce sigma when 0 < strength < 1
        sigma = sigma * strength;
    }
    for (i = 0; i < 32; i++) {
        l = (float)i / 31 / divisor;
        l = expf(-(powf(l, 2)) / (2*(powf(sigma,2))));    // Gaussian

        // LUT entries will be quantized to 16 possible values
        lut[i] = l*16-1 + .5;
    }
  #endif
}


//#############################################################################
#if defined(MYRIAD2)

  #include <DrvSvu.h>
  
  #define   DBG_TXN_TYPE_CPFL1           0x0
  #define   DBG_TXN_TYPE_CPFL1L          0x1
  #define   DBG_TXN_TYPE_CPFL2           0x2
  #define   DBG_TXN_TYPE_CFLUSH          0x3
  #define   DBG_TXN_TYPE_CINVAL          0x4
  #define   DBG_TXN_TYPE_INV_ALL         0x5
  #define   DBG_TXN_TYPE_CFLUSH_ALL      0x6
  #define   DBG_TXN_TYPE_CFLUSH_INV_ALL  0x7
  
  static INLINE void waitWhileShavesL1Busy(UInt32 first, UInt32 last)
  {
    UInt32 svu;
    
   // Wait for all L1 caches to stop :either due to FlushInv(bit1), or data transfers(bit0)
    for(svu = first; svu <= last; svu++)
    {
      while(GET_REG_WORD_VAL(SHAVE_CACHE_STATUS(svu)) & 0x3)
      {
         NOP;NOP;NOP;NOP;NOP;
      }//while
    }//for
  }

//#############################################################################
//Config Shaves L1 caches for a range of shaves.
// - invalidate caches
// - enable both INST and LSU caches
// - set in WRITE-THROUGH to keep things coherent 
// - enable DDR addresses to be cached

//Note: swcResetShave DOES NOT RESET ShaveL1 cache, so can program independently
//      before configuring shaves !
void cfgMyriad2ShaveL1(UInt32 first, UInt32 last)
{
    UInt32 svu;
    
   /*
    //==================================================================
    //Reset L1 caches (needed ?????)
     for(svu = first; svu <= last; svu++)
     {//reset is done by writing a ZERO bit
       SET_REG_WORD(DCU_SVU_SLICE_RST(shaveNumber), (~L1_CACHE_RESET));
     }
   */
   
   //==================================================================
   //1) Stop all L1 caches: this bit must be set in order to invalidate
   //   On CACHE_CTRL_TXN_TYPE register, it's noted :
   //   "Access is only allowed when STOP bit of SLICE_CTRL register is set)
     for(svu = first; svu <= last; svu++)
     { //Set stop bit
       SET_REG_WORD(SHAVE_CACHE_CTRL(svu), 1<<3); 
     }
     waitWhileShavesL1Busy(first, last);
   
   //==================================================================
   //2.a) Invalidate all L1 caches:
    for(svu = first; svu <= last; svu++)
    { //Set stop bit
      SET_REG_WORD(SHAVE_CACHE_DBG_TXN_TYPE(svu), DBG_TXN_TYPE_INV_ALL); 
    }
    waitWhileShavesL1Busy(first, last);//wait while Busy-Invalidating
   
  //==================================================================
  //2.a) Start all L1 caches; writethrogh mode; both INSTR and LSU caches
  //     cache DDR addresses (L2 cacheable and non-cacheable)
  //     for now all transactions route through L2 partition 0
    for(svu = first; svu <= last; svu++)
    {
    //Windowed Cache Policy Config ? SLICE_WIN_CPC
    
    //Non-windowed Cache Policy Config
      SET_REG_WORD(SLICE_NWN_CPC(svu),  (1<<(10+12)) //INST enable CMX    L1 caching
                                       |(1<<( 9+12)) //INST enable DDRL2C L1 caching
                                       |(1<<( 8+12)) //INST enable DDRL2B L1 caching
                                      
                                       |(1<<(10   )) //LSU enable CMX    L1 caching
                                       |(1<<( 9   )) //LSU enable DDRL2C L1 caching
                                       |(1<<( 8   )) //LSU enable DDRL2B L1 caching
                  );
      
      SET_REG_WORD(SHAVE_CACHE_CTRL(svu), (0<<3) //stop
                                         |(1<<2) //WRITE THROUGH !!! IMPORTANT !!!
                                         |(0<<1) //lock
                                         |(1<<0) //ENABLE
                  ); 
    }
}

//#############################################################################
#include <DrvLeonL2C.h>
void leonL2CacheInitWrThrough()
{
    u32 base = DrvLL2CGetMyBase();
    
    // Invalidate entire L2Cache before enabling it
    DrvLL2COperationOnAll(base, LL2C_OPERATION_INVALIDATE, /*disable cache?:*/ 0);

    DrvLL2CSetControl(base,
        ( LL2C_CTRL_EN
        | LL2C_CTRL_REPL__LRU
        | LL2C_CTRL_NR_LOCKED_WAYS(0)
        | LL2C_CTRL_WRITE_POLICY_WRITE_THROUGH ));
        
}
#endif //Myriad2