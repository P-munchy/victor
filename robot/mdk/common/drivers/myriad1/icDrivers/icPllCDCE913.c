///   
/// @file
/// @copyright All code copyright Movidius Ltd 2012, all rights reserved. 
///            For License Warranty see: common/license.txt   
///
/// @brief     IC Driver for the External PLL CDCE913PW
/// 
/// 
/// 

// 1: Includes
// ----------------------------------------------------------------------------
#include <mv_types.h>
#include "icPllCDCE913.h"
#include "assert.h"
#include "DrvTimer.h"

// 2:  Source Specific #defines and types  (typedef,enum,struct)
// ----------------------------------------------------------------------------

// As part of the investigation of bugzilla #17361, this check is temporarily disabled.  
//#define PLL_VERIFY_REGISTER_WRITES

#define SELECT_BYTE_ACCESS (1 << 7) // Bit 7 in the register address sets byte mode when enable.

#define ADDR_CLK_GEN_8BW   (0xCA)
#define ADDR_CLK_GEN_8BR   (ADDR_CLK_GEN_8BW |  1)
#define ADDR_CLK_GEN_7B    (ADDR_CLK_GEN_8BW >> 1)

#define IC_PLL_DEBUG

#ifdef IC_PLL_DEBUG
#include <stdio.h>
#define PLL_DPRINTF(...)  printf(__VA_ARGS__)
#else
#define PLL_DPRINTF(...) // (void(*)())(__VA_ARGS__)
#endif

typedef struct
{
	u8	 	address;
	u8 		value;
} config_element_type;

// 3: Global Data (Only if absolutely necessary)
// ----------------------------------------------------------------------------

// 4: Static Local Data 
// ----------------------------------------------------------------------------
static config_element_type icExtPllCfg_74Mhz[] = 
{
{0x02, 0xB4},
{0x03, 0x03},
{0x04, 0x02},
{0x05, 0x00},
{0x06, 0x40},
{0x07, 0x00},
{0x08, 0x00},
{0x09, 0x00},
{0x0A, 0x00},
{0x0B, 0x00},
{0x0C, 0x00},
{0x0D, 0x00},
{0x0E, 0x00},
{0x0F, 0x00},
{0x10, 0x00},
{0x11, 0x00},
{0x12, 0x00},
{0x13, 0x00},
{0x14, 0x65},
{0x15, 0x02},
{0x16, 0x00},
{0x17, 0x00},
{0x18, 0xFF},
{0x19, 0xC7},
{0x1A, 0xC2},
{0x1B, 0x07},
{0x1C, 0x00},
{0x1D, 0x40},
{0x1E, 0x02},
{0x1F, 0x08},
};

static config_element_type icExtPllCfg_148Mhz[] = 
{
{0x02, 0xB4},
{0x03, 0x01},
{0x04, 0x02},
{0x05, 0x50},
{0x06, 0x40},
{0x07, 0x00},
{0x08, 0x00},
{0x09, 0x00},
{0x0A, 0x00},
{0x0B, 0x00},
{0x0C, 0x00},
{0x0D, 0x00},
{0x0E, 0x00},
{0x0F, 0x00},
{0x10, 0x00},
{0x11, 0x00},
{0x12, 0x00},
{0x13, 0x00},
{0x14, 0x65},
{0x15, 0x02},
{0x16, 0x00},
{0x17, 0x00},
{0x18, 0xaf},
{0x19, 0x50},
{0x1A, 0x02},
{0x1B, 0xc9},
{0x1C, 0x00},
{0x1D, 0x40},
{0x1E, 0x02},
{0x1F, 0x08}
};


// 5: Static Function Prototypes
// ----------------------------------------------------------------------------

// 6: Functions Implementation
// ----------------------------------------------------------------------------

int icPllCDCE913Configure(I2CM_Device * dev,u32 config_index)
{
    int i;
	int retval = 0;
    int size;
	config_element_type * pCfg;
    u8 readBackValue;

	switch (config_index)
		{
		case EXT_PLL_CFG_74MHZ:
			pCfg = icExtPllCfg_74Mhz;
			size = sizeof(icExtPllCfg_74Mhz)/sizeof(config_element_type);
			break;
		case EXT_PLL_CFG_148MHZ:
			pCfg = icExtPllCfg_148Mhz;
			size = sizeof(icExtPllCfg_148Mhz)/sizeof(config_element_type);
			break;
		default:
			retval = -1;
            assert(retval != -1);
			return retval;
		}

    for (i = 0; i < size; ++i)
    {
        // We program the device in byte mode rather than block mode
        /// @TODO: Potential future optimisation. Enable block mode
        pCfg[i].address |=  SELECT_BYTE_ACCESS;
        (void)DrvI2cMWriteByte(dev,ADDR_CLK_GEN_7B,pCfg[i].address,pCfg[i].value);
    }

#ifdef PLL_VERIFY_REGISTER_WRITES
    // Verify the registers we wrote
    for (i = 0; i < size; ++i)
    {
        // The three reads below are a really nasty hack to work around a problem
        // which is believed to be internal to the PLL
        // Previously when reading back the configuration of the PLL intermittent 
        // errors were observed. No evidence was found to suggest that the problem
        // was due to I2C signal quality, but rather it was suspected that the 
        // issue relates to delays within the chip itself. 
        // By reading the value 3 times we effecively introduce a delay between byte
        // reads. Given than the last value is alway correct we can assume that the
        // chip is indeed correctly configured. 
        // TODO: It would be nice to better analyse the pll register set and see if 
        // we can find the reason for this issue. Unfortunately the reg config
        // is generated by a software wizard and we don't have good docs on all
        // the registers
        readBackValue=DrvI2cMReadByte(dev,ADDR_CLK_GEN_7B,pCfg[i].address);
        readBackValue=DrvI2cMReadByte(dev,ADDR_CLK_GEN_7B,pCfg[i].address);
        readBackValue=DrvI2cMReadByte(dev,ADDR_CLK_GEN_7B,pCfg[i].address);
		if (readBackValue != pCfg[i].value)
        {
            PLL_DPRINTF("\nExternal PLL on I2C reg %02X, %02X was written  but %02X was read\n",(int) pCfg[i].address, (int) pCfg[i].value,(int)readBackValue);
            retval++;
            assert(retval == 0);
        }
    }
#endif
    //TODO: change temporary sleep workaround to a I2C poll. See Bug 17390 - SDK - PLL settings in the icPllCDCE913 driver
    SleepMs(500);

	return retval;
}

