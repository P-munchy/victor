// Autogenerated C++ Lite (embedded) message buffer code.
// Source: clad/robotInterface/messageEngineToRobot.clad
// Full command line: ../../tools/message-buffers/emitters/CPPLite_emitter.py --max-message-size 1400 -C ./src/ -I -o ../generated/clad//robot/ clad/robotInterface/messageEngineToRobot.clad

#ifndef __CLAD_ROBOT_INTERFACE_MESSAGE_ENGINE_TO_ROBOT_H__
#define __CLAD_ROBOT_INTERFACE_MESSAGE_ENGINE_TO_ROBOT_H__

#include <stdbool.h>
#include <stdint.h>

#include "clad/types/imageTypes.h"
#include "clad/types/robotStatusAndActions.h"
#include "clad/types/ledTypes.h"
#include "clad/types/animationKeyFrames.h"
#include "clad/types/robotTestModes.h"
#include "clad/types/dockingSignals.h"
#include "clad/types/imu.h"
#include "clad/types/controllerChannels.h"
#include "clad/robotInterface/messageToActiveObject.h"
#include "clad/robotInterface/messageFromActiveObject.h"
#include "clad/robotInterface/otaMessages.h"
#include "clad/types/fwTestMessages.h"
#include "clad/robotInterface/appConnectMessage.h"
#include "clad/types/nvStorage.h"
#include "clad/types/bleMessages.h"

namespace Anki {

namespace Cozmo {

// MESSAGE GetBodyVersion
struct GetBodyVersion
{
  // To conform to C99 standard (6.7.2.1)
  char _empty;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 0;
  static const uint32_t MIN_SIZE = 0;
  inline uint32_t Size() const { return 0; }
  
};

// MESSAGE CubeSlots
struct CubeSlots
{
  uint32_t factory_id_length;
  uint32_t factory_id[7];
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const;
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 32;
  static const uint32_t MIN_SIZE = 4;
  uint32_t Size() const;
  
};

// STRUCTURE SetPropSlot
struct SetPropSlot
{
  uint32_t factory_id;
  uint8_t slot;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 5;
  static const uint32_t MIN_SIZE = 5;
  inline uint32_t Size() const { return 5; }
  
};

// MESSAGE SetCubeGamma
struct SetCubeGamma
{
  uint8_t gamma;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1;
  static const uint32_t MIN_SIZE = 1;
  inline uint32_t Size() const { return 1; }
  
};

namespace RobotInterface {

// MESSAGE SetHeadlight
struct SetHeadlight
{
  bool enable;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1;
  static const uint32_t MIN_SIZE = 1;
  inline uint32_t Size() const { return 1; }
  
};

// MESSAGE StartMotorCalibration
struct StartMotorCalibration
{
  bool calibrateHead;
  bool calibrateLift;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 2;
  static const uint32_t MIN_SIZE = 2;
  inline uint32_t Size() const { return 2; }
  
};

// MESSAGE DriveWheels
struct DriveWheels
{
  float lwheel_speed_mmps;
  float rwheel_speed_mmps;
  float lwheel_accel_mmps2;
  float rwheel_accel_mmps2;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 16;
  static const uint32_t MIN_SIZE = 16;
  inline uint32_t Size() const { return 16; }
  
};

// MESSAGE DriveWheelsCurvature
struct DriveWheelsCurvature
{
  int16_t speed_mmPerSec;
  uint16_t accel_mmPerSec2;
  uint16_t decel_mmPerSec2;
  int16_t curvatureRadius_mm;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 8;
  static const uint32_t MIN_SIZE = 8;
  inline uint32_t Size() const { return 8; }
  
};

// MESSAGE MoveLift
struct MoveLift
{
  float speed_rad_per_sec;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 4;
  static const uint32_t MIN_SIZE = 4;
  inline uint32_t Size() const { return 4; }
  
};

// MESSAGE MoveHead
struct MoveHead
{
  float speed_rad_per_sec;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 4;
  static const uint32_t MIN_SIZE = 4;
  inline uint32_t Size() const { return 4; }
  
};

// MESSAGE SetLiftHeight
struct SetLiftHeight
{
  float height_mm;
  float max_speed_rad_per_sec;
  float accel_rad_per_sec2;
  float duration_sec;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 16;
  static const uint32_t MIN_SIZE = 16;
  inline uint32_t Size() const { return 16; }
  
};

// MESSAGE SetHeadAngle
struct SetHeadAngle
{
  float angle_rad;
  float max_speed_rad_per_sec;
  float accel_rad_per_sec2;
  float duration_sec;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 16;
  static const uint32_t MIN_SIZE = 16;
  inline uint32_t Size() const { return 16; }
  
};

// MESSAGE HeadAngleUpdate
struct HeadAngleUpdate
{
  float newAngle;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 4;
  static const uint32_t MIN_SIZE = 4;
  inline uint32_t Size() const { return 4; }
  
};

// MESSAGE SetBodyAngle
struct SetBodyAngle
{
  float angle_rad;
  float max_speed_rad_per_sec;
  float accel_rad_per_sec2;
  float angle_tolerance;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 16;
  static const uint32_t MIN_SIZE = 16;
  inline uint32_t Size() const { return 16; }
  
};

// MESSAGE TurnInPlaceAtSpeed
struct TurnInPlaceAtSpeed
{
  float speed_rad_per_sec;
  float accel_rad_per_sec2;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 8;
  static const uint32_t MIN_SIZE = 8;
  inline uint32_t Size() const { return 8; }
  
};

// MESSAGE StopAllMotors
struct StopAllMotors
{
  // To conform to C99 standard (6.7.2.1)
  char _empty;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 0;
  static const uint32_t MIN_SIZE = 0;
  inline uint32_t Size() const { return 0; }
  
};

// MESSAGE ClearPath
struct ClearPath
{
  uint16_t pathID;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 2;
  static const uint32_t MIN_SIZE = 2;
  inline uint32_t Size() const { return 2; }
  
};

// MESSAGE PathSegmentSpeed
struct PathSegmentSpeed
{
  float target;
  float accel;
  float decel;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 12;
  static const uint32_t MIN_SIZE = 12;
  inline uint32_t Size() const { return 12; }
  
};

// MESSAGE AppendPathSegmentLine
struct AppendPathSegmentLine
{
  float x_start_mm;
  float y_start_mm;
  float x_end_mm;
  float y_end_mm;
  Anki::Cozmo::RobotInterface::PathSegmentSpeed speed;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 28;
  static const uint32_t MIN_SIZE = 28;
  inline uint32_t Size() const { return 28; }
  
};

// MESSAGE AppendPathSegmentArc
struct AppendPathSegmentArc
{
  float x_center_mm;
  float y_center_mm;
  float radius_mm;
  float startRad;
  float sweepRad;
  Anki::Cozmo::RobotInterface::PathSegmentSpeed speed;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 32;
  static const uint32_t MIN_SIZE = 32;
  inline uint32_t Size() const { return 32; }
  
};

// MESSAGE AppendPathSegmentPointTurn
struct AppendPathSegmentPointTurn
{
  float x_center_mm;
  float y_center_mm;
  float targetRad;
  float angleTolerance;
  Anki::Cozmo::RobotInterface::PathSegmentSpeed speed;
  bool useShortestDir;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 29;
  static const uint32_t MIN_SIZE = 29;
  inline uint32_t Size() const { return 29; }
  
};

// MESSAGE TrimPath
struct TrimPath
{
  uint8_t numPopFrontSegments;
  uint8_t numPopBackSegments;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 2;
  static const uint32_t MIN_SIZE = 2;
  inline uint32_t Size() const { return 2; }
  
};

// MESSAGE ExecutePath
struct ExecutePath
{
  uint16_t pathID;
  bool useManualSpeed;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 3;
  static const uint32_t MIN_SIZE = 3;
  inline uint32_t Size() const { return 3; }
  
};

// MESSAGE AbsoluteLocalizationUpdate
struct AbsoluteLocalizationUpdate
{
  uint32_t timestamp;
  uint32_t pose_frame_id;
  float xPosition;
  float yPosition;
  float headingAngle;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 20;
  static const uint32_t MIN_SIZE = 20;
  inline uint32_t Size() const { return 20; }
  
};

// MESSAGE SyncTime
struct SyncTime
{
  uint32_t robotID;
  uint32_t syncTime;
  float driveCenterOffset;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 12;
  static const uint32_t MIN_SIZE = 12;
  inline uint32_t Size() const { return 12; }
  
};

// MESSAGE ImageRequest
struct ImageRequest
{
  Anki::Cozmo::ImageSendMode sendMode;
  Anki::Cozmo::ImageResolution resolution;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 2;
  static const uint32_t MIN_SIZE = 2;
  inline uint32_t Size() const { return 2; }
  
};

// MESSAGE ControllerGains
struct ControllerGains
{
  float kp;
  float ki;
  float kd;
  float maxIntegralError;
  Anki::Cozmo::ControllerChannel controller;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 17;
  static const uint32_t MIN_SIZE = 17;
  inline uint32_t Size() const { return 17; }
  
};

// MESSAGE SetMotionModelParams
struct SetMotionModelParams
{
  float slipFactor;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 4;
  static const uint32_t MIN_SIZE = 4;
  inline uint32_t Size() const { return 4; }
  
};

// MESSAGE BackpackLights
struct BackpackLights
{
  Anki::Cozmo::LightState lights[5];
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 40;
  static const uint32_t MIN_SIZE = 40;
  inline uint32_t Size() const { return 40; }
  
};

// MESSAGE AbortAnimation
struct AbortAnimation
{
  // To conform to C99 standard (6.7.2.1)
  char _empty;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 0;
  static const uint32_t MIN_SIZE = 0;
  inline uint32_t Size() const { return 0; }
  
};

// MESSAGE AnimEventToRTIP
struct AnimEventToRTIP
{
  uint8_t tag;
  Anki::Cozmo::AnimEvent event_id;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 2;
  static const uint32_t MIN_SIZE = 2;
  inline uint32_t Size() const { return 2; }
  
};

// MESSAGE EnablePickupParalysis
struct EnablePickupParalysis
{
  bool enable;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1;
  static const uint32_t MIN_SIZE = 1;
  inline uint32_t Size() const { return 1; }
  
};

// MESSAGE EnableLiftPower
struct EnableLiftPower
{
  bool enable;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1;
  static const uint32_t MIN_SIZE = 1;
  inline uint32_t Size() const { return 1; }
  
};

// ENUM BodyRadioMode
enum {
  BODY_BLUETOOTH_OPERATING_MODE  = 0, // 0
  BODY_ACCESSORY_OPERATING_MODE,      // 1
  BODY_DTM_OPERATING_MODE,            // 2
  BODY_IDLE_OPERATING_MODE,           // 3
  BODY_LOW_POWER_OPERATING_MODE,      // 4
};
typedef int8_t BodyRadioMode;

#ifdef CLAD_DEBUG
const char* BodyRadioModeToString(BodyRadioMode m);
#endif // CLAD_DEBUG

// MESSAGE GenerateTestTone
struct GenerateTestTone
{
  // To conform to C99 standard (6.7.2.1)
  char _empty;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 0;
  static const uint32_t MIN_SIZE = 0;
  inline uint32_t Size() const { return 0; }
  
};

// MESSAGE SetBodyRadioMode
struct SetBodyRadioMode
{
  Anki::Cozmo::RobotInterface::BodyRadioMode radioMode;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1;
  static const uint32_t MIN_SIZE = 1;
  inline uint32_t Size() const { return 1; }
  
};

// MESSAGE SetHeadDeviceLock
struct SetHeadDeviceLock
{
  bool enable;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1;
  static const uint32_t MIN_SIZE = 1;
  inline uint32_t Size() const { return 1; }
  
};

// MESSAGE SendDTMCommand
struct SendDTMCommand
{
  int32_t command;
  int32_t freq;
  int32_t length;
  int32_t payload;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 16;
  static const uint32_t MIN_SIZE = 16;
  inline uint32_t Size() const { return 16; }
  
};

// MESSAGE EnableReadToolCodeMode
struct EnableReadToolCodeMode
{
  float headPower;
  float liftPower;
  bool enable;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 9;
  static const uint32_t MIN_SIZE = 9;
  inline uint32_t Size() const { return 9; }
  
};

// MESSAGE RTIPVersionInfo
struct RTIPVersionInfo
{
  uint32_t version;
  uint32_t date;
  uint8_t description_length;
  char description[255];
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const;
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 264;
  static const uint32_t MIN_SIZE = 9;
  uint32_t Size() const;
  
};

// MESSAGE RadioState
struct RadioState
{
  bool wifiConnected;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1;
  static const uint32_t MIN_SIZE = 1;
  inline uint32_t Size() const { return 1; }
  
};

// MESSAGE DebugSetRTTO
struct DebugSetRTTO
{
  uint16_t timeoutMilliseconds;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 2;
  static const uint32_t MIN_SIZE = 2;
  inline uint32_t Size() const { return 2; }
  
};

// MESSAGE DisplayNumber
struct DisplayNumber
{
  uint32_t value;
  uint8_t digits;
  uint8_t x;
  uint8_t y;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 7;
  static const uint32_t MIN_SIZE = 7;
  inline uint32_t Size() const { return 7; }
  
};

// MESSAGE NVReadResultToBody
struct NVReadResultToBody
{
  Anki::Cozmo::NVStorage::NVStorageBlob entry;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const;
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1032;
  static const uint32_t MIN_SIZE = 8;
  uint32_t Size() const;
  
};

// MESSAGE NVOpResultToBody
struct NVOpResultToBody
{
  Anki::Cozmo::NVStorage::NVOpResult report;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 6;
  static const uint32_t MIN_SIZE = 6;
  inline uint32_t Size() const { return 6; }
  
};

// ENUM ToRobotAddressSpace
enum {
  GLOBAL_INVALID_TAG = 0,    // 0
  TO_BODY_START      = 0x1,  // 1
  TO_BODY_END        = 0x2f, // 47
  TO_RTIP_START      = 0x30, // 48
  TO_RTIP_END        = 0x7f, // 127
  ANIM_RT_START      = 0x93, // 147
  ANIM_RT_END        = 0x99, // 153
  TO_WIFI_START      = 0x80, // 128
  TO_WIFI_END        = 0xaf, // 175
  TO_ENG_START       = 0xb0, // 176
  TO_ENG_UNREL       = 0xf0, // 240
  TO_ENG_END         = 0xfe, // 254
};
typedef uint32_t ToRobotAddressSpace;

#ifdef CLAD_DEBUG
const char* ToRobotAddressSpaceToString(ToRobotAddressSpace m);
#endif // CLAD_DEBUG

// UNION EngineToRobot
struct EngineToRobot
{
  enum {
    Tag_setBackpackLights       = 0x3,  // 3
    Tag_setCubeLights           = 0x4,  // 4
    Tag_setPropSlot             = 0x5,  // 5
    Tag_killBodyCode            = 0x6,  // 6
    Tag_setBodyRadioMode        = 0x7,  // 7
    Tag_nvReadToBody            = 0x8,  // 8
    Tag_nvOpResultToBody        = 0x9,  // 9
    Tag_sendDTMCommand          = 0xa,  // 10
    Tag_setHeadlight            = 0xb,  // 11
    Tag_setCubeGamma            = 0xc,  // 12
    Tag_bodyRestart             = 0xd,  // 13
    Tag_getBodyVersion          = 0x25, // 37
    Tag_bleRecvHelloMessage     = 0x26, // 38
    Tag_bleEnterPairing         = 0x27, // 39
    Tag_bleSendHelloMessage     = 0x28, // 40
    Tag_bleEncodedKey           = 0x29, // 41
    Tag_robotIpInfo             = 0x2e, // 46
    Tag_wifiCfgResult           = 0x2f, // 47
    Tag_enterRecoveryMode       = 0x30, // 48
    Tag_radioConnected          = 0x31, // 49
    Tag_drive                   = 0x32, // 50
    Tag_driveCurvature          = 0x33, // 51
    Tag_moveLift                = 0x34, // 52
    Tag_moveHead                = 0x35, // 53
    Tag_liftHeight              = 0x36, // 54
    Tag_headAngle               = 0x37, // 55
    Tag_headAngleUpdate         = 0x38, // 56
    Tag_setBodyAngle            = 0x39, // 57
    Tag_turnInPlaceAtSpeed      = 0x3a, // 58
    Tag_stop                    = 0x3b, // 59
    Tag_clearPath               = 0x3c, // 60
    Tag_appendPathSegLine       = 0x3d, // 61
    Tag_appendPathSegArc        = 0x3e, // 62
    Tag_appendPathSegPointTurn  = 0x3f, // 63
    Tag_trimPath                = 0x40, // 64
    Tag_executePath             = 0x41, // 65
    Tag_dockWithObject          = 0x42, // 66
    Tag_abortDocking            = 0x43, // 67
    Tag_placeObjectOnGround     = 0x44, // 68
    Tag_absLocalizationUpdate   = 0x45, // 69
    Tag_startControllerTestMode = 0x46, // 70
    Tag_setControllerGains      = 0x47, // 71
    Tag_dockingErrorSignal      = 0x48, // 72
    Tag_setCarryState           = 0x49, // 73
    Tag_imuRequest              = 0x4a, // 74
    Tag_syncTime                = 0x4b, // 75
    Tag_imageRequest            = 0x4c, // 76
    Tag_flashObjectIDs          = 0x4d, // 77
    Tag_setObjectBeingCarried   = 0x4e, // 78
    Tag_enablePickupParalysis   = 0x4f, // 79
    Tag_enableLiftPower         = 0x50, // 80
    Tag_setMotionModelParams    = 0x51, // 81
    Tag_powerState              = 0x53, // 83
    Tag_getPropState            = 0x54, // 84
    Tag_enableReadToolCodeMode  = 0x55, // 85
    Tag_enableTestStateMessage  = 0x56, // 86
    Tag_setHeadDeviceLock       = 0x57, // 87
    Tag_startMotorCalibration   = 0x58, // 88
    Tag_setIMUCalibration       = 0x60, // 96
    Tag_generateTestTone        = 0x61, // 97
    Tag_writeNV                 = 0x83, // 131
    Tag_readNV                  = 0x84, // 132
    Tag_wipeAllNV               = 0x85, // 133
    Tag_rtipVersion             = 0x87, // 135
    Tag_setRTTO                 = 0x89, // 137
    Tag_abortAnimation          = 0x90, // 144
    Tag_animAudioSample         = 0x91, // 145
    Tag_animAudioSilence        = 0x92, // 146
    Tag_animHeadAngle           = 0x93, // 147
    Tag_animLiftHeight          = 0x94, // 148
    Tag_animEvent               = 0x95, // 149
    Tag_animEventToRTIP         = 0x96, // 150
    Tag_animFaceImage           = 0x97, // 151
    Tag_animBackpackLights      = 0x98, // 152
    Tag_animBodyMotion          = 0x99, // 153
    Tag_animEndOfAnimation      = 0x9a, // 154
    Tag_animStartOfAnimation    = 0x9b, // 155
    Tag_disableAnimTracks       = 0x9d, // 157
    Tag_enableAnimTracks        = 0x9e, // 158
    Tag_assignCubeSlots         = 0xa0, // 160
    Tag_testState               = 0xa1, // 161
    Tag_enterTestMode           = 0xa2, // 162
    Tag_oledDisplayNumber       = 0xa3, // 163
    Tag_otaWrite                = 0xaf, // 175
    Tag_appConCfgString         = 0xaa, // 170
    Tag_appConCfgFlags          = 0xab, // 171
    Tag_appConCfgIPInfo         = 0xac, // 172
    Tag_appConGetRobotIP        = 0xad, // 173
    Tag_wifiOff                 = 0xae, // 174
    INVALID                     = 255
  };
  typedef uint8_t Tag;
  
  /**** Padding added to preserve alignment ****/
  char _padding[3];
  
  Tag tag;
  
  union {
    Anki::Cozmo::RobotInterface::BackpackLights setBackpackLights;
    Anki::Cozmo::CubeLights setCubeLights;
    Anki::Cozmo::SetPropSlot setPropSlot;
    Anki::Cozmo::KillBodyCode killBodyCode;
    Anki::Cozmo::RobotInterface::SetBodyRadioMode setBodyRadioMode;
    Anki::Cozmo::RobotInterface::NVReadResultToBody nvReadToBody;
    Anki::Cozmo::RobotInterface::NVOpResultToBody nvOpResultToBody;
    Anki::Cozmo::RobotInterface::SendDTMCommand sendDTMCommand;
    Anki::Cozmo::RobotInterface::SetHeadlight setHeadlight;
    Anki::Cozmo::SetCubeGamma setCubeGamma;
    Anki::Cozmo::RobotInterface::OTA::BodyRestart bodyRestart;
    Anki::Cozmo::GetBodyVersion getBodyVersion;
    Anki::Cozmo::BLE_RecvHello bleRecvHelloMessage;
    Anki::Cozmo::BLE_EnterPairing bleEnterPairing;
    Anki::Cozmo::BLE_SendHello bleSendHelloMessage;
    Anki::Cozmo::BLE_EncodedKey bleEncodedKey;
    Anki::Cozmo::RobotInterface::AppConnectRobotIP robotIpInfo;
    Anki::Cozmo::RobotInterface::AppConnectConfigResult wifiCfgResult;
    Anki::Cozmo::RobotInterface::OTA::EnterRecoveryMode enterRecoveryMode;
    Anki::Cozmo::RobotInterface::RadioState radioConnected;
    Anki::Cozmo::RobotInterface::DriveWheels drive;
    Anki::Cozmo::RobotInterface::DriveWheelsCurvature driveCurvature;
    Anki::Cozmo::RobotInterface::MoveLift moveLift;
    Anki::Cozmo::RobotInterface::MoveHead moveHead;
    Anki::Cozmo::RobotInterface::SetLiftHeight liftHeight;
    Anki::Cozmo::RobotInterface::SetHeadAngle headAngle;
    Anki::Cozmo::RobotInterface::HeadAngleUpdate headAngleUpdate;
    Anki::Cozmo::RobotInterface::SetBodyAngle setBodyAngle;
    Anki::Cozmo::RobotInterface::TurnInPlaceAtSpeed turnInPlaceAtSpeed;
    Anki::Cozmo::RobotInterface::StopAllMotors stop;
    Anki::Cozmo::RobotInterface::ClearPath clearPath;
    Anki::Cozmo::RobotInterface::AppendPathSegmentLine appendPathSegLine;
    Anki::Cozmo::RobotInterface::AppendPathSegmentArc appendPathSegArc;
    Anki::Cozmo::RobotInterface::AppendPathSegmentPointTurn appendPathSegPointTurn;
    Anki::Cozmo::RobotInterface::TrimPath trimPath;
    Anki::Cozmo::RobotInterface::ExecutePath executePath;
    Anki::Cozmo::DockWithObject dockWithObject;
    Anki::Cozmo::AbortDocking abortDocking;
    Anki::Cozmo::PlaceObjectOnGround placeObjectOnGround;
    Anki::Cozmo::RobotInterface::AbsoluteLocalizationUpdate absLocalizationUpdate;
    Anki::Cozmo::StartControllerTestMode startControllerTestMode;
    Anki::Cozmo::RobotInterface::ControllerGains setControllerGains;
    Anki::Cozmo::DockingErrorSignal dockingErrorSignal;
    Anki::Cozmo::CarryStateUpdate setCarryState;
    Anki::Cozmo::RobotInterface::ImuRequest imuRequest;
    Anki::Cozmo::RobotInterface::SyncTime syncTime;
    Anki::Cozmo::RobotInterface::ImageRequest imageRequest;
    Anki::Cozmo::FlashObjectIDs flashObjectIDs;
    Anki::Cozmo::ObjectBeingCarried setObjectBeingCarried;
    Anki::Cozmo::RobotInterface::EnablePickupParalysis enablePickupParalysis;
    Anki::Cozmo::RobotInterface::EnableLiftPower enableLiftPower;
    Anki::Cozmo::RobotInterface::SetMotionModelParams setMotionModelParams;
    Anki::Cozmo::PowerState powerState;
    Anki::Cozmo::PropState getPropState;
    Anki::Cozmo::RobotInterface::EnableReadToolCodeMode enableReadToolCodeMode;
    Anki::Cozmo::RobotInterface::EnableTestStateMessage enableTestStateMessage;
    Anki::Cozmo::RobotInterface::SetHeadDeviceLock setHeadDeviceLock;
    Anki::Cozmo::RobotInterface::StartMotorCalibration startMotorCalibration;
    Anki::Cozmo::RobotInterface::IMUCalibrationData setIMUCalibration;
    Anki::Cozmo::RobotInterface::GenerateTestTone generateTestTone;
    Anki::Cozmo::NVStorage::NVStorageWrite writeNV;
    Anki::Cozmo::NVStorage::NVStorageRead readNV;
    Anki::Cozmo::NVStorage::NVWipeAll wipeAllNV;
    Anki::Cozmo::RobotInterface::RTIPVersionInfo rtipVersion;
    Anki::Cozmo::RobotInterface::DebugSetRTTO setRTTO;
    Anki::Cozmo::RobotInterface::AbortAnimation abortAnimation;
    Anki::Cozmo::AnimKeyFrame::AudioSample animAudioSample;
    Anki::Cozmo::AnimKeyFrame::AudioSilence animAudioSilence;
    Anki::Cozmo::AnimKeyFrame::HeadAngle animHeadAngle;
    Anki::Cozmo::AnimKeyFrame::LiftHeight animLiftHeight;
    Anki::Cozmo::AnimKeyFrame::Event animEvent;
    Anki::Cozmo::RobotInterface::AnimEventToRTIP animEventToRTIP;
    Anki::Cozmo::AnimKeyFrame::FaceImage animFaceImage;
    Anki::Cozmo::AnimKeyFrame::BackpackLights animBackpackLights;
    Anki::Cozmo::AnimKeyFrame::BodyMotion animBodyMotion;
    Anki::Cozmo::AnimKeyFrame::EndOfAnimation animEndOfAnimation;
    Anki::Cozmo::AnimKeyFrame::StartOfAnimation animStartOfAnimation;
    Anki::Cozmo::AnimKeyFrame::DisableAnimTracks disableAnimTracks;
    Anki::Cozmo::AnimKeyFrame::EnableAnimTracks enableAnimTracks;
    Anki::Cozmo::CubeSlots assignCubeSlots;
    Anki::Cozmo::RobotInterface::TestState testState;
    Anki::Cozmo::RobotInterface::EnterFactoryTestMode enterTestMode;
    Anki::Cozmo::RobotInterface::DisplayNumber oledDisplayNumber;
    Anki::Cozmo::RobotInterface::OTA::Write otaWrite;
    Anki::Cozmo::RobotInterface::AppConnectConfigString appConCfgString;
    Anki::Cozmo::RobotInterface::AppConnectConfigFlags appConCfgFlags;
    Anki::Cozmo::RobotInterface::AppConnectConfigIPInfo appConCfgIPInfo;
    Anki::Cozmo::RobotInterface::AppConnectGetRobotIP appConGetRobotIP;
    Anki::Cozmo::RobotInterface::WiFiOff wifiOff;
  };
  
  EngineToRobot(): tag(INVALID) { }
  
  /**** Cast to byte buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(&this->tag); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(&this->tag); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const;
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1041;
  static const uint32_t MIN_SIZE = 1;
  uint32_t Size() const;
  
#ifdef CLAD_DEBUG
  static const char* TagToString(Tag t);
#endif // CLAD_DEBUG
};

} // namespace RobotInterface

} // namespace Cozmo

} // namespace Anki

#endif // __CLAD_ROBOT_INTERFACE_MESSAGE_ENGINE_TO_ROBOT_H__
