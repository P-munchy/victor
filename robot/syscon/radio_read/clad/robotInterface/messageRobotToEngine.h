// Autogenerated C++ Lite (embedded) message buffer code.
// Source: clad/robotInterface/messageRobotToEngine.clad
// Full command line: ../../tools/message-buffers/emitters/CPPLite_emitter.py --max-message-size 1400 -C ./src/ -I -o ../generated/clad//robot/ clad/robotInterface/messageRobotToEngine.clad

#ifndef __CLAD_ROBOT_INTERFACE_MESSAGE_ROBOT_TO_ENGINE_H__
#define __CLAD_ROBOT_INTERFACE_MESSAGE_ROBOT_TO_ENGINE_H__

#include <stdbool.h>
#include <stdint.h>

#include "clad/types/robotStatusAndActions.h"
#include "clad/types/robotLogging.h"
#include "clad/types/imageTypes.h"
#include "clad/types/motorTypes.h"
#include "clad/types/dockingSignals.h"
#include "clad/types/imu.h"
#include "clad/types/proxMessages.h"
#include "clad/robotInterface/messageFromActiveObject.h"
#include "clad/robotInterface/otaMessages.h"
#include "clad/types/nvStorage.h"
#include "clad/types/bleMessages.h"
#include "clad/types/animationEvents.h"
#include "clad/types/fwTestMessages.h"

namespace Anki {

namespace Cozmo {

namespace RobotInterface {

// MESSAGE FWVersionInfo
struct FWVersionInfo
{
  uint32_t wifiVersion;
  uint32_t rtipVersion;
  uint32_t bodyVersion;
  uint8_t toRobotCLADHash[16];
  uint8_t toEngineCLADHash[16];
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 44;
  static const uint32_t MIN_SIZE = 44;
  inline uint32_t Size() const { return 44; }
  
};

// MESSAGE BodyVersion
struct BodyVersion
{
  uint32_t app_version;
  uint32_t esn_number;
  uint16_t hw_version;
  uint16_t fix_status;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 12;
  static const uint32_t MIN_SIZE = 12;
  inline uint32_t Size() const { return 12; }
  
};

// MESSAGE SyncTimeAck
struct SyncTimeAck
{
  bool isPhysical;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1;
  static const uint32_t MIN_SIZE = 1;
  inline uint32_t Size() const { return 1; }
  
};

// MESSAGE RobotPoked
struct RobotPoked
{
  uint32_t robotID;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 4;
  static const uint32_t MIN_SIZE = 4;
  inline uint32_t Size() const { return 4; }
  
};

// MESSAGE RobotStopped
struct RobotStopped
{
  uint8_t reason;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1;
  static const uint32_t MIN_SIZE = 1;
  inline uint32_t Size() const { return 1; }
  
};

// MESSAGE AnimationStarted
struct AnimationStarted
{
  uint8_t tag;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1;
  static const uint32_t MIN_SIZE = 1;
  inline uint32_t Size() const { return 1; }
  
};

// MESSAGE AnimationEnded
struct AnimationEnded
{
  uint8_t tag;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1;
  static const uint32_t MIN_SIZE = 1;
  inline uint32_t Size() const { return 1; }
  
};

// MESSAGE AnimationEvent
struct AnimationEvent
{
  uint32_t timestamp;
  uint8_t tag;
  Anki::Cozmo::AnimEvent event_id;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 6;
  static const uint32_t MIN_SIZE = 6;
  inline uint32_t Size() const { return 6; }
  
};

// MESSAGE RobotAvailable
struct RobotAvailable
{
  uint32_t robotID;
  uint16_t modelID;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 6;
  static const uint32_t MIN_SIZE = 6;
  inline uint32_t Size() const { return 6; }
  
};

// MESSAGE NVReadResultToEngine
struct NVReadResultToEngine
{
  uint32_t robotAddress;
  Anki::Cozmo::NVStorage::NVStorageBlob blob;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const;
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1036;
  static const uint32_t MIN_SIZE = 12;
  uint32_t Size() const;
  
};

// MESSAGE NVOpResultToEngine
struct NVOpResultToEngine
{
  uint32_t robotAddress;
  Anki::Cozmo::NVStorage::NVOpResult report;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 10;
  static const uint32_t MIN_SIZE = 10;
  inline uint32_t Size() const { return 10; }
  
};

// ENUM CrashSource
enum {
  WiFiCrash, // 0
  RTIPCrash, // 1
  BodyCrash, // 2
  PropCrash, // 3
};
typedef int8_t CrashSource;

#ifdef CLAD_DEBUG
const char* CrashSourceToString(CrashSource m);
#endif // CLAD_DEBUG

// MESSAGE CrashReport
struct CrashReport
{
  uint32_t dump[128];
  Anki::Cozmo::RobotInterface::CrashSource which;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 513;
  static const uint32_t MIN_SIZE = 513;
  inline uint32_t Size() const { return 513; }
  
};

// UNION RobotToEngine
struct RobotToEngine
{
  enum {
    Tag_trace                       = 0xb0, // 176
    Tag_printText                   = 0xb1, // 177
    Tag_mainCycleTimeError          = 0xb2, // 178
    Tag_goalPose                    = 0xb3, // 179
    Tag_activeObjectMoved           = 0xb4, // 180
    Tag_activeObjectStopped         = 0xb5, // 181
    Tag_activeObjectTapped          = 0xb6, // 182
    Tag_dataDump                    = 0xb7, // 183
    Tag_blockPickedUp               = 0xb8, // 184
    Tag_blockPlaced                 = 0xb9, // 185
    Tag_rampTraverseStarted         = 0xba, // 186
    Tag_rampTraverseCompleted       = 0xbb, // 187
    Tag_bridgeTraverseStarted       = 0xbc, // 188
    Tag_bridgeTraverseCompleted     = 0xbd, // 189
    Tag_timeProfStat                = 0xbe, // 190
    Tag_imuDataChunk                = 0xbf, // 191
    Tag_cliffEvent                  = 0xc0, // 192
    Tag_syncTimeAck                 = 0xc2, // 194
    Tag_robotPoked                  = 0xc3, // 195
    Tag_chargerMountCompleted       = 0xc4, // 196
    Tag_movingLiftPostDock          = 0xc5, // 197
    Tag_proxObstacle                = 0xc6, // 198
    Tag_imuRawDataChunk             = 0xc7, // 199
    Tag_cameraCalibration           = 0xc8, // 200
    Tag_robotAvailable              = 0xc9, // 201
    Tag_animStarted                 = 0xca, // 202
    Tag_animEnded                   = 0xcb, // 203
    Tag_nvData                      = 0xcd, // 205
    Tag_nvResult                    = 0xce, // 206
    Tag_crashReport                 = 0xcf, // 207
    Tag_activeObjectConnectionState = 0xd0, // 208
    Tag_motorCalibration            = 0xd1, // 209
    Tag_fwVersionInfo               = 0xd2, // 210
    Tag_dockingStatus               = 0xd3, // 211
    Tag_robotStopped                = 0xd4, // 212
    Tag_animEvent                   = 0xd5, // 213
    Tag_factoryTestParam            = 0xd6, // 214
    Tag_bodyVersion                 = 0xee, // 238
    Tag_otaAck                      = 0xef, // 239
    Tag_state                       = 0xf0, // 240
    Tag_animState                   = 0xf1, // 241
    Tag_image                       = 0xf2, // 242
    Tag_activeObjectDiscovered      = 0xf3, // 243
    Tag_imageGyro                   = 0xf4, // 244
    INVALID                         = 255
  };
  typedef uint8_t Tag;
  
  /**** Padding added to preserve alignment ****/
  char _padding[3];
  
  Tag tag;
  
  union {
    Anki::Cozmo::RobotInterface::PrintTrace trace;
    Anki::Cozmo::RobotInterface::PrintText printText;
    Anki::Cozmo::RobotInterface::MainCycleTimeError mainCycleTimeError;
    Anki::Cozmo::GoalPose goalPose;
    Anki::Cozmo::ObjectMoved activeObjectMoved;
    Anki::Cozmo::ObjectStoppedMoving activeObjectStopped;
    Anki::Cozmo::ObjectTapped activeObjectTapped;
    Anki::Cozmo::RobotInterface::DataDump dataDump;
    Anki::Cozmo::BlockPickedUp blockPickedUp;
    Anki::Cozmo::BlockPlaced blockPlaced;
    Anki::Cozmo::RampTraverseStart rampTraverseStarted;
    Anki::Cozmo::RampTraverseComplete rampTraverseCompleted;
    Anki::Cozmo::BridgeTraverseStart bridgeTraverseStarted;
    Anki::Cozmo::BridgeTraverseComplete bridgeTraverseCompleted;
    Anki::Cozmo::RobotInterface::TimeProfileStat timeProfStat;
    Anki::Cozmo::RobotInterface::IMUDataChunk imuDataChunk;
    Anki::Cozmo::CliffEvent cliffEvent;
    Anki::Cozmo::RobotInterface::SyncTimeAck syncTimeAck;
    Anki::Cozmo::RobotInterface::RobotPoked robotPoked;
    Anki::Cozmo::ChargerMountComplete chargerMountCompleted;
    Anki::Cozmo::MovingLiftPostDock movingLiftPostDock;
    Anki::Cozmo::ProxObstacle proxObstacle;
    Anki::Cozmo::RobotInterface::IMURawDataChunk imuRawDataChunk;
    Anki::Cozmo::CameraCalibration cameraCalibration;
    Anki::Cozmo::RobotInterface::RobotAvailable robotAvailable;
    Anki::Cozmo::RobotInterface::AnimationStarted animStarted;
    Anki::Cozmo::RobotInterface::AnimationEnded animEnded;
    Anki::Cozmo::RobotInterface::NVReadResultToEngine nvData;
    Anki::Cozmo::RobotInterface::NVOpResultToEngine nvResult;
    Anki::Cozmo::RobotInterface::CrashReport crashReport;
    Anki::Cozmo::ObjectConnectionState activeObjectConnectionState;
    Anki::Cozmo::MotorCalibration motorCalibration;
    Anki::Cozmo::RobotInterface::FWVersionInfo fwVersionInfo;
    Anki::Cozmo::DockingStatus dockingStatus;
    Anki::Cozmo::RobotInterface::RobotStopped robotStopped;
    Anki::Cozmo::RobotInterface::AnimationEvent animEvent;
    Anki::Cozmo::RobotInterface::FactoryTestParameter factoryTestParam;
    Anki::Cozmo::RobotInterface::BodyVersion bodyVersion;
    Anki::Cozmo::RobotInterface::OTA::Ack otaAck;
    Anki::Cozmo::RobotState state;
    Anki::Cozmo::RobotInterface::AnimationState animState;
    Anki::Cozmo::ImageChunk image;
    Anki::Cozmo::ObjectDiscovered activeObjectDiscovered;
    Anki::Cozmo::ImageImuData imageGyro;
  };
  
  RobotToEngine(): tag(INVALID) { }
  
  /**** Cast to byte buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(&this->tag); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(&this->tag); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const;
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1219;
  static const uint32_t MIN_SIZE = 2;
  uint32_t Size() const;
  
#ifdef CLAD_DEBUG
  static const char* TagToString(Tag t);
#endif // CLAD_DEBUG
};

} // namespace RobotInterface

} // namespace Cozmo

} // namespace Anki

#endif // __CLAD_ROBOT_INTERFACE_MESSAGE_ROBOT_TO_ENGINE_H__
