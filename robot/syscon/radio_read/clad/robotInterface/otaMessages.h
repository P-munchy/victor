// Autogenerated C++ Lite (embedded) message buffer code.
// Source: clad/robotInterface/otaMessages.clad
// Full command line: ../../tools/message-buffers/emitters/CPPLite_emitter.py --max-message-size 1400 -C ./src/ -I -o ../generated/clad//robot/ clad/robotInterface/otaMessages.clad

#ifndef __CLAD_ROBOT_INTERFACE_OTA_MESSAGES_H__
#define __CLAD_ROBOT_INTERFACE_OTA_MESSAGES_H__

#include <stdbool.h>
#include <stdint.h>

namespace Anki {

namespace Cozmo {

namespace RobotInterface {

namespace OTA {

// MESSAGE Write
struct Write
{
  int16_t packetNumber;
  uint8_t data[1024];
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1026;
  static const uint32_t MIN_SIZE = 1026;
  inline uint32_t Size() const { return 1026; }
  
};

// ENUM Result
enum {
  ERR_READ_ERROR    = -25, // -25
  ERR_READ_TIMEOUT  = -24, // -24
  ERR_WRITE_ERROR   = -23, // -23
  ERR_WRITE_TIMEOUT = -22, // -22
  ERR_ERASE_ERROR   = -21, // -21
  ERR_ERASE_TIMEOUT = -20, // -20
  ERR_FACT_RESET    = -10, // -10
  ERR_RTIP_TIMEOUT  = -7,  // -7
  ERR_RTIP_NAK      = -6,  // -6
  ERR_I2SPI         = -5,  // -5
  ERR_BAD_ENC       = -4,  // -4
  ERR_BAD_DATA      = -3,  // -3
  ERR_BAD_ADDRESS   = -2,  // -2
  ERR_NO_MEM        = -1,  // -1
  OKAY              = 0,   // 0
  BUSY              = 1,   // 1
  NOTHING_TO_DO     = 2,   // 2
  OUT_OF_ORDER      = 3,   // 3
  NOT_ENABLED       = 4,   // 4
  SUCCESS           = 10,  // 10
};
typedef int8_t Result;

#ifdef CLAD_DEBUG
const char* ResultToString(Result m);
#endif // CLAD_DEBUG

// MESSAGE Ack
struct Ack
{
  int32_t bytesProcessed;
  int16_t packetNumber;
  Anki::Cozmo::RobotInterface::OTA::Result result;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 7;
  static const uint32_t MIN_SIZE = 7;
  inline uint32_t Size() const { return 7; }
  
};

// ENUM RecoveryMode
enum {
  System_Reset,    // 0
  System_Shutdown, // 1
  Recovery_Mode,   // 2
  OTA_Mode,        // 3
};
typedef int8_t RecoveryMode;

#ifdef CLAD_DEBUG
const char* RecoveryModeToString(RecoveryMode m);
#endif // CLAD_DEBUG

// MESSAGE BodyRestart
struct BodyRestart
{
  // To conform to C99 standard (6.7.2.1)
  char _empty;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 0;
  static const uint32_t MIN_SIZE = 0;
  inline uint32_t Size() const { return 0; }
  
};

// MESSAGE EnterRecoveryMode
struct EnterRecoveryMode
{
  Anki::Cozmo::RobotInterface::OTA::RecoveryMode mode;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1;
  static const uint32_t MIN_SIZE = 1;
  inline uint32_t Size() const { return 1; }
  
};

} // namespace OTA

} // namespace RobotInterface

} // namespace Cozmo

} // namespace Anki

#endif // __CLAD_ROBOT_INTERFACE_OTA_MESSAGES_H__
