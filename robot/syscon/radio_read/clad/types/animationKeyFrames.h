// Autogenerated C++ Lite (embedded) message buffer code.
// Source: clad/types/animationKeyFrames.clad
// Full command line: ../../tools/message-buffers/emitters/CPPLite_emitter.py --max-message-size 1400 -C ./src/ -I -o ../generated/clad//robot/ clad/types/animationKeyFrames.clad

#ifndef __CLAD_TYPES_ANIMATION_KEY_FRAMES_H__
#define __CLAD_TYPES_ANIMATION_KEY_FRAMES_H__

#include <stdbool.h>
#include <stdint.h>

#include "clad/types/animationEvents.h"

namespace Anki {

namespace Cozmo {

// ENUM AnimTrackFlag
enum {
  NO_TRACKS             = 0,    // 0
  HEAD_TRACK            = 0x1,  // 1
  LIFT_TRACK            = 0x2,  // 2
  BODY_TRACK            = 0x4,  // 4
  FACE_IMAGE_TRACK      = 0x8,  // 8
  EVENT_TRACK           = 0x10, // 16
  BACKPACK_LIGHTS_TRACK = 0x20, // 32
  AUDIO_TRACK           = 0x40, // 64
  ALL_TRACKS            = 0xff, // 255
};
typedef uint8_t AnimTrackFlag;

#ifdef CLAD_DEBUG
const char* AnimTrackFlagToString(AnimTrackFlag m);
#endif // CLAD_DEBUG

// ENUM AnimConstants
enum {
  AUDIO_SAMPLE_RATE    = 22320, // 22320
  AUDIO_SAMPLE_SIZE    = 744,   // 744
  MAX_FACE_FRAME_SIZE  = 1024,  // 1024
  KEYFRAME_BUFFER_SIZE = 16384, // 16384
  NUM_TRACKS           = 8,     // 8
};
typedef int32_t AnimConstants;

#ifdef CLAD_DEBUG
const char* AnimConstantsToString(AnimConstants m);
#endif // CLAD_DEBUG

namespace AnimKeyFrame {

// MESSAGE AudioSample
struct AudioSample
{
  uint8_t sample[744];
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 744;
  static const uint32_t MIN_SIZE = 744;
  inline uint32_t Size() const { return 744; }
  
};

// MESSAGE AudioSilence
struct AudioSilence
{
  // To conform to C99 standard (6.7.2.1)
  char _empty;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 0;
  static const uint32_t MIN_SIZE = 0;
  inline uint32_t Size() const { return 0; }
  
};

// MESSAGE HeadAngle
struct HeadAngle
{
  uint16_t time_ms;
  int8_t angle_deg;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 3;
  static const uint32_t MIN_SIZE = 3;
  inline uint32_t Size() const { return 3; }
  
};

// MESSAGE LiftHeight
struct LiftHeight
{
  uint16_t time_ms;
  uint8_t height_mm;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 3;
  static const uint32_t MIN_SIZE = 3;
  inline uint32_t Size() const { return 3; }
  
};

// MESSAGE FacePosition
struct FacePosition
{
  int8_t xCen;
  int8_t yCen;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 2;
  static const uint32_t MIN_SIZE = 2;
  inline uint32_t Size() const { return 2; }
  
};

// MESSAGE Blink
struct Blink
{
  bool enable;
  bool blinkNow;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 2;
  static const uint32_t MIN_SIZE = 2;
  inline uint32_t Size() const { return 2; }
  
};

// MESSAGE FaceImage
struct FaceImage
{
  uint16_t image_length;
  uint8_t image[1024];
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const;
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1026;
  static const uint32_t MIN_SIZE = 2;
  uint32_t Size() const;
  
};

// MESSAGE BackpackLights
struct BackpackLights
{
  uint32_t colors[5];
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 20;
  static const uint32_t MIN_SIZE = 20;
  inline uint32_t Size() const { return 20; }
  
};

// MESSAGE BodyMotion
struct BodyMotion
{
  int16_t speed;
  int16_t curvatureRadius_mm;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 4;
  static const uint32_t MIN_SIZE = 4;
  inline uint32_t Size() const { return 4; }
  
};

// MESSAGE Event
struct Event
{
  Anki::Cozmo::AnimEvent event_id;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1;
  static const uint32_t MIN_SIZE = 1;
  inline uint32_t Size() const { return 1; }
  
};

// MESSAGE EnableAnimTracks
struct EnableAnimTracks
{
  uint8_t whichTracks;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1;
  static const uint32_t MIN_SIZE = 1;
  inline uint32_t Size() const { return 1; }
  
};

// MESSAGE DisableAnimTracks
struct DisableAnimTracks
{
  uint8_t whichTracks;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1;
  static const uint32_t MIN_SIZE = 1;
  inline uint32_t Size() const { return 1; }
  
};

// MESSAGE StartOfAnimation
struct StartOfAnimation
{
  uint8_t tag;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1;
  static const uint32_t MIN_SIZE = 1;
  inline uint32_t Size() const { return 1; }
  
};

// MESSAGE EndOfAnimation
struct EndOfAnimation
{
  // To conform to C99 standard (6.7.2.1)
  char _empty;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 0;
  static const uint32_t MIN_SIZE = 0;
  inline uint32_t Size() const { return 0; }
  
};

} // namespace AnimKeyFrame

} // namespace Cozmo

} // namespace Anki

#endif // __CLAD_TYPES_ANIMATION_KEY_FRAMES_H__
