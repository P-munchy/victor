// Autogenerated C++ Lite (embedded) message buffer code.
// Source: clad/types/dockingSignals.clad
// Full command line: ../../tools/message-buffers/emitters/CPPLite_emitter.py --max-message-size 1400 -C ./src/ -I -o ../generated/clad//robot/ clad/types/dockingSignals.clad

#ifndef __CLAD_TYPES_DOCKING_SIGNALS_H__
#define __CLAD_TYPES_DOCKING_SIGNALS_H__

#include <stdbool.h>
#include <stdint.h>

#include "clad/types/robotStatusAndActions.h"

namespace Anki {

namespace Cozmo {

// ENUM DockingMethod
enum {
  BLIND_DOCKING,   // 0
  TRACKER_DOCKING, // 1
  HYBRID_DOCKING,  // 2
};
typedef uint8_t DockingMethod;

#ifdef CLAD_DEBUG
const char* DockingMethodToString(DockingMethod m);
#endif // CLAD_DEBUG

// MESSAGE DockWithObject
struct DockWithObject
{
  float horizontalOffset_mm;
  float speed_mmps;
  float accel_mmps2;
  float decel_mmps2;
  Anki::Cozmo::DockAction action;
  bool useManualSpeed;
  uint8_t numRetries;
  Anki::Cozmo::DockingMethod dockingMethod;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 20;
  static const uint32_t MIN_SIZE = 20;
  inline uint32_t Size() const { return 20; }
  
};

// MESSAGE AbortDocking
struct AbortDocking
{
  // To conform to C99 standard (6.7.2.1)
  char _empty;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 0;
  static const uint32_t MIN_SIZE = 0;
  inline uint32_t Size() const { return 0; }
  
};

// MESSAGE PlaceObjectOnGround
struct PlaceObjectOnGround
{
  float rel_x_mm;
  float rel_y_mm;
  float rel_angle;
  float speed_mmps;
  float accel_mmps2;
  float decel_mmps2;
  bool useManualSpeed;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 25;
  static const uint32_t MIN_SIZE = 25;
  inline uint32_t Size() const { return 25; }
  
};

// MESSAGE DockingErrorSignal
struct DockingErrorSignal
{
  uint32_t timestamp;
  float x_distErr;
  float y_horErr;
  float z_height;
  float angleErr;
  bool didTrackingSucceed;
  bool isApproximate;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 22;
  static const uint32_t MIN_SIZE = 22;
  inline uint32_t Size() const { return 22; }
  
};

// ENUM DockingResult
enum {
  DOCK_UNKNOWN,                            // 0
  DOCK_INTERRUPTED,                        // 1
  DOCK_SUCCESS,                            // 2
  DOCK_SUCCESS_RETRY,                      // 3
  DOCK_SUCCESS_HANNS_MANEUVER,             // 4
  DOCK_FAILURE,                            // 5
  DOCK_FAILURE_TOO_LONG_WITHOUT_BLOCKPOSE, // 6
  DOCK_FAILURE_TOO_HIGH,                   // 7
  DOCK_FAILURE_RETRY,                      // 8
};
typedef int8_t DockingResult;

#ifdef CLAD_DEBUG
const char* DockingResultToString(DockingResult m);
#endif // CLAD_DEBUG

// ENUM Status
enum {
  STATUS_BACKING_UP,           // 0
  STATUS_DOING_HANNS_MANEUVER, // 1
};
typedef int8_t Status;

#ifdef CLAD_DEBUG
const char* StatusToString(Status m);
#endif // CLAD_DEBUG

// MESSAGE DockingStatus
struct DockingStatus
{
  uint32_t timestamp;
  Anki::Cozmo::Status status;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 5;
  static const uint32_t MIN_SIZE = 5;
  inline uint32_t Size() const { return 5; }
  
};

// MESSAGE BlockPickedUp
struct BlockPickedUp
{
  uint32_t timestamp;
  bool didSucceed;
  Anki::Cozmo::DockingResult result;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 6;
  static const uint32_t MIN_SIZE = 6;
  inline uint32_t Size() const { return 6; }
  
};

// MESSAGE BlockPlaced
struct BlockPlaced
{
  uint32_t timestamp;
  bool didSucceed;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 5;
  static const uint32_t MIN_SIZE = 5;
  inline uint32_t Size() const { return 5; }
  
};

// MESSAGE MovingLiftPostDock
struct MovingLiftPostDock
{
  Anki::Cozmo::DockAction action;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1;
  static const uint32_t MIN_SIZE = 1;
  inline uint32_t Size() const { return 1; }
  
};

// MESSAGE RampTraverseStart
struct RampTraverseStart
{
  uint32_t timestamp;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 4;
  static const uint32_t MIN_SIZE = 4;
  inline uint32_t Size() const { return 4; }
  
};

// MESSAGE RampTraverseComplete
struct RampTraverseComplete
{
  uint32_t timestamp;
  bool didSucceed;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 5;
  static const uint32_t MIN_SIZE = 5;
  inline uint32_t Size() const { return 5; }
  
};

// MESSAGE BridgeTraverseStart
struct BridgeTraverseStart
{
  uint32_t timestamp;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 4;
  static const uint32_t MIN_SIZE = 4;
  inline uint32_t Size() const { return 4; }
  
};

// MESSAGE BridgeTraverseComplete
struct BridgeTraverseComplete
{
  uint32_t timestamp;
  bool didSucceed;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 5;
  static const uint32_t MIN_SIZE = 5;
  inline uint32_t Size() const { return 5; }
  
};

// MESSAGE ChargerMountComplete
struct ChargerMountComplete
{
  uint32_t timestamp;
  bool didSucceed;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 5;
  static const uint32_t MIN_SIZE = 5;
  inline uint32_t Size() const { return 5; }
  
};

// STRUCTURE GoalPose
struct GoalPose
{
  Anki::Cozmo::RobotPose pose;
  bool followingMarkerNormal;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 21;
  static const uint32_t MIN_SIZE = 21;
  inline uint32_t Size() const { return 21; }
  
};

} // namespace Cozmo

} // namespace Anki

#endif // __CLAD_TYPES_DOCKING_SIGNALS_H__
