// Autogenerated C++ Lite (embedded) message buffer code.
// Source: clad/types/fwTestMessages.clad
// Full command line: ../../tools/message-buffers/emitters/CPPLite_emitter.py --max-message-size 1400 -C ./src/ -I -o ../generated/clad//robot/ clad/types/fwTestMessages.clad

#ifndef __CLAD_TYPES_FW_TEST_MESSAGES_H__
#define __CLAD_TYPES_FW_TEST_MESSAGES_H__

#include <stdbool.h>
#include <stdint.h>

namespace Anki {

namespace Cozmo {

namespace RobotInterface {

// ENUM FactoryTestMode
enum {
  FTM_entry          = -1, // -1
  FTM_None           = 0,  // 0
  FTM_WiFiInfo       = 1,  // 1
  FTM_StateMenu      = 2,  // 2
  FTM_ADCInfo        = 3,  // 3
  FTM_ImuInfo        = 4,  // 4
  FTM_EncoderInfo    = 5,  // 5
  FTM_motorLifeTest  = 6,  // 6
  FTM_PlayPenTest    = 7,  // 7
  FTM_SSID           = 8,  // 8
  FTM_menus          = 9,  // 9
  FTM_cubeTest       = 10, // 10
  FTM_BLE_Menu       = 11, // 11
  FTM_BLE_On         = 12, // 12
  FTM_BLE_Off        = 13, // 13
  FTM_WaitNV         = 14, // 14
  FTM_Sleepy         = 15, // 15
  FTM_FAC            = 16, // 16
  FTM_Off            = 17, // 17
  FTM_IMUCalibration = 18, // 18
};
typedef int32_t FactoryTestMode;

#ifdef CLAD_DEBUG
const char* FactoryTestModeToString(FactoryTestMode m);
#endif // CLAD_DEBUG

// MESSAGE EnterFactoryTestMode
struct EnterFactoryTestMode
{
  Anki::Cozmo::RobotInterface::FactoryTestMode mode;
  int32_t param;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 8;
  static const uint32_t MIN_SIZE = 8;
  inline uint32_t Size() const { return 8; }
  
};

// MESSAGE EnableTestStateMessage
struct EnableTestStateMessage
{
  bool enable;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1;
  static const uint32_t MIN_SIZE = 1;
  inline uint32_t Size() const { return 1; }
  
};

// MESSAGE TestState
struct TestState
{
  int32_t speedsFixed[4];
  int32_t positionsFixed[4];
  uint32_t cliffLevel;
  int16_t gyro[3];
  int16_t acc[3];
  uint8_t battVolt10x;
  uint8_t extVolt10x;
  uint8_t chargeStat;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 51;
  static const uint32_t MIN_SIZE = 51;
  inline uint32_t Size() const { return 51; }
  
};

// MESSAGE FactoryTestParameter
struct FactoryTestParameter
{
  int32_t param;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 4;
  static const uint32_t MIN_SIZE = 4;
  inline uint32_t Size() const { return 4; }
  
};

} // namespace RobotInterface

} // namespace Cozmo

} // namespace Anki

#endif // __CLAD_TYPES_FW_TEST_MESSAGES_H__
