// Autogenerated C++ Lite (embedded) message buffer code.
// Source: clad/types/imageTypes.clad
// Full command line: ../../tools/message-buffers/emitters/CPPLite_emitter.py --max-message-size 1400 -C ./src/ -I -o ../generated/clad//robot/ clad/types/imageTypes.clad

#include "clad/types/imageTypes.h"

namespace Anki {

namespace Cozmo {

#ifdef CLAD_DEBUG
const char* ImageResolutionToString(ImageResolution m)
{
  switch(m) {
    case VerificationSnapshot:
      return "VerificationSnapshot";
    case QQQQVGA:
      return "QQQQVGA";
    case QQQVGA:
      return "QQQVGA";
    case QQVGA:
      return "QQVGA";
    case QVGA:
      return "QVGA";
    case CVGA:
      return "CVGA";
    case VGA:
      return "VGA";
    case SVGA:
      return "SVGA";
    case XGA:
      return "XGA";
    case SXGA:
      return "SXGA";
    case UXGA:
      return "UXGA";
    case QXGA:
      return "QXGA";
    case QUXGA:
      return "QUXGA";
    case ImageResolutionCount:
      return "ImageResolutionCount";
    case ImageResolutionNone:
      return "ImageResolutionNone";
    default:
      return 0;
  }
}
#endif // CLAD_DEBUG

#ifdef CLAD_DEBUG
const char* ImageEncodingToString(ImageEncoding m)
{
  switch(m) {
    case NoneImageEncoding:
      return "NoneImageEncoding";
    case RawGray:
      return "RawGray";
    case RawRGB:
      return "RawRGB";
    case YUYV:
      return "YUYV";
    case BAYER:
      return "BAYER";
    case JPEGGray:
      return "JPEGGray";
    case JPEGColor:
      return "JPEGColor";
    case JPEGColorHalfWidth:
      return "JPEGColorHalfWidth";
    case JPEGMinimizedGray:
      return "JPEGMinimizedGray";
    case JPEGMinimizedColor:
      return "JPEGMinimizedColor";
    default:
      return 0;
  }
}
#endif // CLAD_DEBUG

#ifdef CLAD_DEBUG
const char* ImageSendModeToString(ImageSendMode m)
{
  switch(m) {
    case Off:
      return "Off";
    case Stream:
      return "Stream";
    case SingleShot:
      return "SingleShot";
    default:
      return 0;
  }
}
#endif // CLAD_DEBUG

#ifdef CLAD_DEBUG
const char* ImageConstantsToString(ImageConstants m)
{
  switch(m) {
    case IMAGE_CHUNK_SIZE:
      return "IMAGE_CHUNK_SIZE";
    default:
      return 0;
  }
}
#endif // CLAD_DEBUG

bool ImageChunk::IsValid() const
{
    return (data_length <= 1200);
}

uint32_t ImageChunk::Size() const
{
  uint32_t result = 0;
  // frameTimeStamp
  result += 4; // uint_32
  // imageId
  result += 4; // uint_32
  // chunkDebug
  result += 4; // int_32
  // imageEncoding
  result += 1; // ImageEncoding
  // resolution
  result += 1; // ImageResolution
  // imageChunkCount
  result += 1; // uint_8
  // chunkId
  result += 1; // uint_8
  // data
  result += 2; // uint_16 (data_length)
  result += 1 * this->data_length; // uint_8
  return result;
}

} // namespace Cozmo

} // namespace Anki

