// Autogenerated C++ Lite (embedded) message buffer code.
// Source: clad/types/imageTypes.clad
// Full command line: ../../tools/message-buffers/emitters/CPPLite_emitter.py --max-message-size 1400 -C ./src/ -I -o ../generated/clad//robot/ clad/types/imageTypes.clad

#ifndef __CLAD_TYPES_IMAGE_TYPES_H__
#define __CLAD_TYPES_IMAGE_TYPES_H__

#include <stdbool.h>
#include <stdint.h>

namespace Anki {

namespace Cozmo {

// ENUM ImageResolution
enum {
  VerificationSnapshot, // 0
  QQQQVGA,              // 1
  QQQVGA,               // 2
  QQVGA,                // 3
  QVGA,                 // 4
  CVGA,                 // 5
  VGA,                  // 6
  SVGA,                 // 7
  XGA,                  // 8
  SXGA,                 // 9
  UXGA,                 // 10
  QXGA,                 // 11
  QUXGA,                // 12
  ImageResolutionCount, // 13
  ImageResolutionNone,  // 14
};
typedef int8_t ImageResolution;

#ifdef CLAD_DEBUG
const char* ImageResolutionToString(ImageResolution m);
#endif // CLAD_DEBUG

// ENUM ImageEncoding
enum {
  NoneImageEncoding,  // 0
  RawGray,            // 1
  RawRGB,             // 2
  YUYV,               // 3
  BAYER,              // 4
  JPEGGray,           // 5
  JPEGColor,          // 6
  JPEGColorHalfWidth, // 7
  JPEGMinimizedGray,  // 8
  JPEGMinimizedColor, // 9
};
typedef uint8_t ImageEncoding;

#ifdef CLAD_DEBUG
const char* ImageEncodingToString(ImageEncoding m);
#endif // CLAD_DEBUG

// ENUM ImageSendMode
enum {
  Off,        // 0
  Stream,     // 1
  SingleShot, // 2
};
typedef uint8_t ImageSendMode;

#ifdef CLAD_DEBUG
const char* ImageSendModeToString(ImageSendMode m);
#endif // CLAD_DEBUG

// ENUM ImageConstants
enum {
  IMAGE_CHUNK_SIZE = 1200, // 1200
};
typedef uint32_t ImageConstants;

#ifdef CLAD_DEBUG
const char* ImageConstantsToString(ImageConstants m);
#endif // CLAD_DEBUG

// MESSAGE ImageChunk
struct ImageChunk
{
  uint32_t frameTimeStamp;
  uint32_t imageId;
  int32_t chunkDebug;
  Anki::Cozmo::ImageEncoding imageEncoding;
  Anki::Cozmo::ImageResolution resolution;
  uint8_t imageChunkCount;
  uint8_t chunkId;
  uint16_t data_length;
  uint8_t data[1200];
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const;
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1218;
  static const uint32_t MIN_SIZE = 18;
  uint32_t Size() const;
  
};

// MESSAGE ImageImuData
struct ImageImuData
{
  uint32_t imageId;
  float rateX;
  float rateY;
  float rateZ;
  uint8_t line2Number;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 17;
  static const uint32_t MIN_SIZE = 17;
  inline uint32_t Size() const { return 17; }
  
};

// MESSAGE CameraCalibration
struct CameraCalibration
{
  float focalLength_x;
  float focalLength_y;
  float center_x;
  float center_y;
  float skew;
  uint16_t nrows;
  uint16_t ncols;
  float distCoeffs[8];
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 56;
  static const uint32_t MIN_SIZE = 56;
  inline uint32_t Size() const { return 56; }
  
};

} // namespace Cozmo

} // namespace Anki

#endif // __CLAD_TYPES_IMAGE_TYPES_H__
