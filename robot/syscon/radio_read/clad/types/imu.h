// Autogenerated C++ Lite (embedded) message buffer code.
// Source: clad/types/imu.clad
// Full command line: ../../tools/message-buffers/emitters/CPPLite_emitter.py --max-message-size 1400 -C ./src/ -I -o ../generated/clad//robot/ clad/types/imu.clad

#ifndef __CLAD_TYPES_IMU_H__
#define __CLAD_TYPES_IMU_H__

#include <stdbool.h>
#include <stdint.h>

namespace Anki {

namespace Cozmo {

// ENUM IMUConstants
enum {
  IMU_CHUNK_SIZE = 8, // 8
};
typedef uint8_t IMUConstants;

#ifdef CLAD_DEBUG
const char* IMUConstantsToString(IMUConstants m);
#endif // CLAD_DEBUG

namespace RobotInterface {

// STRUCTURE IMUDataChunk
struct IMUDataChunk
{
  float aX[8];
  float aY[8];
  float aZ[8];
  float gX[8];
  float gY[8];
  float gZ[8];
  uint8_t seqId;
  uint8_t chunkId;
  uint8_t totalNumChunks;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 195;
  static const uint32_t MIN_SIZE = 195;
  inline uint32_t Size() const { return 195; }
  
};

// STRUCTURE IMURawDataChunk
struct IMURawDataChunk
{
  int16_t g[3];
  int16_t a[3];
  uint8_t order;
  uint8_t timestamp;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 14;
  static const uint32_t MIN_SIZE = 14;
  inline uint32_t Size() const { return 14; }
  
};

// STRUCTURE ImuRequest
struct ImuRequest
{
  uint32_t length_ms;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 4;
  static const uint32_t MIN_SIZE = 4;
  inline uint32_t Size() const { return 4; }
  
};

// STRUCTURE IMUCalibrationData
struct IMUCalibrationData
{
  int16_t gyro[3];
  int16_t acc[3];
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 12;
  static const uint32_t MIN_SIZE = 12;
  inline uint32_t Size() const { return 12; }
  
};

} // namespace RobotInterface

} // namespace Cozmo

} // namespace Anki

#endif // __CLAD_TYPES_IMU_H__
