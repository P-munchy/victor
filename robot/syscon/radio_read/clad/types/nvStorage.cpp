// Autogenerated C++ Lite (embedded) message buffer code.
// Source: clad/types/nvStorage.clad
// Full command line: ../../tools/message-buffers/emitters/CPPLite_emitter.py --max-message-size 1400 -C ./src/ -I -o ../generated/clad//robot/ clad/types/nvStorage.clad

#include "clad/types/nvStorage.h"


namespace Anki {

namespace Cozmo {

namespace NVStorage {

bool NVStorageBlob::IsValid() const
{
    return (blob_length <= 1024);
}

uint32_t NVStorageBlob::Size() const
{
  uint32_t result = 0;
  // tag
  result += 4; // uint_32
  // blob
  result += 4; // uint_32 (blob_length)
  result += 1 * this->blob_length; // uint_8
  return result;
}

#ifdef CLAD_DEBUG
const char* NVReportDestToString(NVReportDest m)
{
  switch(m) {
    case ENGINE:
      return "ENGINE";
    case WIFI:
      return "WIFI";
    case RTIP:
      return "RTIP";
    case BODY:
      return "BODY";
    default:
      return 0;
  }
}
#endif // CLAD_DEBUG

bool NVStorageWrite::IsValid() const
{
    return (this->entry.IsValid());
}

uint32_t NVStorageWrite::Size() const
{
  uint32_t result = 0;
  // reportTo
  result += 1; // NVReportDest
  // writeNotErase
  result += 1; // bool
  // reportEach
  result += 1; // bool
  // reportDone
  result += 1; // bool
  // rangeEnd
  result += 4; // uint_32
  // entry
  result += this->entry.Size(); // NVStorageBlob
  return result;
}

bool NVWipeAll::IsValid() const
{
    return (true);
}

uint32_t NVWipeAll::Size() const
{
  uint32_t result = 0;
  // to
  result += 1; // NVReportDest
  // doSegments
  result += 1; // uint_8
  // includeFactory
  result += 1; // bool
  // reboot
  result += 1; // bool
  // key
  result += 1; // uint_8 (key_length)
  result += 1 * this->key_length; // uint_8
  return result;
}

} // namespace NVStorage

} // namespace Cozmo

} // namespace Anki

