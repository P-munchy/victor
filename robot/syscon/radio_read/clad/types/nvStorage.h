// Autogenerated C++ Lite (embedded) message buffer code.
// Source: clad/types/nvStorage.clad
// Full command line: ../../tools/message-buffers/emitters/CPPLite_emitter.py --max-message-size 1400 -C ./src/ -I -o ../generated/clad//robot/ clad/types/nvStorage.clad

#ifndef __CLAD_TYPES_NV_STORAGE_H__
#define __CLAD_TYPES_NV_STORAGE_H__

#include <stdbool.h>
#include <stdint.h>

#include "clad/types/nvStorageTypes.h"

namespace Anki {

namespace Cozmo {

namespace NVStorage {

// STRUCTURE NVStorageBlob
struct NVStorageBlob
{
  uint32_t tag;
  uint32_t blob_length;
  uint8_t blob[1024];
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const;
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1032;
  static const uint32_t MIN_SIZE = 8;
  uint32_t Size() const;
  
};

// ENUM NVReportDest
enum {
  ENGINE, // 0
  WIFI,   // 1
  RTIP,   // 2
  BODY,   // 3
};
typedef int8_t NVReportDest;

#ifdef CLAD_DEBUG
const char* NVReportDestToString(NVReportDest m);
#endif // CLAD_DEBUG

// MESSAGE NVStorageRead
struct NVStorageRead
{
  uint32_t tag;
  uint32_t tagRangeEnd;
  Anki::Cozmo::NVStorage::NVReportDest to;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 9;
  static const uint32_t MIN_SIZE = 9;
  inline uint32_t Size() const { return 9; }
  
};

// MESSAGE NVStorageWrite
struct NVStorageWrite
{
  Anki::Cozmo::NVStorage::NVReportDest reportTo;
  bool writeNotErase;
  bool reportEach;
  bool reportDone;
  uint32_t rangeEnd;
  Anki::Cozmo::NVStorage::NVStorageBlob entry;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const;
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1040;
  static const uint32_t MIN_SIZE = 16;
  uint32_t Size() const;
  
};

// STRUCTURE NVOpResult
struct NVOpResult
{
  uint32_t tag;
  Anki::Cozmo::NVStorage::NVResult result;
  bool write;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 6;
  static const uint32_t MIN_SIZE = 6;
  inline uint32_t Size() const { return 6; }
  
};

// MESSAGE NVWipeAll
struct NVWipeAll
{
  Anki::Cozmo::NVStorage::NVReportDest to;
  uint8_t doSegments;
  bool includeFactory;
  bool reboot;
  uint8_t key_length;
  char key[255];
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const;
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 260;
  static const uint32_t MIN_SIZE = 5;
  uint32_t Size() const;
  
};

} // namespace NVStorage

} // namespace Cozmo

} // namespace Anki

#endif // __CLAD_TYPES_NV_STORAGE_H__
