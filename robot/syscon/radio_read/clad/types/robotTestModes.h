// Autogenerated C++ Lite (embedded) message buffer code.
// Source: clad/types/robotTestModes.clad
// Full command line: ../../tools/message-buffers/emitters/CPPLite_emitter.py --max-message-size 1400 -C ./src/ -I -o ../generated/clad//robot/ clad/types/robotTestModes.clad

#ifndef __CLAD_TYPES_ROBOT_TEST_MODES_H__
#define __CLAD_TYPES_ROBOT_TEST_MODES_H__

#include <stdbool.h>
#include <stdint.h>

namespace Anki {

namespace Cozmo {

// ENUM TestMode
enum {
  TM_NONE,                              // 0
  TM_PLACE_BLOCK_ON_GROUND,             // 1
  TM_DOCK_PATH,                         // 2
  TM_PATH_FOLLOW,                       // 3
  TM_PATH_FOLLOW_CONVENIENCE_FUNCTIONS, // 4
  TM_DIRECT_DRIVE,                      // 5
  TM_LIFT,                              // 6
  TM_LIFT_TOGGLE,                       // 7
  TM_HEAD,                              // 8
  TM_IMU,                               // 9
  TM_ANIMATION,                         // 10
  TM_LIGHTS,                            // 11
  TM_FACE_DISPLAY,                      // 12
  TM_STOP_TEST,                         // 13
  TM_MAX_POWER_TEST,                    // 14
  TM_FACE_TRACKING,                     // 15
  TM_NUM_TESTS,                         // 16
};
typedef uint8_t TestMode;

#ifdef CLAD_DEBUG
const char* TestModeToString(TestMode m);
#endif // CLAD_DEBUG

// ENUM DriveTestFlags
enum {
  DTF_ENABLE_DIRECT_HAL_TEST   = 0x1, // 1
  DTF_ENABLE_CYCLE_SPEEDS_TEST = 0x2, // 2
  DTF_ENABLE_TOGGLE_DIR        = 0x4, // 4
};
typedef uint8_t DriveTestFlags;

#ifdef CLAD_DEBUG
const char* DriveTestFlagsToString(DriveTestFlags m);
#endif // CLAD_DEBUG

// ENUM LiftTestFlags
enum {
  LiftTF_TEST_POWER     = 0, // 0
  LiftTF_TEST_HEIGHTS,       // 1
  LiftTF_NODDING,            // 2
  LiftTF_DISABLE_MOTOR,      // 3
};
typedef uint8_t LiftTestFlags;

#ifdef CLAD_DEBUG
const char* LiftTestFlagsToString(LiftTestFlags m);
#endif // CLAD_DEBUG

// ENUM HeadTestFlags
enum {
  HTF_TEST_POWER   = 0, // 0
  HTF_TEST_ANGLES,      // 1
  HTF_NODDING,          // 2
};
typedef uint8_t HeadTestFlags;

#ifdef CLAD_DEBUG
const char* HeadTestFlagsToString(HeadTestFlags m);
#endif // CLAD_DEBUG

// ENUM IMUTestFlags
enum {
  ITF_DO_TURNS = 0x1, // 1
};
typedef uint8_t IMUTestFlags;

#ifdef CLAD_DEBUG
const char* IMUTestFlagsToString(IMUTestFlags m);
#endif // CLAD_DEBUG

// ENUM LightTestFlags
enum {
  LTF_CYCLE_ALL = 0x1, // 1
};
typedef uint8_t LightTestFlags;

#ifdef CLAD_DEBUG
const char* LightTestFlagsToString(LightTestFlags m);
#endif // CLAD_DEBUG

// MESSAGE StartControllerTestMode
struct StartControllerTestMode
{
  int32_t p1;
  int32_t p2;
  int32_t p3;
  Anki::Cozmo::TestMode mode;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 13;
  static const uint32_t MIN_SIZE = 13;
  inline uint32_t Size() const { return 13; }
  
};

// MESSAGE RawPWM
struct RawPWM
{
  int16_t pwm[4];
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 8;
  static const uint32_t MIN_SIZE = 8;
  inline uint32_t Size() const { return 8; }
  
};

} // namespace Cozmo

} // namespace Anki

#endif // __CLAD_TYPES_ROBOT_TEST_MODES_H__
