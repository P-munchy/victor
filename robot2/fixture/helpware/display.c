#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>
#include <assert.h>
#include <string.h>
#include <ctype.h>
#include <fcntl.h>
#include <unistd.h>


#include "core/common.h"
#include "core/lcd.h"

/*************/
//#include "fonts.h
#define DISPLAY_LINE_COUNT (LCD_FRAME_HEIGHT/SMALL_FONT_HEIGHT)


static const uint8_t gSmallFont[] = {
     0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x5F,0x00,0x00, 0x00,0x07,0x00,0x07,0x00, 0x14,0x7F,0x14,0x7F,0x14,
     0x3E,0x7F,0x63,0x7F,0x3E, 0x23,0x13,0x08,0x64,0x62, 0x0C,0x3C,0x3C,0x3C,0x0C, 0x00,0x08,0x07,0x03,0x00,

     0x00,0x1C,0x22,0x41,0x00, 0x00,0x41,0x22,0x1C,0x00, 0x2A,0x1C,0x7F,0x1C,0x2A, 0x08,0x08,0x3E,0x08,0x08,
     0x00,0x80,0x70,0x30,0x00, 0x08,0x08,0x08,0x08,0x08, 0x00,0x00,0x60,0x60,0x00, 0x20,0x10,0x08,0x04,0x02,
     0x3E,0x51,0x49,0x45,0x3E, 0x00,0x42,0x7F,0x40,0x00, 0x72,0x49,0x49,0x49,0x46, 0x21,0x41,0x49,0x4D,0x33,
     0x18,0x14,0x12,0x7F,0x10, 0x27,0x45,0x45,0x45,0x39, 0x3C,0x4A,0x49,0x49,0x31, 0x41,0x21,0x11,0x09,0x07,
     0x36,0x49,0x49,0x49,0x36, 0x46,0x49,0x49,0x29,0x1E, 0x00,0x00,0x14,0x00,0x00, 0x00,0x40,0x34,0x00,0x00,
     0x00,0x08,0x14,0x22,0x41, 0x14,0x14,0x14,0x14,0x14, 0x00,0x41,0x22,0x14,0x08, 0x02,0x01,0x59,0x09,0x06,
     0x3E,0x41,0x5D,0x59,0x4E, 0x7C,0x12,0x11,0x12,0x7C, 0x7F,0x49,0x49,0x49,0x36, 0x3E,0x41,0x41,0x41,0x22,
     0x7F,0x41,0x41,0x41,0x3E, 0x7F,0x49,0x49,0x49,0x41, 0x7F,0x09,0x09,0x09,0x01, 0x3E,0x41,0x41,0x51,0x73,
     0x7F,0x08,0x08,0x08,0x7F, 0x00,0x41,0x7F,0x41,0x00, 0x20,0x40,0x41,0x3F,0x01, 0x7F,0x08,0x14,0x22,0x41,
     0x7F,0x40,0x40,0x40,0x40, 0x7F,0x02,0x1C,0x02,0x7F, 0x7F,0x04,0x08,0x10,0x7F, 0x3E,0x41,0x41,0x41,0x3E,
     0x7F,0x09,0x09,0x09,0x06, 0x3E,0x41,0x51,0x21,0x5E, 0x7F,0x09,0x19,0x29,0x46, 0x26,0x49,0x49,0x49,0x32,
     0x03,0x01,0x7F,0x01,0x03, 0x3F,0x40,0x40,0x40,0x3F, 0x1F,0x20,0x40,0x20,0x1F, 0x3F,0x40,0x38,0x40,0x3F,
     0x63,0x14,0x08,0x14,0x63, 0x03,0x04,0x78,0x04,0x03, 0x61,0x59,0x49,0x4D,0x43, 0x00,0x7F,0x41,0x41,0x41,
     0x02,0x04,0x08,0x10,0x20, 0x00,0x41,0x41,0x41,0x7F, 0x04,0x02,0x01,0x02,0x04, 0x40,0x40,0x40,0x40,0x40,
     0x00,0x03,0x07,0x08,0x00, 0x20,0x54,0x54,0x78,0x40, 0x7F,0x28,0x44,0x44,0x38, 0x38,0x44,0x44,0x44,0x28,
     0x38,0x44,0x44,0x28,0x7F, 0x38,0x54,0x54,0x54,0x18, 0x00,0x08,0x7E,0x09,0x02, 0x18,0xA4,0xA4,0x9C,0x78,
     0x7F,0x08,0x04,0x04,0x78, 0x00,0x44,0x7D,0x40,0x00, 0x20,0x40,0x40,0x3D,0x00, 0x7F,0x10,0x28,0x44,0x00,
     0x00,0x41,0x7F,0x40,0x00, 0x7C,0x04,0x78,0x04,0x78, 0x7C,0x08,0x04,0x04,0x78, 0x38,0x44,0x44,0x44,0x38,
     0xFC,0x18,0x24,0x24,0x18, 0x18,0x24,0x24,0x18,0xFC, 0x7C,0x08,0x04,0x04,0x08, 0x48,0x54,0x54,0x54,0x24,
     0x04,0x04,0x3F,0x44,0x24, 0x3C,0x40,0x40,0x20,0x7C, 0x1C,0x20,0x40,0x20,0x1C, 0x3C,0x40,0x30,0x40,0x3C,
     0x44,0x28,0x10,0x28,0x44, 0x4C,0x90,0x90,0x90,0x7C, 0x44,0x64,0x54,0x4C,0x44, 0x00,0x08,0x36,0x41,0x00,
     0x00,0x00,0x77,0x00,0x00, 0x00,0x41,0x36,0x08,0x00, 0x02,0x01,0x02,0x04,0x02, 0x3C,0x26,0x23,0x26,0x3C
  };


#define SMALL_FONT_WIDTH 5
#define SMALL_FONT_HEIGHT 8
#define SMALL_FONT_CHARS_PER_LINE (LCD_FRAME_WIDTH/(SMALL_FONT_WIDTH+1))

#define SMALL_FONT_CHAR_START 32
#define SMALL_FONT_CHAR_END  127
#define SMALL_FONT_UNPRINTABLE (127-SMALL_FONT_CHAR_START)




static const uint8_t gHugeFont[] = {
     0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x5F,0x00,0x00, 0x00,0x07,0x00,0x07,0x00, 0x14,0x7F,0x14,0x7F,0x14,
     0x3E,0x7F,0x63,0x7F,0x3E, 0x23,0x13,0x08,0x64,0x62, 0x0C,0x3C,0x3C,0x3C,0x0C, 0x00,0x08,0x07,0x03,0x00,

     0x00,0x1C,0x22,0x41,0x00, 0x00,0x41,0x22,0x1C,0x00, 0x2A,0x1C,0x7F,0x1C,0x2A, 0x08,0x08,0x3E,0x08,0x08,
     0x00,0x80,0x70,0x30,0x00, 0x08,0x08,0x08,0x08,0x08, 0x00,0x00,0x60,0x60,0x00, 0x20,0x10,0x08,0x04,0x02,
     0x3E,0x51,0x49,0x45,0x3E, 0x00,0x42,0x7F,0x40,0x00, 0x72,0x49,0x49,0x49,0x46, 0x21,0x41,0x49,0x4D,0x33,
     0x18,0x14,0x12,0x7F,0x10, 0x27,0x45,0x45,0x45,0x39, 0x3C,0x4A,0x49,0x49,0x31, 0x41,0x21,0x11,0x09,0x07,
     0x36,0x49,0x49,0x49,0x36, 0x46,0x49,0x49,0x29,0x1E, 0x00,0x00,0x14,0x00,0x00, 0x00,0x40,0x34,0x00,0x00,
     0x00,0x08,0x14,0x22,0x41, 0x14,0x14,0x14,0x14,0x14, 0x00,0x41,0x22,0x14,0x08, 0x02,0x01,0x59,0x09,0x06,
     0x3E,0x41,0x5D,0x59,0x4E, 0x7C,0x12,0x11,0x12,0x7C, 0x7F,0x49,0x49,0x49,0x36, 0x3E,0x41,0x41,0x41,0x22,
     0x7F,0x41,0x41,0x41,0x3E, 0x7F,0x49,0x49,0x49,0x41, 0x7F,0x09,0x09,0x09,0x01, 0x3E,0x41,0x41,0x51,0x73,
     0x7F,0x08,0x08,0x08,0x7F, 0x00,0x41,0x7F,0x41,0x00, 0x20,0x40,0x41,0x3F,0x01, 0x7F,0x08,0x14,0x22,0x41,
     0x7F,0x40,0x40,0x40,0x40, 0x7F,0x02,0x1C,0x02,0x7F, 0x7F,0x04,0x08,0x10,0x7F, 0x3E,0x41,0x41,0x41,0x3E,
     0x7F,0x09,0x09,0x09,0x06, 0x3E,0x41,0x51,0x21,0x5E, 0x7F,0x09,0x19,0x29,0x46, 0x26,0x49,0x49,0x49,0x32,
     0x03,0x01,0x7F,0x01,0x03, 0x3F,0x40,0x40,0x40,0x3F, 0x1F,0x20,0x40,0x20,0x1F, 0x3F,0x40,0x38,0x40,0x3F,
     0x63,0x14,0x08,0x14,0x63, 0x03,0x04,0x78,0x04,0x03, 0x61,0x59,0x49,0x4D,0x43, 0x00,0x7F,0x41,0x41,0x41,
     0x02,0x04,0x08,0x10,0x20, 0x00,0x41,0x41,0x41,0x7F, 0x04,0x02,0x01,0x02,0x04, 0x40,0x40,0x40,0x40,0x40,
     0x00,0x03,0x07,0x08,0x00, 0x20,0x54,0x54,0x78,0x40, 0x7F,0x28,0x44,0x44,0x38, 0x38,0x44,0x44,0x44,0x28,
     0x38,0x44,0x44,0x28,0x7F, 0x38,0x54,0x54,0x54,0x18, 0x00,0x08,0x7E,0x09,0x02, 0x18,0xA4,0xA4,0x9C,0x78,
     0x7F,0x08,0x04,0x04,0x78, 0x00,0x44,0x7D,0x40,0x00, 0x20,0x40,0x40,0x3D,0x00, 0x7F,0x10,0x28,0x44,0x00,
     0x00,0x41,0x7F,0x40,0x00, 0x7C,0x04,0x78,0x04,0x78, 0x7C,0x08,0x04,0x04,0x78, 0x38,0x44,0x44,0x44,0x38,
     0xFC,0x18,0x24,0x24,0x18, 0x18,0x24,0x24,0x18,0xFC, 0x7C,0x08,0x04,0x04,0x08, 0x48,0x54,0x54,0x54,0x24,
     0x04,0x04,0x3F,0x44,0x24, 0x3C,0x40,0x40,0x20,0x7C, 0x1C,0x20,0x40,0x20,0x1C, 0x3C,0x40,0x30,0x40,0x3C,
     0x44,0x28,0x10,0x28,0x44, 0x4C,0x90,0x90,0x90,0x7C, 0x44,0x64,0x54,0x4C,0x44, 0x00,0x08,0x36,0x41,0x00,
     0x00,0x00,0x77,0x00,0x00, 0x00,0x41,0x36,0x08,0x00, 0x02,0x01,0x02,0x04,0x02, 0x3C,0x26,0x23,0x26,0x3C
  };



#define HUGE_FONT_WIDTH 15
#define HUGE_FONT_HEIGHT 24
#define HUGE_FONT_CHARS_PER_LINE (LCD_FRAME_WIDTH/(HUGE_FONT_WIDTH+1))

#define HUGE_FONT_CHAR_START 32
#define HUGE_FONT_CHAR_END  127
#define HUGE_FONT_UNPRINTABLE (127-HUGE_FONT_CHAR_START)


#define HUGE_FONT_START_LINE 7
#define HUGE_FONT_LINE_SPAN 3
#define HUGE_TEXT_PROP_LINE DISPLAY_LINE_COUNT
/****************/


#define TERMBUFSZ 80
#define LINEBUFSZ 256


typedef enum {
  layer_NONE = 0,
  layer_SMALL_TEXT=1,
  layer_HUGE_TEXT = 2,
  layer_ALL_TEXT = 3,
} DisplayLayer;
#define DISPLAY_NUM_LAYERS 2

#define isdot(ch) ('.'==(ch))
#define isdash(ch) ('-'==(ch))


// W  x H
//184 x 96 pixels
//5 x 8 font.
// 30 chars x 12 lines
//--or
//15 x 24 font
// 11 chars x 12 lines.

LcdFrame textbuffer;

//each byte represents a block of 8 vertical pixels
uint8_t textmap[LCD_FRAME_WIDTH * LCD_FRAME_HEIGHT/8];

typedef struct TextProperties_t {
  uint16_t fg;
  uint16_t bg;
} TextProperties;


struct {
  char hugetext[HUGE_FONT_CHARS_PER_LINE];
  char smalltext[DISPLAY_LINE_COUNT][SMALL_FONT_CHARS_PER_LINE];
  uint8_t bitmap[LCD_FRAME_WIDTH * LCD_FRAME_HEIGHT/8];
  TextProperties textprop[DISPLAY_LINE_COUNT+1];

  LcdFrame frame;
} gDisplay;


static inline int min(int a, int b){  return a<b?a:b;}

void draw_text_small(int line, uint16_t fg, uint16_t bg, const char* text, int len)
{
  assert(line<DISPLAY_LINE_COUNT);
  int nchars =  min(len, SMALL_FONT_CHARS_PER_LINE);
  memset(gDisplay.smalltext[line], ' ', SMALL_FONT_CHARS_PER_LINE);
  strncpy(gDisplay.smalltext[line], text, nchars);
  gDisplay.textprop[line].fg = fg;
  gDisplay.textprop[line].bg = bg;
}

void draw_text_huge(uint16_t fg, uint16_t bg, const char* text, int len)
{
  int nchars = min(len, HUGE_FONT_CHARS_PER_LINE);
  int npad = (HUGE_FONT_CHARS_PER_LINE - nchars )/ 2;
  memset(gDisplay.hugetext, ' ', HUGE_FONT_CHARS_PER_LINE);
  strncpy(gDisplay.hugetext+npad, text, nchars);
  gDisplay.textprop[HUGE_TEXT_PROP_LINE].fg = fg;
  gDisplay.textprop[HUGE_TEXT_PROP_LINE].bg = bg;
}

void display_render_small_text(uint8_t* bitmap)
{
  //bitmap is FRAME_HEIGHT/8 lines of FRAME_WIDTH pixels.
  // each entry contains 8 rows.
  int line,col;

  for (line=0;line<DISPLAY_LINE_COUNT;line++)
  {
    uint8_t* map = &bitmap[line*LCD_FRAME_WIDTH];
    const char* text = gDisplay.smalltext[line];
    for (col=0;col<SMALL_FONT_CHARS_PER_LINE; col++)
    {
      unsigned char c = *text++;
      c -= SMALL_FONT_CHAR_START;
      if (c > SMALL_FONT_CHAR_END - SMALL_FONT_CHAR_START) {
        c = SMALL_FONT_UNPRINTABLE;
      }
      const uint8_t* glyph = &gSmallFont[c * SMALL_FONT_WIDTH];
      int i;
      for (i=0;i<SMALL_FONT_WIDTH;i++)
      {
        *map++ = *glyph++;
      }
      *map++ = 0; //char separator
    }
  }
}

#define HUGE_FONT_LINE_SPAN 3
void display_render_huge_text(uint8_t* bitmap)
{
  int line,col;

  uint8_t* map[HUGE_FONT_LINE_SPAN];
  for (line=0;line<HUGE_FONT_LINE_SPAN;line++){
    map[line] = &bitmap[(HUGE_FONT_START_LINE+line) * LCD_FRAME_WIDTH];
  }
  const char* text = gDisplay.hugetext;
  for (col=0;col<HUGE_FONT_CHARS_PER_LINE; col++)
  {
    unsigned char c = *text++;
    c -= HUGE_FONT_CHAR_START;
    if (c > HUGE_FONT_CHAR_END - HUGE_FONT_CHAR_START) {
      c = HUGE_FONT_UNPRINTABLE;
    }
    const uint8_t* glyph = &gHugeFont[c * HUGE_FONT_WIDTH * HUGE_FONT_LINE_SPAN];
    int i;
    for (i=0;i<HUGE_FONT_WIDTH;i++)
    {
      for (line=0;line<HUGE_FONT_LINE_SPAN;line++){
        *map[line]++ = *glyph++;
      }
    }
  }
}

#define IsCoveredByHugeText(line,mask) \
  ((mask==layer_HUGE_TEXT) || ((mask&layer_HUGE_TEXT)&&                 \
                               (line>=HUGE_FONT_START_LINE)&&            \
                               (line<HUGE_FONT_START_LINE+HUGE_FONT_LINE_SPAN)))

static inline const TextProperties* get_textprops(int y, uint8_t layermask)
{
  int line = y/SMALL_FONT_HEIGHT;
  if (IsCoveredByHugeText(line, layermask)) {
    line = HUGE_TEXT_PROP_LINE;
  }
  return &gDisplay.textprop[line];
}



#define EXTRACT_BIT(map,x,y) \
  (((map)[(x)+((y)/8)*LCD_FRAME_WIDTH]>>((y)%8))&1)


static void display_render_text(uint8_t layermask) {
  //two stage process
  //first render the fonts into a bitmap.
  uint8_t bitmap[LCD_FRAME_WIDTH * LCD_FRAME_HEIGHT/8]={0};
  if (layermask & layer_SMALL_TEXT) {
    display_render_small_text(bitmap);
  }
  if (layermask & layer_HUGE_TEXT) {
    display_render_huge_text(bitmap);
  }
  //second, convert the bitmap to color using the textprop values.
  int x,y;
  for (y=0;y<LCD_FRAME_HEIGHT;y++) {
    const TextProperties* tp = get_textprops(y, layermask);
    for (x=0;x<LCD_FRAME_WIDTH;x++) {
      int isSet = EXTRACT_BIT(bitmap,x,y);
      uint16_t color = (isSet) ? tp->fg : tp->bg;
//      gDisplay.frame.data[y*LCD_FRAME_HEIGHT+x] = color;
      gDisplay.frame.data[x*LCD_FRAME_WIDTH+(LCD_FRAME_HEIGHT-y)] = color;
      printf("%c", color?'X':' ');
    }
    printf("\n");
  }
  lcd_draw_frame(&gDisplay.frame);
}


static inline int hextoint(char digit)
{
  assert(isxdigit(digit));
  if (digit <= '9') return digit-'0';
  if (digit <= 'F') return digit-'A'+10;
  return digit-'a'+10;
}


static const char* parse_color(const char* cp, const char* endp, uint16_t* colorOut)
{
  if (cp<endp) {
    char colorchar=*cp++;
    switch (colorchar) {
      case 'r':
        *colorOut = lcd_RED;
        break;
      case 'g':
        *colorOut = lcd_GREEN;
        break;
      case 'b':
        *colorOut = lcd_BLUE;
        break;
      case 'w':
        *colorOut = lcd_WHITE;
        break;
      case 'x':
        *colorOut = 0;
        while (cp<endp && isxdigit(*cp)) {
          *colorOut = (*colorOut<<4)+hextoint(*cp++);
        }
        break;
      default:
        *colorOut = lcd_WHITE;
        break;
    }
  }
  return cp;
}


//display layer.line -[rgbi] all the following words
int display_parse(const char* command, int linelen)
{
  int layer=0, line=1, invert = 0;
  uint16_t  fgcolor=lcd_WHITE, bgcolor = lcd_BLACK;
  const char* cp = command;
  const char* endp = cp+linelen;

  //skip spaces
  while (cp<endp && isspace(*cp)) { cp++;}
  printf("advanced to >%s\n", cp);

  //layer & line : layer[.line]
  if (cp<endp && isdigit(*cp)){
    layer = *cp++ - '0';
    if (layer >= DISPLAY_NUM_LAYERS) {layer = 0; }
  }
  if (cp<endp && isdot(*cp)) {
    cp++;
    if (cp<endp && isdigit(*cp)) {
      line = *cp++ - '0';
      if (line > DISPLAY_LINE_COUNT) { line = 1; }
    }
  }
  printf("l.l = %d.%d.  >%s\n", layer,line, cp);

  //skip spaces
  while (cp<endp && isspace(*cp)) { cp++;}
  printf("advanced to >%s\n", cp);

  // color code: -[i](rgbw|x0000)
  //   -w = white
  //   -ir = inverse red
  //   -xF81F = purple
  if (cp<endp && isdash(*cp)) {
    cp++;
    if (cp<endp  && ('i' == *cp)) {
      invert=1;
      cp++;
    }
    cp = parse_color(cp, endp, &fgcolor);
  }
  printf("color = %c%04x >%s\n", invert?'i':' ', fgcolor, cp);
  if (invert) {
    uint16_t swap = bgcolor;
    bgcolor = fgcolor;
    fgcolor = swap;
  }

  //skip spaces
  while (cp<endp && isspace(*cp)) { cp++;}
  printf("advanced to >%s\n", cp);

  DisplayLayer hidemask = layer_ALL_TEXT;
  switch (layer) {
    case 0:
    {
      int lastline = line;
      //line0 means apply to all
      (line==0) ? lastline = DISPLAY_LINE_COUNT : (line-=1);
      for ( ; line<lastline; line++) {
        draw_text_small(line, fgcolor, bgcolor, cp, endp-cp);  //5x8
      }
      break;
    }
    case 1:
      hidemask = line ? layer_HUGE_TEXT : layer_ALL_TEXT;
      draw_text_huge(fgcolor, bgcolor, cp, endp-cp); //15x24?
      break;
    default:
      assert(!layer); //invalid layer
      break;
  }
  display_render_text(hidemask);
  return 0;

}

void on_exit(void) {
  lcd_shutdown();
}

int main(int argc, const char* argv[])
{
  bool exit = false;
  static char linebuf[LINEBUFSZ];
  int linelen = 0;

  dprintf("Initializing\n");

  lcd_init();

//  gDisplay.serialFd = serial_init(FIXTURE_TTY, FIXTURE_BAUD);

  while (!exit)
  {
    int nread = read(0, linebuf+linelen, LINEBUFSZ-linelen);
    printf("%s",linebuf);
    if (nread<0) { exit = true; break; }
    char* endl = memchr(linebuf+linelen, '\n', nread);
    if (!endl) {
      linelen+=nread;
      if (linelen >= LINEBUFSZ)
      {
        printf("TOO MANY CHARACTERS, truncating to %d\n", LINEBUFSZ);
        endl = linebuf+LINEBUFSZ-1;
        *endl = '\n';
      }
    }
    if (endl) {
      printf("parsing \"%s\"\n", linebuf);
      display_parse(linebuf, endl-linebuf);
      linelen = 0;
    }
  }
  return 0;
}
