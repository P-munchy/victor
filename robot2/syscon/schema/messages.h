// Autogenerated C++ Lite (embedded) message buffer code.
// Source: schema/messages.clad
// Full command line: ../../tools/message-buffers/emitters/CPPLite_emitter.py ./schema/messages.clad -r build -o build

#ifndef __SCHEMA_MESSAGES_H__
#define __SCHEMA_MESSAGES_H__

#include <stdbool.h>
#include <stdint.h>

namespace Anki {

namespace Cozmo {

namespace Spine {

// ENUM SpineSync
enum {
  SYNC_BODY_TO_HEAD = 0x483242aa,
  SYNC_HEAD_TO_BODY = 0x423248aa,
};
typedef uint32_t SpineSync;

#ifdef CLAD_DEBUG
const char* SpineSyncToString(SpineSync m);
#endif // CLAD_DEBUG

// ENUM RobotMotor
enum {
  MOTOR_LEFT  = 0,
  MOTOR_RIGHT = 1,
  MOTOR_LIFT  = 2,
  MOTOR_HEAD  = 3,
  MOTOR_COUNT = 4,
};
typedef uint32_t RobotMotor;

#ifdef CLAD_DEBUG
const char* RobotMotorToString(RobotMotor m);
#endif // CLAD_DEBUG

// ENUM DropSensor
enum {
  DROP_SENSOR_FRONT_LEFT  = 0,
  DROP_SENSOR_FRONT_RIGHT = 1,
  DROP_SENSOR_BACK_LEFT   = 2,
  DROP_SENSOR_BACK_RIGHT  = 3,
  DROP_SENSOR_COUNT       = 4,
};
typedef uint32_t DropSensor;

#ifdef CLAD_DEBUG
const char* DropSensorToString(DropSensor m);
#endif // CLAD_DEBUG

// ENUM PayloadId
enum {
  PAYLOAD_DATA_FRAME  = 0x6466,
  PAYLOAD_MODE_CHANGE = 0x6d64,
  PAYLOAD_VERSION     = 0x7276,
  PAYLOAD_ACK         = 0x6b61,
  PAYLOAD_ERASE       = 0x7878,
  PAYLOAD_VALIDATE    = 0x7374,
  PAYLOAD_DFU_PACKET  = 0x6675,
  PAYLOAD_TYPE_COUNT  = 7,     
};
typedef uint16_t PayloadId;

#ifdef CLAD_DEBUG
const char* PayloadIdToString(PayloadId m);
#endif // CLAD_DEBUG

// ENUM Ack
enum {
  ACK_PAYLOAD       = 1, 
  NACK_CRC_FAILED   = -1,
  NACK_NOT_ERASED   = -2,
  NACK_FLASH_FAILED = -3,
  NACK_CERT_FAILED  = -4,
  NACK_BAD_ADDRESS  = -5,
  NACK_SIZE_ALIGN   = -6,
  NACK_BAD_COMMAND  = -7,
  NACK_NOT_VALID    = -8,
};
typedef int32_t Ack;

#ifdef CLAD_DEBUG
const char* AckToString(Ack m);
#endif // CLAD_DEBUG

// ENUM BatteryFlags
enum {
  isCharging  = 0x1,
  isOnCharger = 0x2,
  chargerOOS  = 0x4,
};
typedef uint32_t BatteryFlags;

#ifdef CLAD_DEBUG
const char* BatteryFlagsToString(BatteryFlags m);
#endif // CLAD_DEBUG

// ENUM PowerState
enum {
  POWER_STATE_OFF               = 0,
  POWER_STATE_OFF_WAKE_ON_RADIO = 1,
  POWER_STATE_ON                = 2,
  POWER_STATE_IDLE              = 3,
  POWER_STATE_FORCE_RECOVERY    = 4,
  POWER_STATE_OTA_MODE          = 5,
  POWER_STATE_CHARGER_TEST_MODE = 6,
  POWER_STATE_DTM_MODE          = 7,
};
typedef uint16_t PowerState;

#ifdef CLAD_DEBUG
const char* PowerStateToString(PowerState m);
#endif // CLAD_DEBUG

// ENUM LedIndexes
enum {
  LED0_RED    = 0, 
  LED0_GREEN  = 1, 
  LED0_BLUE   = 2, 
  LED1_RED    = 3, 
  LED1_GREEN  = 4, 
  LED1_BLUE   = 5, 
  LED2_RED    = 6, 
  LED2_GREEN  = 7, 
  LED2_BLUE   = 8, 
  LED3_RED    = 9, 
  LED3_GREEN  = 10,
  LED3_BLUE   = 11,
  LED_UNUSED1 = 12,
  LED_UNUSED2 = 13,
  LED_UNUSED3 = 14,
  LED_COUNT   = 15,
};
typedef uint32_t LedIndexes;
#define LED_CHANEL_CT 3  //RGB

#ifdef CLAD_DEBUG
const char* LedIndexesToString(LedIndexes m);
#endif // CLAD_DEBUG

// ENUM ProxSensorCommands
enum {
  CMD_STOP         = 0,
  CMD_RUN          = 1,
  CALIBRATE        = 2,
  SET_OFFSET       = 3,
  SET_XTALK        = 4,
  SET_RANGING_TIME = 5,
  SET_PERIOD       = 6,
};
typedef uint16_t ProxSensorCommands;

#ifdef CLAD_DEBUG
const char* ProxSensorCommandsToString(ProxSensorCommands m);
#endif // CLAD_DEBUG

// STRUCTURE MotorPower
struct MotorPower
{
  int16_t leftWheel;
  int16_t rightWheel;
  int16_t liftMotor;
  int16_t headMotor;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 8;
  static const uint32_t MIN_SIZE = 8;
  inline uint32_t Size() const { return 8; }
  
};

// STRUCTURE BatteryState
struct BatteryState
{
  int32_t batteryVolts;
  int32_t chargerVolts;
  Anki::Cozmo::Spine::BatteryFlags flags;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 12;
  static const uint32_t MIN_SIZE = 12;
  inline uint32_t Size() const { return 12; }
  
};

// STRUCTURE ButtonState
struct ButtonState
{
  uint16_t level;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 2;
  static const uint32_t MIN_SIZE = 2;
  inline uint32_t Size() const { return 2; }
  
};

// STRUCTURE RangeData
struct RangeData
{
  uint8_t rangeStatus;
  uint8_t spare1;
  uint16_t rangeMM;
  uint16_t signalRate;
  uint16_t ambientRate;
  uint16_t spadCount;
  uint16_t spare2;
  uint32_t calibrationResult;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 16;
  static const uint32_t MIN_SIZE = 16;
  inline uint32_t Size() const { return 16; }
  
};

// STRUCTURE ProcessorStatus
struct ProcessorStatus
{
  uint16_t watchdogCount;
  uint16_t statusBits;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 4;
  static const uint32_t MIN_SIZE = 4;
  inline uint32_t Size() const { return 4; }
  
};

// STRUCTURE ProxControl
struct ProxControl
{
  uint32_t configValue;
  uint32_t commandValue;
  Anki::Cozmo::Spine::ProxSensorCommands command;
  uint16_t spare;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 12;
  static const uint32_t MIN_SIZE = 12;
  inline uint32_t Size() const { return 12; }
  
};

// STRUCTURE MotorState
struct MotorState
{
  int32_t position;
  int32_t delta;
  uint32_t time;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 12;
  static const uint32_t MIN_SIZE = 12;
  inline uint32_t Size() const { return 12; }
  
};

// STRUCTURE SpineMessageHeader
struct SpineMessageHeader
{
  Anki::Cozmo::Spine::SpineSync sync_bytes;
  Anki::Cozmo::Spine::PayloadId payload_type;
  uint16_t bytes_to_follow;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 8;
  static const uint32_t MIN_SIZE = 8;
  inline uint32_t Size() const { return 8; }
  
};

// STRUCTURE SpineMessageFooter
struct SpineMessageFooter
{
  uint32_t checksum;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 4;
  static const uint32_t MIN_SIZE = 4;
  inline uint32_t Size() const { return 4; }
  
};

// STRUCTURE BodyToHead
struct BodyToHead
{
  uint32_t framecounter;
  Anki::Cozmo::Spine::MotorState motor[4];
  uint16_t cliffSense[4];
  Anki::Cozmo::Spine::BatteryState battery;
  Anki::Cozmo::Spine::RangeData proximity;
  uint16_t touchLevel[2];
  int16_t audio[320];
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 732;
  static const uint32_t MIN_SIZE = 732;
  inline uint32_t Size() const { return 732; }
  
};

// STRUCTURE HeadToBody
struct HeadToBody
{
  uint32_t framecounter;
  int16_t motorPower[4];
  uint8_t ledColors[16];
  Anki::Cozmo::Spine::ProxControl proxCmd;
  Anki::Cozmo::Spine::PowerState powerState;
  uint16_t spare;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 44;
  static const uint32_t MIN_SIZE = 44;
  inline uint32_t Size() const { return 44; }
  
};

// STRUCTURE AckMessage
struct AckMessage
{
  Anki::Cozmo::Spine::Ack status;
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 4;
  static const uint32_t MIN_SIZE = 4;
  inline uint32_t Size() const { return 4; }
  
};

// STRUCTURE WriteDFU
struct WriteDFU
{
  uint16_t address;
  uint16_t wordCount;
  uint32_t data[256];
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 1028;
  static const uint32_t MIN_SIZE = 1028;
  inline uint32_t Size() const { return 1028; }
  
};

// STRUCTURE VersionInfo
struct VersionInfo
{
  uint32_t hw_revision;
  uint32_t hw_model;
  uint8_t ein[16];
  uint8_t app_version[16];
  
  /**** Cast to/from buffer, adjusting any padding. ****/
  inline uint8_t* GetBuffer() { return reinterpret_cast<uint8_t*>(this); }
  inline const uint8_t* GetBuffer() const { return reinterpret_cast<const uint8_t*>(this); }
  
  /**** Check if current message is parsable. ****/
  bool IsValid() const { return true; }
  
  /**** Serialized size, starting from GetBuffer(). ****/
  static const uint32_t MAX_SIZE = 40;
  static const uint32_t MIN_SIZE = 40;
  inline uint32_t Size() const { return 40; }
  
};

} // namespace Spine

} // namespace Cozmo

} // namespace Anki

#endif // __SCHEMA_MESSAGES_H__
