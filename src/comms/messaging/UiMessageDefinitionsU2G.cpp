// Autogenerated C++ message buffer code.
// Source: UiMessageDefinitionsU2G.clad
// Full command line: ../lib/anki/cozmo-engine/tools/message-buffers/emitters/CPP_emitter.py -o comms/messaging/UiMessageDefinitionsU2G.cpp -r ../include/anki/cozmo/game/comms/messaging/UiMessageDefinitionsU2G.def /Users/gregnage/cozmo-game/src/comms/messaging/UiMessageDefinitionsU2G.clad

#include "../include/anki/cozmo/game/comms/messaging/UiMessageDefinitionsU2G.def"
namespace Anki {
namespace Cozmo {
U2G_Ping::U2G_Ping(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_Ping::U2G_Ping(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_Ping::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_Ping::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->counter);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_Ping::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_Ping::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->counter);
	return buffer.GetBytesRead();
}

size_t U2G_Ping::Size() const
{
	size_t result = 0;
	//counter
	result += 4; // = uint_32
	return result;
}

bool U2G_Ping::operator==(const U2G_Ping& other) const
{
	if (counter != other.counter) {
		return false;
	}
	return true;
}

bool U2G_Ping::operator!=(const U2G_Ping& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_ConnectToRobot::U2G_ConnectToRobot(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_ConnectToRobot::U2G_ConnectToRobot(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_ConnectToRobot::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_ConnectToRobot::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->robotID);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_ConnectToRobot::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_ConnectToRobot::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->robotID);
	return buffer.GetBytesRead();
}

size_t U2G_ConnectToRobot::Size() const
{
	size_t result = 0;
	//robotID
	result += 1; // = uint_8
	return result;
}

bool U2G_ConnectToRobot::operator==(const U2G_ConnectToRobot& other) const
{
	if (robotID != other.robotID) {
		return false;
	}
	return true;
}

bool U2G_ConnectToRobot::operator!=(const U2G_ConnectToRobot& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_ConnectToUiDevice::U2G_ConnectToUiDevice(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_ConnectToUiDevice::U2G_ConnectToUiDevice(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_ConnectToUiDevice::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_ConnectToUiDevice::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->deviceID);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_ConnectToUiDevice::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_ConnectToUiDevice::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->deviceID);
	return buffer.GetBytesRead();
}

size_t U2G_ConnectToUiDevice::Size() const
{
	size_t result = 0;
	//deviceID
	result += 1; // = uint_8
	return result;
}

bool U2G_ConnectToUiDevice::operator==(const U2G_ConnectToUiDevice& other) const
{
	if (deviceID != other.deviceID) {
		return false;
	}
	return true;
}

bool U2G_ConnectToUiDevice::operator!=(const U2G_ConnectToUiDevice& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_DisconnectFromUiDevice::U2G_DisconnectFromUiDevice(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_DisconnectFromUiDevice::U2G_DisconnectFromUiDevice(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_DisconnectFromUiDevice::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_DisconnectFromUiDevice::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->deviceID);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_DisconnectFromUiDevice::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_DisconnectFromUiDevice::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->deviceID);
	return buffer.GetBytesRead();
}

size_t U2G_DisconnectFromUiDevice::Size() const
{
	size_t result = 0;
	//deviceID
	result += 1; // = uint_8
	return result;
}

bool U2G_DisconnectFromUiDevice::operator==(const U2G_DisconnectFromUiDevice& other) const
{
	if (deviceID != other.deviceID) {
		return false;
	}
	return true;
}

bool U2G_DisconnectFromUiDevice::operator!=(const U2G_DisconnectFromUiDevice& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_ForceAddRobot::U2G_ForceAddRobot(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_ForceAddRobot::U2G_ForceAddRobot(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_ForceAddRobot::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_ForceAddRobot::Pack(SafeMessageBuffer& buffer) const
{
	buffer.WriteFArray<uint8_t, 16>(this->ipAddress);
	buffer.Write(this->robotID);
	buffer.Write(this->isSimulated);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_ForceAddRobot::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_ForceAddRobot::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.ReadFArray<uint8_t, 16>(this->ipAddress);
	buffer.Read(this->robotID);
	buffer.Read(this->isSimulated);
	return buffer.GetBytesRead();
}

size_t U2G_ForceAddRobot::Size() const
{
	size_t result = 0;
	//ipAddress
	result += 1 * 16; // = uint_8 * 16
	//robotID
	result += 1; // = uint_8
	//isSimulated
	result += 1; // = uint_8
	return result;
}

bool U2G_ForceAddRobot::operator==(const U2G_ForceAddRobot& other) const
{
	if (ipAddress != other.ipAddress
	|| robotID != other.robotID
	|| isSimulated != other.isSimulated) {
		return false;
	}
	return true;
}

bool U2G_ForceAddRobot::operator!=(const U2G_ForceAddRobot& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_StartEngine::U2G_StartEngine(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_StartEngine::U2G_StartEngine(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_StartEngine::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_StartEngine::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->asHost);
	buffer.WriteFArray<uint8_t, 16>(this->vizHostIP);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_StartEngine::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_StartEngine::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->asHost);
	buffer.ReadFArray<uint8_t, 16>(this->vizHostIP);
	return buffer.GetBytesRead();
}

size_t U2G_StartEngine::Size() const
{
	size_t result = 0;
	//asHost
	result += 1; // = uint_8
	//vizHostIP
	result += 1 * 16; // = uint_8 * 16
	return result;
}

bool U2G_StartEngine::operator==(const U2G_StartEngine& other) const
{
	if (asHost != other.asHost
	|| vizHostIP != other.vizHostIP) {
		return false;
	}
	return true;
}

bool U2G_StartEngine::operator!=(const U2G_StartEngine& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_DriveWheels::U2G_DriveWheels(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_DriveWheels::U2G_DriveWheels(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_DriveWheels::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_DriveWheels::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->lwheel_speed_mmps);
	buffer.Write(this->rwheel_speed_mmps);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_DriveWheels::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_DriveWheels::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->lwheel_speed_mmps);
	buffer.Read(this->rwheel_speed_mmps);
	return buffer.GetBytesRead();
}

size_t U2G_DriveWheels::Size() const
{
	size_t result = 0;
	//lwheel_speed_mmps
	result += 4; // = float_32
	//rwheel_speed_mmps
	result += 4; // = float_32
	return result;
}

bool U2G_DriveWheels::operator==(const U2G_DriveWheels& other) const
{
	if (lwheel_speed_mmps != other.lwheel_speed_mmps
	|| rwheel_speed_mmps != other.rwheel_speed_mmps) {
		return false;
	}
	return true;
}

bool U2G_DriveWheels::operator!=(const U2G_DriveWheels& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_TurnInPlace::U2G_TurnInPlace(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_TurnInPlace::U2G_TurnInPlace(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_TurnInPlace::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_TurnInPlace::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->angle_rad);
	buffer.Write(this->robotID);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_TurnInPlace::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_TurnInPlace::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->angle_rad);
	buffer.Read(this->robotID);
	return buffer.GetBytesRead();
}

size_t U2G_TurnInPlace::Size() const
{
	size_t result = 0;
	//angle_rad
	result += 4; // = float_32
	//robotID
	result += 1; // = uint_8
	return result;
}

bool U2G_TurnInPlace::operator==(const U2G_TurnInPlace& other) const
{
	if (angle_rad != other.angle_rad
	|| robotID != other.robotID) {
		return false;
	}
	return true;
}

bool U2G_TurnInPlace::operator!=(const U2G_TurnInPlace& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_MoveHead::U2G_MoveHead(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_MoveHead::U2G_MoveHead(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_MoveHead::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_MoveHead::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->speed_rad_per_sec);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_MoveHead::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_MoveHead::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->speed_rad_per_sec);
	return buffer.GetBytesRead();
}

size_t U2G_MoveHead::Size() const
{
	size_t result = 0;
	//speed_rad_per_sec
	result += 4; // = float_32
	return result;
}

bool U2G_MoveHead::operator==(const U2G_MoveHead& other) const
{
	if (speed_rad_per_sec != other.speed_rad_per_sec) {
		return false;
	}
	return true;
}

bool U2G_MoveHead::operator!=(const U2G_MoveHead& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_MoveLift::U2G_MoveLift(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_MoveLift::U2G_MoveLift(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_MoveLift::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_MoveLift::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->speed_rad_per_sec);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_MoveLift::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_MoveLift::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->speed_rad_per_sec);
	return buffer.GetBytesRead();
}

size_t U2G_MoveLift::Size() const
{
	size_t result = 0;
	//speed_rad_per_sec
	result += 4; // = float_32
	return result;
}

bool U2G_MoveLift::operator==(const U2G_MoveLift& other) const
{
	if (speed_rad_per_sec != other.speed_rad_per_sec) {
		return false;
	}
	return true;
}

bool U2G_MoveLift::operator!=(const U2G_MoveLift& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_SetLiftHeight::U2G_SetLiftHeight(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_SetLiftHeight::U2G_SetLiftHeight(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_SetLiftHeight::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_SetLiftHeight::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->height_mm);
	buffer.Write(this->max_speed_rad_per_sec);
	buffer.Write(this->accel_rad_per_sec2);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_SetLiftHeight::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_SetLiftHeight::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->height_mm);
	buffer.Read(this->max_speed_rad_per_sec);
	buffer.Read(this->accel_rad_per_sec2);
	return buffer.GetBytesRead();
}

size_t U2G_SetLiftHeight::Size() const
{
	size_t result = 0;
	//height_mm
	result += 4; // = float_32
	//max_speed_rad_per_sec
	result += 4; // = float_32
	//accel_rad_per_sec2
	result += 4; // = float_32
	return result;
}

bool U2G_SetLiftHeight::operator==(const U2G_SetLiftHeight& other) const
{
	if (height_mm != other.height_mm
	|| max_speed_rad_per_sec != other.max_speed_rad_per_sec
	|| accel_rad_per_sec2 != other.accel_rad_per_sec2) {
		return false;
	}
	return true;
}

bool U2G_SetLiftHeight::operator!=(const U2G_SetLiftHeight& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_SetHeadAngle::U2G_SetHeadAngle(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_SetHeadAngle::U2G_SetHeadAngle(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_SetHeadAngle::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_SetHeadAngle::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->angle_rad);
	buffer.Write(this->max_speed_rad_per_sec);
	buffer.Write(this->accel_rad_per_sec2);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_SetHeadAngle::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_SetHeadAngle::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->angle_rad);
	buffer.Read(this->max_speed_rad_per_sec);
	buffer.Read(this->accel_rad_per_sec2);
	return buffer.GetBytesRead();
}

size_t U2G_SetHeadAngle::Size() const
{
	size_t result = 0;
	//angle_rad
	result += 4; // = float_32
	//max_speed_rad_per_sec
	result += 4; // = float_32
	//accel_rad_per_sec2
	result += 4; // = float_32
	return result;
}

bool U2G_SetHeadAngle::operator==(const U2G_SetHeadAngle& other) const
{
	if (angle_rad != other.angle_rad
	|| max_speed_rad_per_sec != other.max_speed_rad_per_sec
	|| accel_rad_per_sec2 != other.accel_rad_per_sec2) {
		return false;
	}
	return true;
}

bool U2G_SetHeadAngle::operator!=(const U2G_SetHeadAngle& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_TrackHeadToObject::U2G_TrackHeadToObject(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_TrackHeadToObject::U2G_TrackHeadToObject(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_TrackHeadToObject::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_TrackHeadToObject::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->objectID);
	buffer.Write(this->robotID);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_TrackHeadToObject::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_TrackHeadToObject::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->objectID);
	buffer.Read(this->robotID);
	return buffer.GetBytesRead();
}

size_t U2G_TrackHeadToObject::Size() const
{
	size_t result = 0;
	//objectID
	result += 4; // = uint_32
	//robotID
	result += 1; // = uint_8
	return result;
}

bool U2G_TrackHeadToObject::operator==(const U2G_TrackHeadToObject& other) const
{
	if (objectID != other.objectID
	|| robotID != other.robotID) {
		return false;
	}
	return true;
}

bool U2G_TrackHeadToObject::operator!=(const U2G_TrackHeadToObject& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_StopAllMotors::U2G_StopAllMotors(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_StopAllMotors::U2G_StopAllMotors(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_StopAllMotors::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_StopAllMotors::Pack(SafeMessageBuffer& buffer) const
{
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_StopAllMotors::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_StopAllMotors::Unpack(const SafeMessageBuffer& buffer)
{
	return buffer.GetBytesRead();
}

size_t U2G_StopAllMotors::Size() const
{
	size_t result = 0;
	return result;
}

bool U2G_StopAllMotors::operator==(const U2G_StopAllMotors& other) const
{
	return true;
}

bool U2G_StopAllMotors::operator!=(const U2G_StopAllMotors& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_ImageRequest::U2G_ImageRequest(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_ImageRequest::U2G_ImageRequest(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_ImageRequest::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_ImageRequest::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->robotID);
	buffer.Write(this->mode);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_ImageRequest::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_ImageRequest::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->robotID);
	buffer.Read(this->mode);
	return buffer.GetBytesRead();
}

size_t U2G_ImageRequest::Size() const
{
	size_t result = 0;
	//robotID
	result += 1; // = uint_8
	//mode
	result += 1; // = uint_8
	return result;
}

bool U2G_ImageRequest::operator==(const U2G_ImageRequest& other) const
{
	if (robotID != other.robotID
	|| mode != other.mode) {
		return false;
	}
	return true;
}

bool U2G_ImageRequest::operator!=(const U2G_ImageRequest& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_SetRobotImageSendMode::U2G_SetRobotImageSendMode(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_SetRobotImageSendMode::U2G_SetRobotImageSendMode(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_SetRobotImageSendMode::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_SetRobotImageSendMode::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->mode);
	buffer.Write(this->resolution);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_SetRobotImageSendMode::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_SetRobotImageSendMode::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->mode);
	buffer.Read(this->resolution);
	return buffer.GetBytesRead();
}

size_t U2G_SetRobotImageSendMode::Size() const
{
	size_t result = 0;
	//mode
	result += 1; // = uint_8
	//resolution
	result += 1; // = uint_8
	return result;
}

bool U2G_SetRobotImageSendMode::operator==(const U2G_SetRobotImageSendMode& other) const
{
	if (mode != other.mode
	|| resolution != other.resolution) {
		return false;
	}
	return true;
}

bool U2G_SetRobotImageSendMode::operator!=(const U2G_SetRobotImageSendMode& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_SaveImages::U2G_SaveImages(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_SaveImages::U2G_SaveImages(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_SaveImages::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_SaveImages::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->mode);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_SaveImages::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_SaveImages::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->mode);
	return buffer.GetBytesRead();
}

size_t U2G_SaveImages::Size() const
{
	size_t result = 0;
	//mode
	result += 1; // = uint_8
	return result;
}

bool U2G_SaveImages::operator==(const U2G_SaveImages& other) const
{
	if (mode != other.mode) {
		return false;
	}
	return true;
}

bool U2G_SaveImages::operator!=(const U2G_SaveImages& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_SaveRobotState::U2G_SaveRobotState(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_SaveRobotState::U2G_SaveRobotState(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_SaveRobotState::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_SaveRobotState::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->mode);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_SaveRobotState::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_SaveRobotState::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->mode);
	return buffer.GetBytesRead();
}

size_t U2G_SaveRobotState::Size() const
{
	size_t result = 0;
	//mode
	result += 1; // = uint_8
	return result;
}

bool U2G_SaveRobotState::operator==(const U2G_SaveRobotState& other) const
{
	if (mode != other.mode) {
		return false;
	}
	return true;
}

bool U2G_SaveRobotState::operator!=(const U2G_SaveRobotState& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_EnableDisplay::U2G_EnableDisplay(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_EnableDisplay::U2G_EnableDisplay(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_EnableDisplay::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_EnableDisplay::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->enable);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_EnableDisplay::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_EnableDisplay::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->enable);
	return buffer.GetBytesRead();
}

size_t U2G_EnableDisplay::Size() const
{
	size_t result = 0;
	//enable
	result += 1; // = uint_8
	return result;
}

bool U2G_EnableDisplay::operator==(const U2G_EnableDisplay& other) const
{
	if (enable != other.enable) {
		return false;
	}
	return true;
}

bool U2G_EnableDisplay::operator!=(const U2G_EnableDisplay& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_SetHeadlights::U2G_SetHeadlights(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_SetHeadlights::U2G_SetHeadlights(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_SetHeadlights::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_SetHeadlights::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->intensity);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_SetHeadlights::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_SetHeadlights::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->intensity);
	return buffer.GetBytesRead();
}

size_t U2G_SetHeadlights::Size() const
{
	size_t result = 0;
	//intensity
	result += 1; // = uint_8
	return result;
}

bool U2G_SetHeadlights::operator==(const U2G_SetHeadlights& other) const
{
	if (intensity != other.intensity) {
		return false;
	}
	return true;
}

bool U2G_SetHeadlights::operator!=(const U2G_SetHeadlights& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_GotoPose::U2G_GotoPose(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_GotoPose::U2G_GotoPose(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_GotoPose::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_GotoPose::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->x_mm);
	buffer.Write(this->y_mm);
	buffer.Write(this->rad);
	buffer.Write(this->level);
	buffer.Write(this->useManualSpeed);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_GotoPose::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_GotoPose::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->x_mm);
	buffer.Read(this->y_mm);
	buffer.Read(this->rad);
	buffer.Read(this->level);
	buffer.Read(this->useManualSpeed);
	return buffer.GetBytesRead();
}

size_t U2G_GotoPose::Size() const
{
	size_t result = 0;
	//x_mm
	result += 4; // = float_32
	//y_mm
	result += 4; // = float_32
	//rad
	result += 4; // = float_32
	//level
	result += 1; // = uint_8
	//useManualSpeed
	result += 1; // = uint_8
	return result;
}

bool U2G_GotoPose::operator==(const U2G_GotoPose& other) const
{
	if (x_mm != other.x_mm
	|| y_mm != other.y_mm
	|| rad != other.rad
	|| level != other.level
	|| useManualSpeed != other.useManualSpeed) {
		return false;
	}
	return true;
}

bool U2G_GotoPose::operator!=(const U2G_GotoPose& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_PlaceObjectOnGround::U2G_PlaceObjectOnGround(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_PlaceObjectOnGround::U2G_PlaceObjectOnGround(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_PlaceObjectOnGround::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_PlaceObjectOnGround::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->x_mm);
	buffer.Write(this->y_mm);
	buffer.Write(this->rad);
	buffer.Write(this->level);
	buffer.Write(this->useManualSpeed);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_PlaceObjectOnGround::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_PlaceObjectOnGround::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->x_mm);
	buffer.Read(this->y_mm);
	buffer.Read(this->rad);
	buffer.Read(this->level);
	buffer.Read(this->useManualSpeed);
	return buffer.GetBytesRead();
}

size_t U2G_PlaceObjectOnGround::Size() const
{
	size_t result = 0;
	//x_mm
	result += 4; // = float_32
	//y_mm
	result += 4; // = float_32
	//rad
	result += 4; // = float_32
	//level
	result += 1; // = uint_8
	//useManualSpeed
	result += 1; // = uint_8
	return result;
}

bool U2G_PlaceObjectOnGround::operator==(const U2G_PlaceObjectOnGround& other) const
{
	if (x_mm != other.x_mm
	|| y_mm != other.y_mm
	|| rad != other.rad
	|| level != other.level
	|| useManualSpeed != other.useManualSpeed) {
		return false;
	}
	return true;
}

bool U2G_PlaceObjectOnGround::operator!=(const U2G_PlaceObjectOnGround& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_PlaceObjectOnGroundHere::U2G_PlaceObjectOnGroundHere(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_PlaceObjectOnGroundHere::U2G_PlaceObjectOnGroundHere(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_PlaceObjectOnGroundHere::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_PlaceObjectOnGroundHere::Pack(SafeMessageBuffer& buffer) const
{
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_PlaceObjectOnGroundHere::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_PlaceObjectOnGroundHere::Unpack(const SafeMessageBuffer& buffer)
{
	return buffer.GetBytesRead();
}

size_t U2G_PlaceObjectOnGroundHere::Size() const
{
	size_t result = 0;
	return result;
}

bool U2G_PlaceObjectOnGroundHere::operator==(const U2G_PlaceObjectOnGroundHere& other) const
{
	return true;
}

bool U2G_PlaceObjectOnGroundHere::operator!=(const U2G_PlaceObjectOnGroundHere& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_ExecuteTestPlan::U2G_ExecuteTestPlan(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_ExecuteTestPlan::U2G_ExecuteTestPlan(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_ExecuteTestPlan::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_ExecuteTestPlan::Pack(SafeMessageBuffer& buffer) const
{
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_ExecuteTestPlan::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_ExecuteTestPlan::Unpack(const SafeMessageBuffer& buffer)
{
	return buffer.GetBytesRead();
}

size_t U2G_ExecuteTestPlan::Size() const
{
	size_t result = 0;
	return result;
}

bool U2G_ExecuteTestPlan::operator==(const U2G_ExecuteTestPlan& other) const
{
	return true;
}

bool U2G_ExecuteTestPlan::operator!=(const U2G_ExecuteTestPlan& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_SelectNextObject::U2G_SelectNextObject(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_SelectNextObject::U2G_SelectNextObject(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_SelectNextObject::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_SelectNextObject::Pack(SafeMessageBuffer& buffer) const
{
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_SelectNextObject::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_SelectNextObject::Unpack(const SafeMessageBuffer& buffer)
{
	return buffer.GetBytesRead();
}

size_t U2G_SelectNextObject::Size() const
{
	size_t result = 0;
	return result;
}

bool U2G_SelectNextObject::operator==(const U2G_SelectNextObject& other) const
{
	return true;
}

bool U2G_SelectNextObject::operator!=(const U2G_SelectNextObject& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_PickAndPlaceObject::U2G_PickAndPlaceObject(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_PickAndPlaceObject::U2G_PickAndPlaceObject(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_PickAndPlaceObject::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_PickAndPlaceObject::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->objectID);
	buffer.Write(this->usePreDockPose);
	buffer.Write(this->useManualSpeed);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_PickAndPlaceObject::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_PickAndPlaceObject::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->objectID);
	buffer.Read(this->usePreDockPose);
	buffer.Read(this->useManualSpeed);
	return buffer.GetBytesRead();
}

size_t U2G_PickAndPlaceObject::Size() const
{
	size_t result = 0;
	//objectID
	result += 4; // = int_32
	//usePreDockPose
	result += 1; // = uint_8
	//useManualSpeed
	result += 1; // = uint_8
	return result;
}

bool U2G_PickAndPlaceObject::operator==(const U2G_PickAndPlaceObject& other) const
{
	if (objectID != other.objectID
	|| usePreDockPose != other.usePreDockPose
	|| useManualSpeed != other.useManualSpeed) {
		return false;
	}
	return true;
}

bool U2G_PickAndPlaceObject::operator!=(const U2G_PickAndPlaceObject& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_TraverseObject::U2G_TraverseObject(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_TraverseObject::U2G_TraverseObject(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_TraverseObject::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_TraverseObject::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->usePreDockPose);
	buffer.Write(this->useManualSpeed);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_TraverseObject::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_TraverseObject::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->usePreDockPose);
	buffer.Read(this->useManualSpeed);
	return buffer.GetBytesRead();
}

size_t U2G_TraverseObject::Size() const
{
	size_t result = 0;
	//usePreDockPose
	result += 1; // = uint_8
	//useManualSpeed
	result += 1; // = uint_8
	return result;
}

bool U2G_TraverseObject::operator==(const U2G_TraverseObject& other) const
{
	if (usePreDockPose != other.usePreDockPose
	|| useManualSpeed != other.useManualSpeed) {
		return false;
	}
	return true;
}

bool U2G_TraverseObject::operator!=(const U2G_TraverseObject& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_SetRobotCarryingObject::U2G_SetRobotCarryingObject(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_SetRobotCarryingObject::U2G_SetRobotCarryingObject(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_SetRobotCarryingObject::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_SetRobotCarryingObject::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->objectID);
	buffer.Write(this->robotID);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_SetRobotCarryingObject::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_SetRobotCarryingObject::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->objectID);
	buffer.Read(this->robotID);
	return buffer.GetBytesRead();
}

size_t U2G_SetRobotCarryingObject::Size() const
{
	size_t result = 0;
	//objectID
	result += 4; // = int_32
	//robotID
	result += 1; // = uint_8
	return result;
}

bool U2G_SetRobotCarryingObject::operator==(const U2G_SetRobotCarryingObject& other) const
{
	if (objectID != other.objectID
	|| robotID != other.robotID) {
		return false;
	}
	return true;
}

bool U2G_SetRobotCarryingObject::operator!=(const U2G_SetRobotCarryingObject& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_ClearAllBlocks::U2G_ClearAllBlocks(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_ClearAllBlocks::U2G_ClearAllBlocks(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_ClearAllBlocks::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_ClearAllBlocks::Pack(SafeMessageBuffer& buffer) const
{
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_ClearAllBlocks::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_ClearAllBlocks::Unpack(const SafeMessageBuffer& buffer)
{
	return buffer.GetBytesRead();
}

size_t U2G_ClearAllBlocks::Size() const
{
	size_t result = 0;
	return result;
}

bool U2G_ClearAllBlocks::operator==(const U2G_ClearAllBlocks& other) const
{
	return true;
}

bool U2G_ClearAllBlocks::operator!=(const U2G_ClearAllBlocks& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_VisionWhileMoving::U2G_VisionWhileMoving(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_VisionWhileMoving::U2G_VisionWhileMoving(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_VisionWhileMoving::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_VisionWhileMoving::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->enable);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_VisionWhileMoving::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_VisionWhileMoving::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->enable);
	return buffer.GetBytesRead();
}

size_t U2G_VisionWhileMoving::Size() const
{
	size_t result = 0;
	//enable
	result += 1; // = uint_8
	return result;
}

bool U2G_VisionWhileMoving::operator==(const U2G_VisionWhileMoving& other) const
{
	if (enable != other.enable) {
		return false;
	}
	return true;
}

bool U2G_VisionWhileMoving::operator!=(const U2G_VisionWhileMoving& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_ExecuteBehavior::U2G_ExecuteBehavior(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_ExecuteBehavior::U2G_ExecuteBehavior(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_ExecuteBehavior::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_ExecuteBehavior::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->behaviorMode);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_ExecuteBehavior::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_ExecuteBehavior::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->behaviorMode);
	return buffer.GetBytesRead();
}

size_t U2G_ExecuteBehavior::Size() const
{
	size_t result = 0;
	//behaviorMode
	result += 1; // = uint_8
	return result;
}

bool U2G_ExecuteBehavior::operator==(const U2G_ExecuteBehavior& other) const
{
	if (behaviorMode != other.behaviorMode) {
		return false;
	}
	return true;
}

bool U2G_ExecuteBehavior::operator!=(const U2G_ExecuteBehavior& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_SetBehaviorState::U2G_SetBehaviorState(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_SetBehaviorState::U2G_SetBehaviorState(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_SetBehaviorState::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_SetBehaviorState::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->behaviorState);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_SetBehaviorState::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_SetBehaviorState::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->behaviorState);
	return buffer.GetBytesRead();
}

size_t U2G_SetBehaviorState::Size() const
{
	size_t result = 0;
	//behaviorState
	result += 1; // = uint_8
	return result;
}

bool U2G_SetBehaviorState::operator==(const U2G_SetBehaviorState& other) const
{
	if (behaviorState != other.behaviorState) {
		return false;
	}
	return true;
}

bool U2G_SetBehaviorState::operator!=(const U2G_SetBehaviorState& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_AbortPath::U2G_AbortPath(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_AbortPath::U2G_AbortPath(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_AbortPath::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_AbortPath::Pack(SafeMessageBuffer& buffer) const
{
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_AbortPath::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_AbortPath::Unpack(const SafeMessageBuffer& buffer)
{
	return buffer.GetBytesRead();
}

size_t U2G_AbortPath::Size() const
{
	size_t result = 0;
	return result;
}

bool U2G_AbortPath::operator==(const U2G_AbortPath& other) const
{
	return true;
}

bool U2G_AbortPath::operator!=(const U2G_AbortPath& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_AbortAll::U2G_AbortAll(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_AbortAll::U2G_AbortAll(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_AbortAll::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_AbortAll::Pack(SafeMessageBuffer& buffer) const
{
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_AbortAll::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_AbortAll::Unpack(const SafeMessageBuffer& buffer)
{
	return buffer.GetBytesRead();
}

size_t U2G_AbortAll::Size() const
{
	size_t result = 0;
	return result;
}

bool U2G_AbortAll::operator==(const U2G_AbortAll& other) const
{
	return true;
}

bool U2G_AbortAll::operator!=(const U2G_AbortAll& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_DrawPoseMarker::U2G_DrawPoseMarker(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_DrawPoseMarker::U2G_DrawPoseMarker(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_DrawPoseMarker::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_DrawPoseMarker::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->x_mm);
	buffer.Write(this->y_mm);
	buffer.Write(this->rad);
	buffer.Write(this->level);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_DrawPoseMarker::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_DrawPoseMarker::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->x_mm);
	buffer.Read(this->y_mm);
	buffer.Read(this->rad);
	buffer.Read(this->level);
	return buffer.GetBytesRead();
}

size_t U2G_DrawPoseMarker::Size() const
{
	size_t result = 0;
	//x_mm
	result += 4; // = float_32
	//y_mm
	result += 4; // = float_32
	//rad
	result += 4; // = float_32
	//level
	result += 1; // = uint_8
	return result;
}

bool U2G_DrawPoseMarker::operator==(const U2G_DrawPoseMarker& other) const
{
	if (x_mm != other.x_mm
	|| y_mm != other.y_mm
	|| rad != other.rad
	|| level != other.level) {
		return false;
	}
	return true;
}

bool U2G_DrawPoseMarker::operator!=(const U2G_DrawPoseMarker& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_ErasePoseMarker::U2G_ErasePoseMarker(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_ErasePoseMarker::U2G_ErasePoseMarker(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_ErasePoseMarker::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_ErasePoseMarker::Pack(SafeMessageBuffer& buffer) const
{
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_ErasePoseMarker::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_ErasePoseMarker::Unpack(const SafeMessageBuffer& buffer)
{
	return buffer.GetBytesRead();
}

size_t U2G_ErasePoseMarker::Size() const
{
	size_t result = 0;
	return result;
}

bool U2G_ErasePoseMarker::operator==(const U2G_ErasePoseMarker& other) const
{
	return true;
}

bool U2G_ErasePoseMarker::operator!=(const U2G_ErasePoseMarker& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_SetHeadControllerGains::U2G_SetHeadControllerGains(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_SetHeadControllerGains::U2G_SetHeadControllerGains(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_SetHeadControllerGains::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_SetHeadControllerGains::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->kp);
	buffer.Write(this->ki);
	buffer.Write(this->maxIntegralError);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_SetHeadControllerGains::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_SetHeadControllerGains::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->kp);
	buffer.Read(this->ki);
	buffer.Read(this->maxIntegralError);
	return buffer.GetBytesRead();
}

size_t U2G_SetHeadControllerGains::Size() const
{
	size_t result = 0;
	//kp
	result += 4; // = float_32
	//ki
	result += 4; // = float_32
	//maxIntegralError
	result += 4; // = float_32
	return result;
}

bool U2G_SetHeadControllerGains::operator==(const U2G_SetHeadControllerGains& other) const
{
	if (kp != other.kp
	|| ki != other.ki
	|| maxIntegralError != other.maxIntegralError) {
		return false;
	}
	return true;
}

bool U2G_SetHeadControllerGains::operator!=(const U2G_SetHeadControllerGains& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_SetLiftControllerGains::U2G_SetLiftControllerGains(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_SetLiftControllerGains::U2G_SetLiftControllerGains(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_SetLiftControllerGains::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_SetLiftControllerGains::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->kp);
	buffer.Write(this->ki);
	buffer.Write(this->maxIntegralError);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_SetLiftControllerGains::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_SetLiftControllerGains::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->kp);
	buffer.Read(this->ki);
	buffer.Read(this->maxIntegralError);
	return buffer.GetBytesRead();
}

size_t U2G_SetLiftControllerGains::Size() const
{
	size_t result = 0;
	//kp
	result += 4; // = float_32
	//ki
	result += 4; // = float_32
	//maxIntegralError
	result += 4; // = float_32
	return result;
}

bool U2G_SetLiftControllerGains::operator==(const U2G_SetLiftControllerGains& other) const
{
	if (kp != other.kp
	|| ki != other.ki
	|| maxIntegralError != other.maxIntegralError) {
		return false;
	}
	return true;
}

bool U2G_SetLiftControllerGains::operator!=(const U2G_SetLiftControllerGains& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_SelectNextSoundScheme::U2G_SelectNextSoundScheme(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_SelectNextSoundScheme::U2G_SelectNextSoundScheme(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_SelectNextSoundScheme::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_SelectNextSoundScheme::Pack(SafeMessageBuffer& buffer) const
{
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_SelectNextSoundScheme::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_SelectNextSoundScheme::Unpack(const SafeMessageBuffer& buffer)
{
	return buffer.GetBytesRead();
}

size_t U2G_SelectNextSoundScheme::Size() const
{
	size_t result = 0;
	return result;
}

bool U2G_SelectNextSoundScheme::operator==(const U2G_SelectNextSoundScheme& other) const
{
	return true;
}

bool U2G_SelectNextSoundScheme::operator!=(const U2G_SelectNextSoundScheme& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_StartTestMode::U2G_StartTestMode(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_StartTestMode::U2G_StartTestMode(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_StartTestMode::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_StartTestMode::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->p1);
	buffer.Write(this->p2);
	buffer.Write(this->p3);
	buffer.Write(this->mode);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_StartTestMode::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_StartTestMode::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->p1);
	buffer.Read(this->p2);
	buffer.Read(this->p3);
	buffer.Read(this->mode);
	return buffer.GetBytesRead();
}

size_t U2G_StartTestMode::Size() const
{
	size_t result = 0;
	//p1
	result += 4; // = int_32
	//p2
	result += 4; // = int_32
	//p3
	result += 4; // = int_32
	//mode
	result += 1; // = uint_8
	return result;
}

bool U2G_StartTestMode::operator==(const U2G_StartTestMode& other) const
{
	if (p1 != other.p1
	|| p2 != other.p2
	|| p3 != other.p3
	|| mode != other.mode) {
		return false;
	}
	return true;
}

bool U2G_StartTestMode::operator!=(const U2G_StartTestMode& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_IMURequest::U2G_IMURequest(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_IMURequest::U2G_IMURequest(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_IMURequest::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_IMURequest::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->length_ms);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_IMURequest::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_IMURequest::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->length_ms);
	return buffer.GetBytesRead();
}

size_t U2G_IMURequest::Size() const
{
	size_t result = 0;
	//length_ms
	result += 4; // = uint_32
	return result;
}

bool U2G_IMURequest::operator==(const U2G_IMURequest& other) const
{
	if (length_ms != other.length_ms) {
		return false;
	}
	return true;
}

bool U2G_IMURequest::operator!=(const U2G_IMURequest& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_PlayAnimation::U2G_PlayAnimation(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_PlayAnimation::U2G_PlayAnimation(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_PlayAnimation::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_PlayAnimation::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->numLoops);
	buffer.WritePString<uint8_t>(this->animationName);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_PlayAnimation::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_PlayAnimation::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->numLoops);
	buffer.ReadPString<uint8_t>(this->animationName);
	return buffer.GetBytesRead();
}

size_t U2G_PlayAnimation::Size() const
{
	size_t result = 0;
	//numLoops
	result += 4; // = uint_32
	//animationName
	result += 1; // length = uint_8
	result += 1 * animationName.size(); //string
	return result;
}

bool U2G_PlayAnimation::operator==(const U2G_PlayAnimation& other) const
{
	if (numLoops != other.numLoops
	|| animationName != other.animationName) {
		return false;
	}
	return true;
}

bool U2G_PlayAnimation::operator!=(const U2G_PlayAnimation& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_ReadAnimationFile::U2G_ReadAnimationFile(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_ReadAnimationFile::U2G_ReadAnimationFile(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_ReadAnimationFile::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_ReadAnimationFile::Pack(SafeMessageBuffer& buffer) const
{
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_ReadAnimationFile::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_ReadAnimationFile::Unpack(const SafeMessageBuffer& buffer)
{
	return buffer.GetBytesRead();
}

size_t U2G_ReadAnimationFile::Size() const
{
	size_t result = 0;
	return result;
}

bool U2G_ReadAnimationFile::operator==(const U2G_ReadAnimationFile& other) const
{
	return true;
}

bool U2G_ReadAnimationFile::operator!=(const U2G_ReadAnimationFile& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_StartFaceTracking::U2G_StartFaceTracking(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_StartFaceTracking::U2G_StartFaceTracking(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_StartFaceTracking::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_StartFaceTracking::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->timeout_sec);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_StartFaceTracking::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_StartFaceTracking::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->timeout_sec);
	return buffer.GetBytesRead();
}

size_t U2G_StartFaceTracking::Size() const
{
	size_t result = 0;
	//timeout_sec
	result += 1; // = uint_8
	return result;
}

bool U2G_StartFaceTracking::operator==(const U2G_StartFaceTracking& other) const
{
	if (timeout_sec != other.timeout_sec) {
		return false;
	}
	return true;
}

bool U2G_StartFaceTracking::operator!=(const U2G_StartFaceTracking& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_StopFaceTracking::U2G_StopFaceTracking(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_StopFaceTracking::U2G_StopFaceTracking(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_StopFaceTracking::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_StopFaceTracking::Pack(SafeMessageBuffer& buffer) const
{
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_StopFaceTracking::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_StopFaceTracking::Unpack(const SafeMessageBuffer& buffer)
{
	return buffer.GetBytesRead();
}

size_t U2G_StopFaceTracking::Size() const
{
	size_t result = 0;
	return result;
}

bool U2G_StopFaceTracking::operator==(const U2G_StopFaceTracking& other) const
{
	return true;
}

bool U2G_StopFaceTracking::operator!=(const U2G_StopFaceTracking& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_StartLookingForMarkers::U2G_StartLookingForMarkers(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_StartLookingForMarkers::U2G_StartLookingForMarkers(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_StartLookingForMarkers::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_StartLookingForMarkers::Pack(SafeMessageBuffer& buffer) const
{
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_StartLookingForMarkers::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_StartLookingForMarkers::Unpack(const SafeMessageBuffer& buffer)
{
	return buffer.GetBytesRead();
}

size_t U2G_StartLookingForMarkers::Size() const
{
	size_t result = 0;
	return result;
}

bool U2G_StartLookingForMarkers::operator==(const U2G_StartLookingForMarkers& other) const
{
	return true;
}

bool U2G_StartLookingForMarkers::operator!=(const U2G_StartLookingForMarkers& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_StopLookingForMarkers::U2G_StopLookingForMarkers(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_StopLookingForMarkers::U2G_StopLookingForMarkers(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_StopLookingForMarkers::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_StopLookingForMarkers::Pack(SafeMessageBuffer& buffer) const
{
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_StopLookingForMarkers::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_StopLookingForMarkers::Unpack(const SafeMessageBuffer& buffer)
{
	return buffer.GetBytesRead();
}

size_t U2G_StopLookingForMarkers::Size() const
{
	size_t result = 0;
	return result;
}

bool U2G_StopLookingForMarkers::operator==(const U2G_StopLookingForMarkers& other) const
{
	return true;
}

bool U2G_StopLookingForMarkers::operator!=(const U2G_StopLookingForMarkers& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_SetVisionSystemParams::U2G_SetVisionSystemParams(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_SetVisionSystemParams::U2G_SetVisionSystemParams(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_SetVisionSystemParams::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_SetVisionSystemParams::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->autoexposureOn);
	buffer.Write(this->exposureTime);
	buffer.Write(this->integerCountsIncrement);
	buffer.Write(this->minExposureTime);
	buffer.Write(this->maxExposureTime);
	buffer.Write(this->percentileToMakeHigh);
	buffer.Write(this->limitFramerate);
	buffer.Write(this->highValue);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_SetVisionSystemParams::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_SetVisionSystemParams::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->autoexposureOn);
	buffer.Read(this->exposureTime);
	buffer.Read(this->integerCountsIncrement);
	buffer.Read(this->minExposureTime);
	buffer.Read(this->maxExposureTime);
	buffer.Read(this->percentileToMakeHigh);
	buffer.Read(this->limitFramerate);
	buffer.Read(this->highValue);
	return buffer.GetBytesRead();
}

size_t U2G_SetVisionSystemParams::Size() const
{
	size_t result = 0;
	//autoexposureOn
	result += 4; // = int_32
	//exposureTime
	result += 4; // = float_32
	//integerCountsIncrement
	result += 4; // = int_32
	//minExposureTime
	result += 4; // = float_32
	//maxExposureTime
	result += 4; // = float_32
	//percentileToMakeHigh
	result += 4; // = float_32
	//limitFramerate
	result += 4; // = int_32
	//highValue
	result += 1; // = uint_8
	return result;
}

bool U2G_SetVisionSystemParams::operator==(const U2G_SetVisionSystemParams& other) const
{
	if (autoexposureOn != other.autoexposureOn
	|| exposureTime != other.exposureTime
	|| integerCountsIncrement != other.integerCountsIncrement
	|| minExposureTime != other.minExposureTime
	|| maxExposureTime != other.maxExposureTime
	|| percentileToMakeHigh != other.percentileToMakeHigh
	|| limitFramerate != other.limitFramerate
	|| highValue != other.highValue) {
		return false;
	}
	return true;
}

bool U2G_SetVisionSystemParams::operator!=(const U2G_SetVisionSystemParams& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {
U2G_SetFaceDetectParams::U2G_SetFaceDetectParams(const uint8_t* buff, size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

U2G_SetFaceDetectParams::U2G_SetFaceDetectParams(const SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t U2G_SetFaceDetectParams::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_SetFaceDetectParams::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(this->scaleFactor);
	buffer.Write(this->minNeighbors);
	buffer.Write(this->minObjectHeight);
	buffer.Write(this->minObjectWidth);
	buffer.Write(this->maxObjectHeight);
	buffer.Write(this->maxObjectWidth);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_SetFaceDetectParams::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_SetFaceDetectParams::Unpack(const SafeMessageBuffer& buffer)
{
	buffer.Read(this->scaleFactor);
	buffer.Read(this->minNeighbors);
	buffer.Read(this->minObjectHeight);
	buffer.Read(this->minObjectWidth);
	buffer.Read(this->maxObjectHeight);
	buffer.Read(this->maxObjectWidth);
	return buffer.GetBytesRead();
}

size_t U2G_SetFaceDetectParams::Size() const
{
	size_t result = 0;
	//scaleFactor
	result += 4; // = float_32
	//minNeighbors
	result += 4; // = int_32
	//minObjectHeight
	result += 4; // = int_32
	//minObjectWidth
	result += 4; // = int_32
	//maxObjectHeight
	result += 4; // = int_32
	//maxObjectWidth
	result += 4; // = int_32
	return result;
}

bool U2G_SetFaceDetectParams::operator==(const U2G_SetFaceDetectParams& other) const
{
	if (scaleFactor != other.scaleFactor
	|| minNeighbors != other.minNeighbors
	|| minObjectHeight != other.minObjectHeight
	|| minObjectWidth != other.minObjectWidth
	|| maxObjectHeight != other.maxObjectHeight
	|| maxObjectWidth != other.maxObjectWidth) {
		return false;
	}
	return true;
}

bool U2G_SetFaceDetectParams::operator!=(const U2G_SetFaceDetectParams& other) const
{
	return !(operator==(other));
}

} // namespace Anki
} // namespace Cozmo
namespace Anki {
namespace Cozmo {

U2G_Message::U2G_Message(const SafeMessageBuffer& buff) :_type(Type::INVALID)
{
	Unpack(buff);
}

U2G_Message::U2G_Message(const uint8_t* buffer, size_t length) :_type(Type::INVALID)
{
	SafeMessageBuffer buff(const_cast<uint8_t*>(buffer), length);
	Unpack(buff);
}

const Anki::Cozmo::U2G_Ping& U2G_Message::Get_Ping() const
{
	assert(_type == Type::Ping);
	return _Ping;
}
void U2G_Message::Set_Ping(const Anki::Cozmo::U2G_Ping& new_Ping)
{
	if(this->_type == Type::Ping) {
		_Ping = new_Ping;
	}
	else {
		ClearCurrent();
		new(&_Ping) Anki::Cozmo::U2G_Ping{new_Ping};
		_type = Type::Ping;
	}
}
void U2G_Message::Set_Ping(Anki::Cozmo::U2G_Ping&& new_Ping)
{
	if(this->_type == Type::Ping) {
		_Ping = std::move(new_Ping);
	}
	else {
		ClearCurrent();
		new(&_Ping) Anki::Cozmo::U2G_Ping{std::move(new_Ping)};
		_type = Type::Ping;
	}
}


const Anki::Cozmo::U2G_ConnectToRobot& U2G_Message::Get_ConnectToRobot() const
{
	assert(_type == Type::ConnectToRobot);
	return _ConnectToRobot;
}
void U2G_Message::Set_ConnectToRobot(const Anki::Cozmo::U2G_ConnectToRobot& new_ConnectToRobot)
{
	if(this->_type == Type::ConnectToRobot) {
		_ConnectToRobot = new_ConnectToRobot;
	}
	else {
		ClearCurrent();
		new(&_ConnectToRobot) Anki::Cozmo::U2G_ConnectToRobot{new_ConnectToRobot};
		_type = Type::ConnectToRobot;
	}
}
void U2G_Message::Set_ConnectToRobot(Anki::Cozmo::U2G_ConnectToRobot&& new_ConnectToRobot)
{
	if(this->_type == Type::ConnectToRobot) {
		_ConnectToRobot = std::move(new_ConnectToRobot);
	}
	else {
		ClearCurrent();
		new(&_ConnectToRobot) Anki::Cozmo::U2G_ConnectToRobot{std::move(new_ConnectToRobot)};
		_type = Type::ConnectToRobot;
	}
}


const Anki::Cozmo::U2G_ConnectToUiDevice& U2G_Message::Get_ConnectToUiDevice() const
{
	assert(_type == Type::ConnectToUiDevice);
	return _ConnectToUiDevice;
}
void U2G_Message::Set_ConnectToUiDevice(const Anki::Cozmo::U2G_ConnectToUiDevice& new_ConnectToUiDevice)
{
	if(this->_type == Type::ConnectToUiDevice) {
		_ConnectToUiDevice = new_ConnectToUiDevice;
	}
	else {
		ClearCurrent();
		new(&_ConnectToUiDevice) Anki::Cozmo::U2G_ConnectToUiDevice{new_ConnectToUiDevice};
		_type = Type::ConnectToUiDevice;
	}
}
void U2G_Message::Set_ConnectToUiDevice(Anki::Cozmo::U2G_ConnectToUiDevice&& new_ConnectToUiDevice)
{
	if(this->_type == Type::ConnectToUiDevice) {
		_ConnectToUiDevice = std::move(new_ConnectToUiDevice);
	}
	else {
		ClearCurrent();
		new(&_ConnectToUiDevice) Anki::Cozmo::U2G_ConnectToUiDevice{std::move(new_ConnectToUiDevice)};
		_type = Type::ConnectToUiDevice;
	}
}


const Anki::Cozmo::U2G_DisconnectFromUiDevice& U2G_Message::Get_DisconnectFromUiDevice() const
{
	assert(_type == Type::DisconnectFromUiDevice);
	return _DisconnectFromUiDevice;
}
void U2G_Message::Set_DisconnectFromUiDevice(const Anki::Cozmo::U2G_DisconnectFromUiDevice& new_DisconnectFromUiDevice)
{
	if(this->_type == Type::DisconnectFromUiDevice) {
		_DisconnectFromUiDevice = new_DisconnectFromUiDevice;
	}
	else {
		ClearCurrent();
		new(&_DisconnectFromUiDevice) Anki::Cozmo::U2G_DisconnectFromUiDevice{new_DisconnectFromUiDevice};
		_type = Type::DisconnectFromUiDevice;
	}
}
void U2G_Message::Set_DisconnectFromUiDevice(Anki::Cozmo::U2G_DisconnectFromUiDevice&& new_DisconnectFromUiDevice)
{
	if(this->_type == Type::DisconnectFromUiDevice) {
		_DisconnectFromUiDevice = std::move(new_DisconnectFromUiDevice);
	}
	else {
		ClearCurrent();
		new(&_DisconnectFromUiDevice) Anki::Cozmo::U2G_DisconnectFromUiDevice{std::move(new_DisconnectFromUiDevice)};
		_type = Type::DisconnectFromUiDevice;
	}
}


const Anki::Cozmo::U2G_ForceAddRobot& U2G_Message::Get_ForceAddRobot() const
{
	assert(_type == Type::ForceAddRobot);
	return _ForceAddRobot;
}
void U2G_Message::Set_ForceAddRobot(const Anki::Cozmo::U2G_ForceAddRobot& new_ForceAddRobot)
{
	if(this->_type == Type::ForceAddRobot) {
		_ForceAddRobot = new_ForceAddRobot;
	}
	else {
		ClearCurrent();
		new(&_ForceAddRobot) Anki::Cozmo::U2G_ForceAddRobot{new_ForceAddRobot};
		_type = Type::ForceAddRobot;
	}
}
void U2G_Message::Set_ForceAddRobot(Anki::Cozmo::U2G_ForceAddRobot&& new_ForceAddRobot)
{
	if(this->_type == Type::ForceAddRobot) {
		_ForceAddRobot = std::move(new_ForceAddRobot);
	}
	else {
		ClearCurrent();
		new(&_ForceAddRobot) Anki::Cozmo::U2G_ForceAddRobot{std::move(new_ForceAddRobot)};
		_type = Type::ForceAddRobot;
	}
}


const Anki::Cozmo::U2G_StartEngine& U2G_Message::Get_StartEngine() const
{
	assert(_type == Type::StartEngine);
	return _StartEngine;
}
void U2G_Message::Set_StartEngine(const Anki::Cozmo::U2G_StartEngine& new_StartEngine)
{
	if(this->_type == Type::StartEngine) {
		_StartEngine = new_StartEngine;
	}
	else {
		ClearCurrent();
		new(&_StartEngine) Anki::Cozmo::U2G_StartEngine{new_StartEngine};
		_type = Type::StartEngine;
	}
}
void U2G_Message::Set_StartEngine(Anki::Cozmo::U2G_StartEngine&& new_StartEngine)
{
	if(this->_type == Type::StartEngine) {
		_StartEngine = std::move(new_StartEngine);
	}
	else {
		ClearCurrent();
		new(&_StartEngine) Anki::Cozmo::U2G_StartEngine{std::move(new_StartEngine)};
		_type = Type::StartEngine;
	}
}


const Anki::Cozmo::U2G_DriveWheels& U2G_Message::Get_DriveWheels() const
{
	assert(_type == Type::DriveWheels);
	return _DriveWheels;
}
void U2G_Message::Set_DriveWheels(const Anki::Cozmo::U2G_DriveWheels& new_DriveWheels)
{
	if(this->_type == Type::DriveWheels) {
		_DriveWheels = new_DriveWheels;
	}
	else {
		ClearCurrent();
		new(&_DriveWheels) Anki::Cozmo::U2G_DriveWheels{new_DriveWheels};
		_type = Type::DriveWheels;
	}
}
void U2G_Message::Set_DriveWheels(Anki::Cozmo::U2G_DriveWheels&& new_DriveWheels)
{
	if(this->_type == Type::DriveWheels) {
		_DriveWheels = std::move(new_DriveWheels);
	}
	else {
		ClearCurrent();
		new(&_DriveWheels) Anki::Cozmo::U2G_DriveWheels{std::move(new_DriveWheels)};
		_type = Type::DriveWheels;
	}
}


const Anki::Cozmo::U2G_TurnInPlace& U2G_Message::Get_TurnInPlace() const
{
	assert(_type == Type::TurnInPlace);
	return _TurnInPlace;
}
void U2G_Message::Set_TurnInPlace(const Anki::Cozmo::U2G_TurnInPlace& new_TurnInPlace)
{
	if(this->_type == Type::TurnInPlace) {
		_TurnInPlace = new_TurnInPlace;
	}
	else {
		ClearCurrent();
		new(&_TurnInPlace) Anki::Cozmo::U2G_TurnInPlace{new_TurnInPlace};
		_type = Type::TurnInPlace;
	}
}
void U2G_Message::Set_TurnInPlace(Anki::Cozmo::U2G_TurnInPlace&& new_TurnInPlace)
{
	if(this->_type == Type::TurnInPlace) {
		_TurnInPlace = std::move(new_TurnInPlace);
	}
	else {
		ClearCurrent();
		new(&_TurnInPlace) Anki::Cozmo::U2G_TurnInPlace{std::move(new_TurnInPlace)};
		_type = Type::TurnInPlace;
	}
}


const Anki::Cozmo::U2G_MoveHead& U2G_Message::Get_MoveHead() const
{
	assert(_type == Type::MoveHead);
	return _MoveHead;
}
void U2G_Message::Set_MoveHead(const Anki::Cozmo::U2G_MoveHead& new_MoveHead)
{
	if(this->_type == Type::MoveHead) {
		_MoveHead = new_MoveHead;
	}
	else {
		ClearCurrent();
		new(&_MoveHead) Anki::Cozmo::U2G_MoveHead{new_MoveHead};
		_type = Type::MoveHead;
	}
}
void U2G_Message::Set_MoveHead(Anki::Cozmo::U2G_MoveHead&& new_MoveHead)
{
	if(this->_type == Type::MoveHead) {
		_MoveHead = std::move(new_MoveHead);
	}
	else {
		ClearCurrent();
		new(&_MoveHead) Anki::Cozmo::U2G_MoveHead{std::move(new_MoveHead)};
		_type = Type::MoveHead;
	}
}


const Anki::Cozmo::U2G_MoveLift& U2G_Message::Get_MoveLift() const
{
	assert(_type == Type::MoveLift);
	return _MoveLift;
}
void U2G_Message::Set_MoveLift(const Anki::Cozmo::U2G_MoveLift& new_MoveLift)
{
	if(this->_type == Type::MoveLift) {
		_MoveLift = new_MoveLift;
	}
	else {
		ClearCurrent();
		new(&_MoveLift) Anki::Cozmo::U2G_MoveLift{new_MoveLift};
		_type = Type::MoveLift;
	}
}
void U2G_Message::Set_MoveLift(Anki::Cozmo::U2G_MoveLift&& new_MoveLift)
{
	if(this->_type == Type::MoveLift) {
		_MoveLift = std::move(new_MoveLift);
	}
	else {
		ClearCurrent();
		new(&_MoveLift) Anki::Cozmo::U2G_MoveLift{std::move(new_MoveLift)};
		_type = Type::MoveLift;
	}
}


const Anki::Cozmo::U2G_SetLiftHeight& U2G_Message::Get_SetLiftHeight() const
{
	assert(_type == Type::SetLiftHeight);
	return _SetLiftHeight;
}
void U2G_Message::Set_SetLiftHeight(const Anki::Cozmo::U2G_SetLiftHeight& new_SetLiftHeight)
{
	if(this->_type == Type::SetLiftHeight) {
		_SetLiftHeight = new_SetLiftHeight;
	}
	else {
		ClearCurrent();
		new(&_SetLiftHeight) Anki::Cozmo::U2G_SetLiftHeight{new_SetLiftHeight};
		_type = Type::SetLiftHeight;
	}
}
void U2G_Message::Set_SetLiftHeight(Anki::Cozmo::U2G_SetLiftHeight&& new_SetLiftHeight)
{
	if(this->_type == Type::SetLiftHeight) {
		_SetLiftHeight = std::move(new_SetLiftHeight);
	}
	else {
		ClearCurrent();
		new(&_SetLiftHeight) Anki::Cozmo::U2G_SetLiftHeight{std::move(new_SetLiftHeight)};
		_type = Type::SetLiftHeight;
	}
}


const Anki::Cozmo::U2G_SetHeadAngle& U2G_Message::Get_SetHeadAngle() const
{
	assert(_type == Type::SetHeadAngle);
	return _SetHeadAngle;
}
void U2G_Message::Set_SetHeadAngle(const Anki::Cozmo::U2G_SetHeadAngle& new_SetHeadAngle)
{
	if(this->_type == Type::SetHeadAngle) {
		_SetHeadAngle = new_SetHeadAngle;
	}
	else {
		ClearCurrent();
		new(&_SetHeadAngle) Anki::Cozmo::U2G_SetHeadAngle{new_SetHeadAngle};
		_type = Type::SetHeadAngle;
	}
}
void U2G_Message::Set_SetHeadAngle(Anki::Cozmo::U2G_SetHeadAngle&& new_SetHeadAngle)
{
	if(this->_type == Type::SetHeadAngle) {
		_SetHeadAngle = std::move(new_SetHeadAngle);
	}
	else {
		ClearCurrent();
		new(&_SetHeadAngle) Anki::Cozmo::U2G_SetHeadAngle{std::move(new_SetHeadAngle)};
		_type = Type::SetHeadAngle;
	}
}


const Anki::Cozmo::U2G_TrackHeadToObject& U2G_Message::Get_TrackHeadToObject() const
{
	assert(_type == Type::TrackHeadToObject);
	return _TrackHeadToObject;
}
void U2G_Message::Set_TrackHeadToObject(const Anki::Cozmo::U2G_TrackHeadToObject& new_TrackHeadToObject)
{
	if(this->_type == Type::TrackHeadToObject) {
		_TrackHeadToObject = new_TrackHeadToObject;
	}
	else {
		ClearCurrent();
		new(&_TrackHeadToObject) Anki::Cozmo::U2G_TrackHeadToObject{new_TrackHeadToObject};
		_type = Type::TrackHeadToObject;
	}
}
void U2G_Message::Set_TrackHeadToObject(Anki::Cozmo::U2G_TrackHeadToObject&& new_TrackHeadToObject)
{
	if(this->_type == Type::TrackHeadToObject) {
		_TrackHeadToObject = std::move(new_TrackHeadToObject);
	}
	else {
		ClearCurrent();
		new(&_TrackHeadToObject) Anki::Cozmo::U2G_TrackHeadToObject{std::move(new_TrackHeadToObject)};
		_type = Type::TrackHeadToObject;
	}
}


const Anki::Cozmo::U2G_StopAllMotors& U2G_Message::Get_StopAllMotors() const
{
	assert(_type == Type::StopAllMotors);
	return _StopAllMotors;
}
void U2G_Message::Set_StopAllMotors(const Anki::Cozmo::U2G_StopAllMotors& new_StopAllMotors)
{
	if(this->_type == Type::StopAllMotors) {
		_StopAllMotors = new_StopAllMotors;
	}
	else {
		ClearCurrent();
		new(&_StopAllMotors) Anki::Cozmo::U2G_StopAllMotors{new_StopAllMotors};
		_type = Type::StopAllMotors;
	}
}
void U2G_Message::Set_StopAllMotors(Anki::Cozmo::U2G_StopAllMotors&& new_StopAllMotors)
{
	if(this->_type == Type::StopAllMotors) {
		_StopAllMotors = std::move(new_StopAllMotors);
	}
	else {
		ClearCurrent();
		new(&_StopAllMotors) Anki::Cozmo::U2G_StopAllMotors{std::move(new_StopAllMotors)};
		_type = Type::StopAllMotors;
	}
}


const Anki::Cozmo::U2G_ImageRequest& U2G_Message::Get_ImageRequest() const
{
	assert(_type == Type::ImageRequest);
	return _ImageRequest;
}
void U2G_Message::Set_ImageRequest(const Anki::Cozmo::U2G_ImageRequest& new_ImageRequest)
{
	if(this->_type == Type::ImageRequest) {
		_ImageRequest = new_ImageRequest;
	}
	else {
		ClearCurrent();
		new(&_ImageRequest) Anki::Cozmo::U2G_ImageRequest{new_ImageRequest};
		_type = Type::ImageRequest;
	}
}
void U2G_Message::Set_ImageRequest(Anki::Cozmo::U2G_ImageRequest&& new_ImageRequest)
{
	if(this->_type == Type::ImageRequest) {
		_ImageRequest = std::move(new_ImageRequest);
	}
	else {
		ClearCurrent();
		new(&_ImageRequest) Anki::Cozmo::U2G_ImageRequest{std::move(new_ImageRequest)};
		_type = Type::ImageRequest;
	}
}


const Anki::Cozmo::U2G_SetRobotImageSendMode& U2G_Message::Get_SetRobotImageSendMode() const
{
	assert(_type == Type::SetRobotImageSendMode);
	return _SetRobotImageSendMode;
}
void U2G_Message::Set_SetRobotImageSendMode(const Anki::Cozmo::U2G_SetRobotImageSendMode& new_SetRobotImageSendMode)
{
	if(this->_type == Type::SetRobotImageSendMode) {
		_SetRobotImageSendMode = new_SetRobotImageSendMode;
	}
	else {
		ClearCurrent();
		new(&_SetRobotImageSendMode) Anki::Cozmo::U2G_SetRobotImageSendMode{new_SetRobotImageSendMode};
		_type = Type::SetRobotImageSendMode;
	}
}
void U2G_Message::Set_SetRobotImageSendMode(Anki::Cozmo::U2G_SetRobotImageSendMode&& new_SetRobotImageSendMode)
{
	if(this->_type == Type::SetRobotImageSendMode) {
		_SetRobotImageSendMode = std::move(new_SetRobotImageSendMode);
	}
	else {
		ClearCurrent();
		new(&_SetRobotImageSendMode) Anki::Cozmo::U2G_SetRobotImageSendMode{std::move(new_SetRobotImageSendMode)};
		_type = Type::SetRobotImageSendMode;
	}
}


const Anki::Cozmo::U2G_SaveImages& U2G_Message::Get_SaveImages() const
{
	assert(_type == Type::SaveImages);
	return _SaveImages;
}
void U2G_Message::Set_SaveImages(const Anki::Cozmo::U2G_SaveImages& new_SaveImages)
{
	if(this->_type == Type::SaveImages) {
		_SaveImages = new_SaveImages;
	}
	else {
		ClearCurrent();
		new(&_SaveImages) Anki::Cozmo::U2G_SaveImages{new_SaveImages};
		_type = Type::SaveImages;
	}
}
void U2G_Message::Set_SaveImages(Anki::Cozmo::U2G_SaveImages&& new_SaveImages)
{
	if(this->_type == Type::SaveImages) {
		_SaveImages = std::move(new_SaveImages);
	}
	else {
		ClearCurrent();
		new(&_SaveImages) Anki::Cozmo::U2G_SaveImages{std::move(new_SaveImages)};
		_type = Type::SaveImages;
	}
}


const Anki::Cozmo::U2G_SaveRobotState& U2G_Message::Get_SaveRobotState() const
{
	assert(_type == Type::SaveRobotState);
	return _SaveRobotState;
}
void U2G_Message::Set_SaveRobotState(const Anki::Cozmo::U2G_SaveRobotState& new_SaveRobotState)
{
	if(this->_type == Type::SaveRobotState) {
		_SaveRobotState = new_SaveRobotState;
	}
	else {
		ClearCurrent();
		new(&_SaveRobotState) Anki::Cozmo::U2G_SaveRobotState{new_SaveRobotState};
		_type = Type::SaveRobotState;
	}
}
void U2G_Message::Set_SaveRobotState(Anki::Cozmo::U2G_SaveRobotState&& new_SaveRobotState)
{
	if(this->_type == Type::SaveRobotState) {
		_SaveRobotState = std::move(new_SaveRobotState);
	}
	else {
		ClearCurrent();
		new(&_SaveRobotState) Anki::Cozmo::U2G_SaveRobotState{std::move(new_SaveRobotState)};
		_type = Type::SaveRobotState;
	}
}


const Anki::Cozmo::U2G_EnableDisplay& U2G_Message::Get_EnableDisplay() const
{
	assert(_type == Type::EnableDisplay);
	return _EnableDisplay;
}
void U2G_Message::Set_EnableDisplay(const Anki::Cozmo::U2G_EnableDisplay& new_EnableDisplay)
{
	if(this->_type == Type::EnableDisplay) {
		_EnableDisplay = new_EnableDisplay;
	}
	else {
		ClearCurrent();
		new(&_EnableDisplay) Anki::Cozmo::U2G_EnableDisplay{new_EnableDisplay};
		_type = Type::EnableDisplay;
	}
}
void U2G_Message::Set_EnableDisplay(Anki::Cozmo::U2G_EnableDisplay&& new_EnableDisplay)
{
	if(this->_type == Type::EnableDisplay) {
		_EnableDisplay = std::move(new_EnableDisplay);
	}
	else {
		ClearCurrent();
		new(&_EnableDisplay) Anki::Cozmo::U2G_EnableDisplay{std::move(new_EnableDisplay)};
		_type = Type::EnableDisplay;
	}
}


const Anki::Cozmo::U2G_SetHeadlights& U2G_Message::Get_SetHeadlights() const
{
	assert(_type == Type::SetHeadlights);
	return _SetHeadlights;
}
void U2G_Message::Set_SetHeadlights(const Anki::Cozmo::U2G_SetHeadlights& new_SetHeadlights)
{
	if(this->_type == Type::SetHeadlights) {
		_SetHeadlights = new_SetHeadlights;
	}
	else {
		ClearCurrent();
		new(&_SetHeadlights) Anki::Cozmo::U2G_SetHeadlights{new_SetHeadlights};
		_type = Type::SetHeadlights;
	}
}
void U2G_Message::Set_SetHeadlights(Anki::Cozmo::U2G_SetHeadlights&& new_SetHeadlights)
{
	if(this->_type == Type::SetHeadlights) {
		_SetHeadlights = std::move(new_SetHeadlights);
	}
	else {
		ClearCurrent();
		new(&_SetHeadlights) Anki::Cozmo::U2G_SetHeadlights{std::move(new_SetHeadlights)};
		_type = Type::SetHeadlights;
	}
}


const Anki::Cozmo::U2G_GotoPose& U2G_Message::Get_GotoPose() const
{
	assert(_type == Type::GotoPose);
	return _GotoPose;
}
void U2G_Message::Set_GotoPose(const Anki::Cozmo::U2G_GotoPose& new_GotoPose)
{
	if(this->_type == Type::GotoPose) {
		_GotoPose = new_GotoPose;
	}
	else {
		ClearCurrent();
		new(&_GotoPose) Anki::Cozmo::U2G_GotoPose{new_GotoPose};
		_type = Type::GotoPose;
	}
}
void U2G_Message::Set_GotoPose(Anki::Cozmo::U2G_GotoPose&& new_GotoPose)
{
	if(this->_type == Type::GotoPose) {
		_GotoPose = std::move(new_GotoPose);
	}
	else {
		ClearCurrent();
		new(&_GotoPose) Anki::Cozmo::U2G_GotoPose{std::move(new_GotoPose)};
		_type = Type::GotoPose;
	}
}


const Anki::Cozmo::U2G_PlaceObjectOnGround& U2G_Message::Get_PlaceObjectOnGround() const
{
	assert(_type == Type::PlaceObjectOnGround);
	return _PlaceObjectOnGround;
}
void U2G_Message::Set_PlaceObjectOnGround(const Anki::Cozmo::U2G_PlaceObjectOnGround& new_PlaceObjectOnGround)
{
	if(this->_type == Type::PlaceObjectOnGround) {
		_PlaceObjectOnGround = new_PlaceObjectOnGround;
	}
	else {
		ClearCurrent();
		new(&_PlaceObjectOnGround) Anki::Cozmo::U2G_PlaceObjectOnGround{new_PlaceObjectOnGround};
		_type = Type::PlaceObjectOnGround;
	}
}
void U2G_Message::Set_PlaceObjectOnGround(Anki::Cozmo::U2G_PlaceObjectOnGround&& new_PlaceObjectOnGround)
{
	if(this->_type == Type::PlaceObjectOnGround) {
		_PlaceObjectOnGround = std::move(new_PlaceObjectOnGround);
	}
	else {
		ClearCurrent();
		new(&_PlaceObjectOnGround) Anki::Cozmo::U2G_PlaceObjectOnGround{std::move(new_PlaceObjectOnGround)};
		_type = Type::PlaceObjectOnGround;
	}
}


const Anki::Cozmo::U2G_PlaceObjectOnGroundHere& U2G_Message::Get_PlaceObjectOnGroundHere() const
{
	assert(_type == Type::PlaceObjectOnGroundHere);
	return _PlaceObjectOnGroundHere;
}
void U2G_Message::Set_PlaceObjectOnGroundHere(const Anki::Cozmo::U2G_PlaceObjectOnGroundHere& new_PlaceObjectOnGroundHere)
{
	if(this->_type == Type::PlaceObjectOnGroundHere) {
		_PlaceObjectOnGroundHere = new_PlaceObjectOnGroundHere;
	}
	else {
		ClearCurrent();
		new(&_PlaceObjectOnGroundHere) Anki::Cozmo::U2G_PlaceObjectOnGroundHere{new_PlaceObjectOnGroundHere};
		_type = Type::PlaceObjectOnGroundHere;
	}
}
void U2G_Message::Set_PlaceObjectOnGroundHere(Anki::Cozmo::U2G_PlaceObjectOnGroundHere&& new_PlaceObjectOnGroundHere)
{
	if(this->_type == Type::PlaceObjectOnGroundHere) {
		_PlaceObjectOnGroundHere = std::move(new_PlaceObjectOnGroundHere);
	}
	else {
		ClearCurrent();
		new(&_PlaceObjectOnGroundHere) Anki::Cozmo::U2G_PlaceObjectOnGroundHere{std::move(new_PlaceObjectOnGroundHere)};
		_type = Type::PlaceObjectOnGroundHere;
	}
}


const Anki::Cozmo::U2G_ExecuteTestPlan& U2G_Message::Get_ExecuteTestPlan() const
{
	assert(_type == Type::ExecuteTestPlan);
	return _ExecuteTestPlan;
}
void U2G_Message::Set_ExecuteTestPlan(const Anki::Cozmo::U2G_ExecuteTestPlan& new_ExecuteTestPlan)
{
	if(this->_type == Type::ExecuteTestPlan) {
		_ExecuteTestPlan = new_ExecuteTestPlan;
	}
	else {
		ClearCurrent();
		new(&_ExecuteTestPlan) Anki::Cozmo::U2G_ExecuteTestPlan{new_ExecuteTestPlan};
		_type = Type::ExecuteTestPlan;
	}
}
void U2G_Message::Set_ExecuteTestPlan(Anki::Cozmo::U2G_ExecuteTestPlan&& new_ExecuteTestPlan)
{
	if(this->_type == Type::ExecuteTestPlan) {
		_ExecuteTestPlan = std::move(new_ExecuteTestPlan);
	}
	else {
		ClearCurrent();
		new(&_ExecuteTestPlan) Anki::Cozmo::U2G_ExecuteTestPlan{std::move(new_ExecuteTestPlan)};
		_type = Type::ExecuteTestPlan;
	}
}


const Anki::Cozmo::U2G_SelectNextObject& U2G_Message::Get_SelectNextObject() const
{
	assert(_type == Type::SelectNextObject);
	return _SelectNextObject;
}
void U2G_Message::Set_SelectNextObject(const Anki::Cozmo::U2G_SelectNextObject& new_SelectNextObject)
{
	if(this->_type == Type::SelectNextObject) {
		_SelectNextObject = new_SelectNextObject;
	}
	else {
		ClearCurrent();
		new(&_SelectNextObject) Anki::Cozmo::U2G_SelectNextObject{new_SelectNextObject};
		_type = Type::SelectNextObject;
	}
}
void U2G_Message::Set_SelectNextObject(Anki::Cozmo::U2G_SelectNextObject&& new_SelectNextObject)
{
	if(this->_type == Type::SelectNextObject) {
		_SelectNextObject = std::move(new_SelectNextObject);
	}
	else {
		ClearCurrent();
		new(&_SelectNextObject) Anki::Cozmo::U2G_SelectNextObject{std::move(new_SelectNextObject)};
		_type = Type::SelectNextObject;
	}
}


const Anki::Cozmo::U2G_PickAndPlaceObject& U2G_Message::Get_PickAndPlaceObject() const
{
	assert(_type == Type::PickAndPlaceObject);
	return _PickAndPlaceObject;
}
void U2G_Message::Set_PickAndPlaceObject(const Anki::Cozmo::U2G_PickAndPlaceObject& new_PickAndPlaceObject)
{
	if(this->_type == Type::PickAndPlaceObject) {
		_PickAndPlaceObject = new_PickAndPlaceObject;
	}
	else {
		ClearCurrent();
		new(&_PickAndPlaceObject) Anki::Cozmo::U2G_PickAndPlaceObject{new_PickAndPlaceObject};
		_type = Type::PickAndPlaceObject;
	}
}
void U2G_Message::Set_PickAndPlaceObject(Anki::Cozmo::U2G_PickAndPlaceObject&& new_PickAndPlaceObject)
{
	if(this->_type == Type::PickAndPlaceObject) {
		_PickAndPlaceObject = std::move(new_PickAndPlaceObject);
	}
	else {
		ClearCurrent();
		new(&_PickAndPlaceObject) Anki::Cozmo::U2G_PickAndPlaceObject{std::move(new_PickAndPlaceObject)};
		_type = Type::PickAndPlaceObject;
	}
}


const Anki::Cozmo::U2G_TraverseObject& U2G_Message::Get_TraverseObject() const
{
	assert(_type == Type::TraverseObject);
	return _TraverseObject;
}
void U2G_Message::Set_TraverseObject(const Anki::Cozmo::U2G_TraverseObject& new_TraverseObject)
{
	if(this->_type == Type::TraverseObject) {
		_TraverseObject = new_TraverseObject;
	}
	else {
		ClearCurrent();
		new(&_TraverseObject) Anki::Cozmo::U2G_TraverseObject{new_TraverseObject};
		_type = Type::TraverseObject;
	}
}
void U2G_Message::Set_TraverseObject(Anki::Cozmo::U2G_TraverseObject&& new_TraverseObject)
{
	if(this->_type == Type::TraverseObject) {
		_TraverseObject = std::move(new_TraverseObject);
	}
	else {
		ClearCurrent();
		new(&_TraverseObject) Anki::Cozmo::U2G_TraverseObject{std::move(new_TraverseObject)};
		_type = Type::TraverseObject;
	}
}


const Anki::Cozmo::U2G_SetRobotCarryingObject& U2G_Message::Get_SetRobotCarryingObject() const
{
	assert(_type == Type::SetRobotCarryingObject);
	return _SetRobotCarryingObject;
}
void U2G_Message::Set_SetRobotCarryingObject(const Anki::Cozmo::U2G_SetRobotCarryingObject& new_SetRobotCarryingObject)
{
	if(this->_type == Type::SetRobotCarryingObject) {
		_SetRobotCarryingObject = new_SetRobotCarryingObject;
	}
	else {
		ClearCurrent();
		new(&_SetRobotCarryingObject) Anki::Cozmo::U2G_SetRobotCarryingObject{new_SetRobotCarryingObject};
		_type = Type::SetRobotCarryingObject;
	}
}
void U2G_Message::Set_SetRobotCarryingObject(Anki::Cozmo::U2G_SetRobotCarryingObject&& new_SetRobotCarryingObject)
{
	if(this->_type == Type::SetRobotCarryingObject) {
		_SetRobotCarryingObject = std::move(new_SetRobotCarryingObject);
	}
	else {
		ClearCurrent();
		new(&_SetRobotCarryingObject) Anki::Cozmo::U2G_SetRobotCarryingObject{std::move(new_SetRobotCarryingObject)};
		_type = Type::SetRobotCarryingObject;
	}
}


const Anki::Cozmo::U2G_ClearAllBlocks& U2G_Message::Get_ClearAllBlocks() const
{
	assert(_type == Type::ClearAllBlocks);
	return _ClearAllBlocks;
}
void U2G_Message::Set_ClearAllBlocks(const Anki::Cozmo::U2G_ClearAllBlocks& new_ClearAllBlocks)
{
	if(this->_type == Type::ClearAllBlocks) {
		_ClearAllBlocks = new_ClearAllBlocks;
	}
	else {
		ClearCurrent();
		new(&_ClearAllBlocks) Anki::Cozmo::U2G_ClearAllBlocks{new_ClearAllBlocks};
		_type = Type::ClearAllBlocks;
	}
}
void U2G_Message::Set_ClearAllBlocks(Anki::Cozmo::U2G_ClearAllBlocks&& new_ClearAllBlocks)
{
	if(this->_type == Type::ClearAllBlocks) {
		_ClearAllBlocks = std::move(new_ClearAllBlocks);
	}
	else {
		ClearCurrent();
		new(&_ClearAllBlocks) Anki::Cozmo::U2G_ClearAllBlocks{std::move(new_ClearAllBlocks)};
		_type = Type::ClearAllBlocks;
	}
}


const Anki::Cozmo::U2G_VisionWhileMoving& U2G_Message::Get_VisionWhileMoving() const
{
	assert(_type == Type::VisionWhileMoving);
	return _VisionWhileMoving;
}
void U2G_Message::Set_VisionWhileMoving(const Anki::Cozmo::U2G_VisionWhileMoving& new_VisionWhileMoving)
{
	if(this->_type == Type::VisionWhileMoving) {
		_VisionWhileMoving = new_VisionWhileMoving;
	}
	else {
		ClearCurrent();
		new(&_VisionWhileMoving) Anki::Cozmo::U2G_VisionWhileMoving{new_VisionWhileMoving};
		_type = Type::VisionWhileMoving;
	}
}
void U2G_Message::Set_VisionWhileMoving(Anki::Cozmo::U2G_VisionWhileMoving&& new_VisionWhileMoving)
{
	if(this->_type == Type::VisionWhileMoving) {
		_VisionWhileMoving = std::move(new_VisionWhileMoving);
	}
	else {
		ClearCurrent();
		new(&_VisionWhileMoving) Anki::Cozmo::U2G_VisionWhileMoving{std::move(new_VisionWhileMoving)};
		_type = Type::VisionWhileMoving;
	}
}


const Anki::Cozmo::U2G_ExecuteBehavior& U2G_Message::Get_ExecuteBehavior() const
{
	assert(_type == Type::ExecuteBehavior);
	return _ExecuteBehavior;
}
void U2G_Message::Set_ExecuteBehavior(const Anki::Cozmo::U2G_ExecuteBehavior& new_ExecuteBehavior)
{
	if(this->_type == Type::ExecuteBehavior) {
		_ExecuteBehavior = new_ExecuteBehavior;
	}
	else {
		ClearCurrent();
		new(&_ExecuteBehavior) Anki::Cozmo::U2G_ExecuteBehavior{new_ExecuteBehavior};
		_type = Type::ExecuteBehavior;
	}
}
void U2G_Message::Set_ExecuteBehavior(Anki::Cozmo::U2G_ExecuteBehavior&& new_ExecuteBehavior)
{
	if(this->_type == Type::ExecuteBehavior) {
		_ExecuteBehavior = std::move(new_ExecuteBehavior);
	}
	else {
		ClearCurrent();
		new(&_ExecuteBehavior) Anki::Cozmo::U2G_ExecuteBehavior{std::move(new_ExecuteBehavior)};
		_type = Type::ExecuteBehavior;
	}
}


const Anki::Cozmo::U2G_SetBehaviorState& U2G_Message::Get_SetBehaviorState() const
{
	assert(_type == Type::SetBehaviorState);
	return _SetBehaviorState;
}
void U2G_Message::Set_SetBehaviorState(const Anki::Cozmo::U2G_SetBehaviorState& new_SetBehaviorState)
{
	if(this->_type == Type::SetBehaviorState) {
		_SetBehaviorState = new_SetBehaviorState;
	}
	else {
		ClearCurrent();
		new(&_SetBehaviorState) Anki::Cozmo::U2G_SetBehaviorState{new_SetBehaviorState};
		_type = Type::SetBehaviorState;
	}
}
void U2G_Message::Set_SetBehaviorState(Anki::Cozmo::U2G_SetBehaviorState&& new_SetBehaviorState)
{
	if(this->_type == Type::SetBehaviorState) {
		_SetBehaviorState = std::move(new_SetBehaviorState);
	}
	else {
		ClearCurrent();
		new(&_SetBehaviorState) Anki::Cozmo::U2G_SetBehaviorState{std::move(new_SetBehaviorState)};
		_type = Type::SetBehaviorState;
	}
}


const Anki::Cozmo::U2G_AbortPath& U2G_Message::Get_AbortPath() const
{
	assert(_type == Type::AbortPath);
	return _AbortPath;
}
void U2G_Message::Set_AbortPath(const Anki::Cozmo::U2G_AbortPath& new_AbortPath)
{
	if(this->_type == Type::AbortPath) {
		_AbortPath = new_AbortPath;
	}
	else {
		ClearCurrent();
		new(&_AbortPath) Anki::Cozmo::U2G_AbortPath{new_AbortPath};
		_type = Type::AbortPath;
	}
}
void U2G_Message::Set_AbortPath(Anki::Cozmo::U2G_AbortPath&& new_AbortPath)
{
	if(this->_type == Type::AbortPath) {
		_AbortPath = std::move(new_AbortPath);
	}
	else {
		ClearCurrent();
		new(&_AbortPath) Anki::Cozmo::U2G_AbortPath{std::move(new_AbortPath)};
		_type = Type::AbortPath;
	}
}


const Anki::Cozmo::U2G_AbortAll& U2G_Message::Get_AbortAll() const
{
	assert(_type == Type::AbortAll);
	return _AbortAll;
}
void U2G_Message::Set_AbortAll(const Anki::Cozmo::U2G_AbortAll& new_AbortAll)
{
	if(this->_type == Type::AbortAll) {
		_AbortAll = new_AbortAll;
	}
	else {
		ClearCurrent();
		new(&_AbortAll) Anki::Cozmo::U2G_AbortAll{new_AbortAll};
		_type = Type::AbortAll;
	}
}
void U2G_Message::Set_AbortAll(Anki::Cozmo::U2G_AbortAll&& new_AbortAll)
{
	if(this->_type == Type::AbortAll) {
		_AbortAll = std::move(new_AbortAll);
	}
	else {
		ClearCurrent();
		new(&_AbortAll) Anki::Cozmo::U2G_AbortAll{std::move(new_AbortAll)};
		_type = Type::AbortAll;
	}
}


const Anki::Cozmo::U2G_DrawPoseMarker& U2G_Message::Get_DrawPoseMarker() const
{
	assert(_type == Type::DrawPoseMarker);
	return _DrawPoseMarker;
}
void U2G_Message::Set_DrawPoseMarker(const Anki::Cozmo::U2G_DrawPoseMarker& new_DrawPoseMarker)
{
	if(this->_type == Type::DrawPoseMarker) {
		_DrawPoseMarker = new_DrawPoseMarker;
	}
	else {
		ClearCurrent();
		new(&_DrawPoseMarker) Anki::Cozmo::U2G_DrawPoseMarker{new_DrawPoseMarker};
		_type = Type::DrawPoseMarker;
	}
}
void U2G_Message::Set_DrawPoseMarker(Anki::Cozmo::U2G_DrawPoseMarker&& new_DrawPoseMarker)
{
	if(this->_type == Type::DrawPoseMarker) {
		_DrawPoseMarker = std::move(new_DrawPoseMarker);
	}
	else {
		ClearCurrent();
		new(&_DrawPoseMarker) Anki::Cozmo::U2G_DrawPoseMarker{std::move(new_DrawPoseMarker)};
		_type = Type::DrawPoseMarker;
	}
}


const Anki::Cozmo::U2G_ErasePoseMarker& U2G_Message::Get_ErasePoseMarker() const
{
	assert(_type == Type::ErasePoseMarker);
	return _ErasePoseMarker;
}
void U2G_Message::Set_ErasePoseMarker(const Anki::Cozmo::U2G_ErasePoseMarker& new_ErasePoseMarker)
{
	if(this->_type == Type::ErasePoseMarker) {
		_ErasePoseMarker = new_ErasePoseMarker;
	}
	else {
		ClearCurrent();
		new(&_ErasePoseMarker) Anki::Cozmo::U2G_ErasePoseMarker{new_ErasePoseMarker};
		_type = Type::ErasePoseMarker;
	}
}
void U2G_Message::Set_ErasePoseMarker(Anki::Cozmo::U2G_ErasePoseMarker&& new_ErasePoseMarker)
{
	if(this->_type == Type::ErasePoseMarker) {
		_ErasePoseMarker = std::move(new_ErasePoseMarker);
	}
	else {
		ClearCurrent();
		new(&_ErasePoseMarker) Anki::Cozmo::U2G_ErasePoseMarker{std::move(new_ErasePoseMarker)};
		_type = Type::ErasePoseMarker;
	}
}


const Anki::Cozmo::U2G_SetHeadControllerGains& U2G_Message::Get_SetHeadControllerGains() const
{
	assert(_type == Type::SetHeadControllerGains);
	return _SetHeadControllerGains;
}
void U2G_Message::Set_SetHeadControllerGains(const Anki::Cozmo::U2G_SetHeadControllerGains& new_SetHeadControllerGains)
{
	if(this->_type == Type::SetHeadControllerGains) {
		_SetHeadControllerGains = new_SetHeadControllerGains;
	}
	else {
		ClearCurrent();
		new(&_SetHeadControllerGains) Anki::Cozmo::U2G_SetHeadControllerGains{new_SetHeadControllerGains};
		_type = Type::SetHeadControllerGains;
	}
}
void U2G_Message::Set_SetHeadControllerGains(Anki::Cozmo::U2G_SetHeadControllerGains&& new_SetHeadControllerGains)
{
	if(this->_type == Type::SetHeadControllerGains) {
		_SetHeadControllerGains = std::move(new_SetHeadControllerGains);
	}
	else {
		ClearCurrent();
		new(&_SetHeadControllerGains) Anki::Cozmo::U2G_SetHeadControllerGains{std::move(new_SetHeadControllerGains)};
		_type = Type::SetHeadControllerGains;
	}
}


const Anki::Cozmo::U2G_SetLiftControllerGains& U2G_Message::Get_SetLiftControllerGains() const
{
	assert(_type == Type::SetLiftControllerGains);
	return _SetLiftControllerGains;
}
void U2G_Message::Set_SetLiftControllerGains(const Anki::Cozmo::U2G_SetLiftControllerGains& new_SetLiftControllerGains)
{
	if(this->_type == Type::SetLiftControllerGains) {
		_SetLiftControllerGains = new_SetLiftControllerGains;
	}
	else {
		ClearCurrent();
		new(&_SetLiftControllerGains) Anki::Cozmo::U2G_SetLiftControllerGains{new_SetLiftControllerGains};
		_type = Type::SetLiftControllerGains;
	}
}
void U2G_Message::Set_SetLiftControllerGains(Anki::Cozmo::U2G_SetLiftControllerGains&& new_SetLiftControllerGains)
{
	if(this->_type == Type::SetLiftControllerGains) {
		_SetLiftControllerGains = std::move(new_SetLiftControllerGains);
	}
	else {
		ClearCurrent();
		new(&_SetLiftControllerGains) Anki::Cozmo::U2G_SetLiftControllerGains{std::move(new_SetLiftControllerGains)};
		_type = Type::SetLiftControllerGains;
	}
}


const Anki::Cozmo::U2G_SelectNextSoundScheme& U2G_Message::Get_SelectNextSoundScheme() const
{
	assert(_type == Type::SelectNextSoundScheme);
	return _SelectNextSoundScheme;
}
void U2G_Message::Set_SelectNextSoundScheme(const Anki::Cozmo::U2G_SelectNextSoundScheme& new_SelectNextSoundScheme)
{
	if(this->_type == Type::SelectNextSoundScheme) {
		_SelectNextSoundScheme = new_SelectNextSoundScheme;
	}
	else {
		ClearCurrent();
		new(&_SelectNextSoundScheme) Anki::Cozmo::U2G_SelectNextSoundScheme{new_SelectNextSoundScheme};
		_type = Type::SelectNextSoundScheme;
	}
}
void U2G_Message::Set_SelectNextSoundScheme(Anki::Cozmo::U2G_SelectNextSoundScheme&& new_SelectNextSoundScheme)
{
	if(this->_type == Type::SelectNextSoundScheme) {
		_SelectNextSoundScheme = std::move(new_SelectNextSoundScheme);
	}
	else {
		ClearCurrent();
		new(&_SelectNextSoundScheme) Anki::Cozmo::U2G_SelectNextSoundScheme{std::move(new_SelectNextSoundScheme)};
		_type = Type::SelectNextSoundScheme;
	}
}


const Anki::Cozmo::U2G_StartTestMode& U2G_Message::Get_StartTestMode() const
{
	assert(_type == Type::StartTestMode);
	return _StartTestMode;
}
void U2G_Message::Set_StartTestMode(const Anki::Cozmo::U2G_StartTestMode& new_StartTestMode)
{
	if(this->_type == Type::StartTestMode) {
		_StartTestMode = new_StartTestMode;
	}
	else {
		ClearCurrent();
		new(&_StartTestMode) Anki::Cozmo::U2G_StartTestMode{new_StartTestMode};
		_type = Type::StartTestMode;
	}
}
void U2G_Message::Set_StartTestMode(Anki::Cozmo::U2G_StartTestMode&& new_StartTestMode)
{
	if(this->_type == Type::StartTestMode) {
		_StartTestMode = std::move(new_StartTestMode);
	}
	else {
		ClearCurrent();
		new(&_StartTestMode) Anki::Cozmo::U2G_StartTestMode{std::move(new_StartTestMode)};
		_type = Type::StartTestMode;
	}
}


const Anki::Cozmo::U2G_IMURequest& U2G_Message::Get_IMURequest() const
{
	assert(_type == Type::IMURequest);
	return _IMURequest;
}
void U2G_Message::Set_IMURequest(const Anki::Cozmo::U2G_IMURequest& new_IMURequest)
{
	if(this->_type == Type::IMURequest) {
		_IMURequest = new_IMURequest;
	}
	else {
		ClearCurrent();
		new(&_IMURequest) Anki::Cozmo::U2G_IMURequest{new_IMURequest};
		_type = Type::IMURequest;
	}
}
void U2G_Message::Set_IMURequest(Anki::Cozmo::U2G_IMURequest&& new_IMURequest)
{
	if(this->_type == Type::IMURequest) {
		_IMURequest = std::move(new_IMURequest);
	}
	else {
		ClearCurrent();
		new(&_IMURequest) Anki::Cozmo::U2G_IMURequest{std::move(new_IMURequest)};
		_type = Type::IMURequest;
	}
}


const Anki::Cozmo::U2G_PlayAnimation& U2G_Message::Get_PlayAnimation() const
{
	assert(_type == Type::PlayAnimation);
	return _PlayAnimation;
}
void U2G_Message::Set_PlayAnimation(const Anki::Cozmo::U2G_PlayAnimation& new_PlayAnimation)
{
	if(this->_type == Type::PlayAnimation) {
		_PlayAnimation = new_PlayAnimation;
	}
	else {
		ClearCurrent();
		new(&_PlayAnimation) Anki::Cozmo::U2G_PlayAnimation{new_PlayAnimation};
		_type = Type::PlayAnimation;
	}
}
void U2G_Message::Set_PlayAnimation(Anki::Cozmo::U2G_PlayAnimation&& new_PlayAnimation)
{
	if(this->_type == Type::PlayAnimation) {
		_PlayAnimation = std::move(new_PlayAnimation);
	}
	else {
		ClearCurrent();
		new(&_PlayAnimation) Anki::Cozmo::U2G_PlayAnimation{std::move(new_PlayAnimation)};
		_type = Type::PlayAnimation;
	}
}


const Anki::Cozmo::U2G_ReadAnimationFile& U2G_Message::Get_ReadAnimationFile() const
{
	assert(_type == Type::ReadAnimationFile);
	return _ReadAnimationFile;
}
void U2G_Message::Set_ReadAnimationFile(const Anki::Cozmo::U2G_ReadAnimationFile& new_ReadAnimationFile)
{
	if(this->_type == Type::ReadAnimationFile) {
		_ReadAnimationFile = new_ReadAnimationFile;
	}
	else {
		ClearCurrent();
		new(&_ReadAnimationFile) Anki::Cozmo::U2G_ReadAnimationFile{new_ReadAnimationFile};
		_type = Type::ReadAnimationFile;
	}
}
void U2G_Message::Set_ReadAnimationFile(Anki::Cozmo::U2G_ReadAnimationFile&& new_ReadAnimationFile)
{
	if(this->_type == Type::ReadAnimationFile) {
		_ReadAnimationFile = std::move(new_ReadAnimationFile);
	}
	else {
		ClearCurrent();
		new(&_ReadAnimationFile) Anki::Cozmo::U2G_ReadAnimationFile{std::move(new_ReadAnimationFile)};
		_type = Type::ReadAnimationFile;
	}
}


const Anki::Cozmo::U2G_StartFaceTracking& U2G_Message::Get_StartFaceTracking() const
{
	assert(_type == Type::StartFaceTracking);
	return _StartFaceTracking;
}
void U2G_Message::Set_StartFaceTracking(const Anki::Cozmo::U2G_StartFaceTracking& new_StartFaceTracking)
{
	if(this->_type == Type::StartFaceTracking) {
		_StartFaceTracking = new_StartFaceTracking;
	}
	else {
		ClearCurrent();
		new(&_StartFaceTracking) Anki::Cozmo::U2G_StartFaceTracking{new_StartFaceTracking};
		_type = Type::StartFaceTracking;
	}
}
void U2G_Message::Set_StartFaceTracking(Anki::Cozmo::U2G_StartFaceTracking&& new_StartFaceTracking)
{
	if(this->_type == Type::StartFaceTracking) {
		_StartFaceTracking = std::move(new_StartFaceTracking);
	}
	else {
		ClearCurrent();
		new(&_StartFaceTracking) Anki::Cozmo::U2G_StartFaceTracking{std::move(new_StartFaceTracking)};
		_type = Type::StartFaceTracking;
	}
}


const Anki::Cozmo::U2G_StopFaceTracking& U2G_Message::Get_StopFaceTracking() const
{
	assert(_type == Type::StopFaceTracking);
	return _StopFaceTracking;
}
void U2G_Message::Set_StopFaceTracking(const Anki::Cozmo::U2G_StopFaceTracking& new_StopFaceTracking)
{
	if(this->_type == Type::StopFaceTracking) {
		_StopFaceTracking = new_StopFaceTracking;
	}
	else {
		ClearCurrent();
		new(&_StopFaceTracking) Anki::Cozmo::U2G_StopFaceTracking{new_StopFaceTracking};
		_type = Type::StopFaceTracking;
	}
}
void U2G_Message::Set_StopFaceTracking(Anki::Cozmo::U2G_StopFaceTracking&& new_StopFaceTracking)
{
	if(this->_type == Type::StopFaceTracking) {
		_StopFaceTracking = std::move(new_StopFaceTracking);
	}
	else {
		ClearCurrent();
		new(&_StopFaceTracking) Anki::Cozmo::U2G_StopFaceTracking{std::move(new_StopFaceTracking)};
		_type = Type::StopFaceTracking;
	}
}


const Anki::Cozmo::U2G_StartLookingForMarkers& U2G_Message::Get_StartLookingForMarkers() const
{
	assert(_type == Type::StartLookingForMarkers);
	return _StartLookingForMarkers;
}
void U2G_Message::Set_StartLookingForMarkers(const Anki::Cozmo::U2G_StartLookingForMarkers& new_StartLookingForMarkers)
{
	if(this->_type == Type::StartLookingForMarkers) {
		_StartLookingForMarkers = new_StartLookingForMarkers;
	}
	else {
		ClearCurrent();
		new(&_StartLookingForMarkers) Anki::Cozmo::U2G_StartLookingForMarkers{new_StartLookingForMarkers};
		_type = Type::StartLookingForMarkers;
	}
}
void U2G_Message::Set_StartLookingForMarkers(Anki::Cozmo::U2G_StartLookingForMarkers&& new_StartLookingForMarkers)
{
	if(this->_type == Type::StartLookingForMarkers) {
		_StartLookingForMarkers = std::move(new_StartLookingForMarkers);
	}
	else {
		ClearCurrent();
		new(&_StartLookingForMarkers) Anki::Cozmo::U2G_StartLookingForMarkers{std::move(new_StartLookingForMarkers)};
		_type = Type::StartLookingForMarkers;
	}
}


const Anki::Cozmo::U2G_StopLookingForMarkers& U2G_Message::Get_StopLookingForMarkers() const
{
	assert(_type == Type::StopLookingForMarkers);
	return _StopLookingForMarkers;
}
void U2G_Message::Set_StopLookingForMarkers(const Anki::Cozmo::U2G_StopLookingForMarkers& new_StopLookingForMarkers)
{
	if(this->_type == Type::StopLookingForMarkers) {
		_StopLookingForMarkers = new_StopLookingForMarkers;
	}
	else {
		ClearCurrent();
		new(&_StopLookingForMarkers) Anki::Cozmo::U2G_StopLookingForMarkers{new_StopLookingForMarkers};
		_type = Type::StopLookingForMarkers;
	}
}
void U2G_Message::Set_StopLookingForMarkers(Anki::Cozmo::U2G_StopLookingForMarkers&& new_StopLookingForMarkers)
{
	if(this->_type == Type::StopLookingForMarkers) {
		_StopLookingForMarkers = std::move(new_StopLookingForMarkers);
	}
	else {
		ClearCurrent();
		new(&_StopLookingForMarkers) Anki::Cozmo::U2G_StopLookingForMarkers{std::move(new_StopLookingForMarkers)};
		_type = Type::StopLookingForMarkers;
	}
}


const Anki::Cozmo::U2G_SetVisionSystemParams& U2G_Message::Get_SetVisionSystemParams() const
{
	assert(_type == Type::SetVisionSystemParams);
	return _SetVisionSystemParams;
}
void U2G_Message::Set_SetVisionSystemParams(const Anki::Cozmo::U2G_SetVisionSystemParams& new_SetVisionSystemParams)
{
	if(this->_type == Type::SetVisionSystemParams) {
		_SetVisionSystemParams = new_SetVisionSystemParams;
	}
	else {
		ClearCurrent();
		new(&_SetVisionSystemParams) Anki::Cozmo::U2G_SetVisionSystemParams{new_SetVisionSystemParams};
		_type = Type::SetVisionSystemParams;
	}
}
void U2G_Message::Set_SetVisionSystemParams(Anki::Cozmo::U2G_SetVisionSystemParams&& new_SetVisionSystemParams)
{
	if(this->_type == Type::SetVisionSystemParams) {
		_SetVisionSystemParams = std::move(new_SetVisionSystemParams);
	}
	else {
		ClearCurrent();
		new(&_SetVisionSystemParams) Anki::Cozmo::U2G_SetVisionSystemParams{std::move(new_SetVisionSystemParams)};
		_type = Type::SetVisionSystemParams;
	}
}


const Anki::Cozmo::U2G_SetFaceDetectParams& U2G_Message::Get_SetFaceDetectParams() const
{
	assert(_type == Type::SetFaceDetectParams);
	return _SetFaceDetectParams;
}
void U2G_Message::Set_SetFaceDetectParams(const Anki::Cozmo::U2G_SetFaceDetectParams& new_SetFaceDetectParams)
{
	if(this->_type == Type::SetFaceDetectParams) {
		_SetFaceDetectParams = new_SetFaceDetectParams;
	}
	else {
		ClearCurrent();
		new(&_SetFaceDetectParams) Anki::Cozmo::U2G_SetFaceDetectParams{new_SetFaceDetectParams};
		_type = Type::SetFaceDetectParams;
	}
}
void U2G_Message::Set_SetFaceDetectParams(Anki::Cozmo::U2G_SetFaceDetectParams&& new_SetFaceDetectParams)
{
	if(this->_type == Type::SetFaceDetectParams) {
		_SetFaceDetectParams = std::move(new_SetFaceDetectParams);
	}
	else {
		ClearCurrent();
		new(&_SetFaceDetectParams) Anki::Cozmo::U2G_SetFaceDetectParams{std::move(new_SetFaceDetectParams)};
		_type = Type::SetFaceDetectParams;
	}
}


size_t U2G_Message::Unpack(const uint8_t* buff, const size_t len)
{
	const SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t U2G_Message::Unpack(const SafeMessageBuffer& buffer)
{
	Type newType {Type::INVALID};
	const Type oldType {GetType()};
	buffer.Read(newType);
	if (newType != oldType) {
		ClearCurrent();
	}
	switch(newType) {
	case Type::Ping:
		if (newType != oldType) {
			new(&(this->_Ping)) Anki::Cozmo::U2G_Ping(buffer);
		}
		else {
			this->_Ping.Unpack(buffer);
		}
		break;
	case Type::ConnectToRobot:
		if (newType != oldType) {
			new(&(this->_ConnectToRobot)) Anki::Cozmo::U2G_ConnectToRobot(buffer);
		}
		else {
			this->_ConnectToRobot.Unpack(buffer);
		}
		break;
	case Type::ConnectToUiDevice:
		if (newType != oldType) {
			new(&(this->_ConnectToUiDevice)) Anki::Cozmo::U2G_ConnectToUiDevice(buffer);
		}
		else {
			this->_ConnectToUiDevice.Unpack(buffer);
		}
		break;
	case Type::DisconnectFromUiDevice:
		if (newType != oldType) {
			new(&(this->_DisconnectFromUiDevice)) Anki::Cozmo::U2G_DisconnectFromUiDevice(buffer);
		}
		else {
			this->_DisconnectFromUiDevice.Unpack(buffer);
		}
		break;
	case Type::ForceAddRobot:
		if (newType != oldType) {
			new(&(this->_ForceAddRobot)) Anki::Cozmo::U2G_ForceAddRobot(buffer);
		}
		else {
			this->_ForceAddRobot.Unpack(buffer);
		}
		break;
	case Type::StartEngine:
		if (newType != oldType) {
			new(&(this->_StartEngine)) Anki::Cozmo::U2G_StartEngine(buffer);
		}
		else {
			this->_StartEngine.Unpack(buffer);
		}
		break;
	case Type::DriveWheels:
		if (newType != oldType) {
			new(&(this->_DriveWheels)) Anki::Cozmo::U2G_DriveWheels(buffer);
		}
		else {
			this->_DriveWheels.Unpack(buffer);
		}
		break;
	case Type::TurnInPlace:
		if (newType != oldType) {
			new(&(this->_TurnInPlace)) Anki::Cozmo::U2G_TurnInPlace(buffer);
		}
		else {
			this->_TurnInPlace.Unpack(buffer);
		}
		break;
	case Type::MoveHead:
		if (newType != oldType) {
			new(&(this->_MoveHead)) Anki::Cozmo::U2G_MoveHead(buffer);
		}
		else {
			this->_MoveHead.Unpack(buffer);
		}
		break;
	case Type::MoveLift:
		if (newType != oldType) {
			new(&(this->_MoveLift)) Anki::Cozmo::U2G_MoveLift(buffer);
		}
		else {
			this->_MoveLift.Unpack(buffer);
		}
		break;
	case Type::SetLiftHeight:
		if (newType != oldType) {
			new(&(this->_SetLiftHeight)) Anki::Cozmo::U2G_SetLiftHeight(buffer);
		}
		else {
			this->_SetLiftHeight.Unpack(buffer);
		}
		break;
	case Type::SetHeadAngle:
		if (newType != oldType) {
			new(&(this->_SetHeadAngle)) Anki::Cozmo::U2G_SetHeadAngle(buffer);
		}
		else {
			this->_SetHeadAngle.Unpack(buffer);
		}
		break;
	case Type::TrackHeadToObject:
		if (newType != oldType) {
			new(&(this->_TrackHeadToObject)) Anki::Cozmo::U2G_TrackHeadToObject(buffer);
		}
		else {
			this->_TrackHeadToObject.Unpack(buffer);
		}
		break;
	case Type::StopAllMotors:
		if (newType != oldType) {
			new(&(this->_StopAllMotors)) Anki::Cozmo::U2G_StopAllMotors(buffer);
		}
		else {
			this->_StopAllMotors.Unpack(buffer);
		}
		break;
	case Type::ImageRequest:
		if (newType != oldType) {
			new(&(this->_ImageRequest)) Anki::Cozmo::U2G_ImageRequest(buffer);
		}
		else {
			this->_ImageRequest.Unpack(buffer);
		}
		break;
	case Type::SetRobotImageSendMode:
		if (newType != oldType) {
			new(&(this->_SetRobotImageSendMode)) Anki::Cozmo::U2G_SetRobotImageSendMode(buffer);
		}
		else {
			this->_SetRobotImageSendMode.Unpack(buffer);
		}
		break;
	case Type::SaveImages:
		if (newType != oldType) {
			new(&(this->_SaveImages)) Anki::Cozmo::U2G_SaveImages(buffer);
		}
		else {
			this->_SaveImages.Unpack(buffer);
		}
		break;
	case Type::SaveRobotState:
		if (newType != oldType) {
			new(&(this->_SaveRobotState)) Anki::Cozmo::U2G_SaveRobotState(buffer);
		}
		else {
			this->_SaveRobotState.Unpack(buffer);
		}
		break;
	case Type::EnableDisplay:
		if (newType != oldType) {
			new(&(this->_EnableDisplay)) Anki::Cozmo::U2G_EnableDisplay(buffer);
		}
		else {
			this->_EnableDisplay.Unpack(buffer);
		}
		break;
	case Type::SetHeadlights:
		if (newType != oldType) {
			new(&(this->_SetHeadlights)) Anki::Cozmo::U2G_SetHeadlights(buffer);
		}
		else {
			this->_SetHeadlights.Unpack(buffer);
		}
		break;
	case Type::GotoPose:
		if (newType != oldType) {
			new(&(this->_GotoPose)) Anki::Cozmo::U2G_GotoPose(buffer);
		}
		else {
			this->_GotoPose.Unpack(buffer);
		}
		break;
	case Type::PlaceObjectOnGround:
		if (newType != oldType) {
			new(&(this->_PlaceObjectOnGround)) Anki::Cozmo::U2G_PlaceObjectOnGround(buffer);
		}
		else {
			this->_PlaceObjectOnGround.Unpack(buffer);
		}
		break;
	case Type::PlaceObjectOnGroundHere:
		if (newType != oldType) {
			new(&(this->_PlaceObjectOnGroundHere)) Anki::Cozmo::U2G_PlaceObjectOnGroundHere(buffer);
		}
		else {
			this->_PlaceObjectOnGroundHere.Unpack(buffer);
		}
		break;
	case Type::ExecuteTestPlan:
		if (newType != oldType) {
			new(&(this->_ExecuteTestPlan)) Anki::Cozmo::U2G_ExecuteTestPlan(buffer);
		}
		else {
			this->_ExecuteTestPlan.Unpack(buffer);
		}
		break;
	case Type::SelectNextObject:
		if (newType != oldType) {
			new(&(this->_SelectNextObject)) Anki::Cozmo::U2G_SelectNextObject(buffer);
		}
		else {
			this->_SelectNextObject.Unpack(buffer);
		}
		break;
	case Type::PickAndPlaceObject:
		if (newType != oldType) {
			new(&(this->_PickAndPlaceObject)) Anki::Cozmo::U2G_PickAndPlaceObject(buffer);
		}
		else {
			this->_PickAndPlaceObject.Unpack(buffer);
		}
		break;
	case Type::TraverseObject:
		if (newType != oldType) {
			new(&(this->_TraverseObject)) Anki::Cozmo::U2G_TraverseObject(buffer);
		}
		else {
			this->_TraverseObject.Unpack(buffer);
		}
		break;
	case Type::SetRobotCarryingObject:
		if (newType != oldType) {
			new(&(this->_SetRobotCarryingObject)) Anki::Cozmo::U2G_SetRobotCarryingObject(buffer);
		}
		else {
			this->_SetRobotCarryingObject.Unpack(buffer);
		}
		break;
	case Type::ClearAllBlocks:
		if (newType != oldType) {
			new(&(this->_ClearAllBlocks)) Anki::Cozmo::U2G_ClearAllBlocks(buffer);
		}
		else {
			this->_ClearAllBlocks.Unpack(buffer);
		}
		break;
	case Type::VisionWhileMoving:
		if (newType != oldType) {
			new(&(this->_VisionWhileMoving)) Anki::Cozmo::U2G_VisionWhileMoving(buffer);
		}
		else {
			this->_VisionWhileMoving.Unpack(buffer);
		}
		break;
	case Type::ExecuteBehavior:
		if (newType != oldType) {
			new(&(this->_ExecuteBehavior)) Anki::Cozmo::U2G_ExecuteBehavior(buffer);
		}
		else {
			this->_ExecuteBehavior.Unpack(buffer);
		}
		break;
	case Type::SetBehaviorState:
		if (newType != oldType) {
			new(&(this->_SetBehaviorState)) Anki::Cozmo::U2G_SetBehaviorState(buffer);
		}
		else {
			this->_SetBehaviorState.Unpack(buffer);
		}
		break;
	case Type::AbortPath:
		if (newType != oldType) {
			new(&(this->_AbortPath)) Anki::Cozmo::U2G_AbortPath(buffer);
		}
		else {
			this->_AbortPath.Unpack(buffer);
		}
		break;
	case Type::AbortAll:
		if (newType != oldType) {
			new(&(this->_AbortAll)) Anki::Cozmo::U2G_AbortAll(buffer);
		}
		else {
			this->_AbortAll.Unpack(buffer);
		}
		break;
	case Type::DrawPoseMarker:
		if (newType != oldType) {
			new(&(this->_DrawPoseMarker)) Anki::Cozmo::U2G_DrawPoseMarker(buffer);
		}
		else {
			this->_DrawPoseMarker.Unpack(buffer);
		}
		break;
	case Type::ErasePoseMarker:
		if (newType != oldType) {
			new(&(this->_ErasePoseMarker)) Anki::Cozmo::U2G_ErasePoseMarker(buffer);
		}
		else {
			this->_ErasePoseMarker.Unpack(buffer);
		}
		break;
	case Type::SetHeadControllerGains:
		if (newType != oldType) {
			new(&(this->_SetHeadControllerGains)) Anki::Cozmo::U2G_SetHeadControllerGains(buffer);
		}
		else {
			this->_SetHeadControllerGains.Unpack(buffer);
		}
		break;
	case Type::SetLiftControllerGains:
		if (newType != oldType) {
			new(&(this->_SetLiftControllerGains)) Anki::Cozmo::U2G_SetLiftControllerGains(buffer);
		}
		else {
			this->_SetLiftControllerGains.Unpack(buffer);
		}
		break;
	case Type::SelectNextSoundScheme:
		if (newType != oldType) {
			new(&(this->_SelectNextSoundScheme)) Anki::Cozmo::U2G_SelectNextSoundScheme(buffer);
		}
		else {
			this->_SelectNextSoundScheme.Unpack(buffer);
		}
		break;
	case Type::StartTestMode:
		if (newType != oldType) {
			new(&(this->_StartTestMode)) Anki::Cozmo::U2G_StartTestMode(buffer);
		}
		else {
			this->_StartTestMode.Unpack(buffer);
		}
		break;
	case Type::IMURequest:
		if (newType != oldType) {
			new(&(this->_IMURequest)) Anki::Cozmo::U2G_IMURequest(buffer);
		}
		else {
			this->_IMURequest.Unpack(buffer);
		}
		break;
	case Type::PlayAnimation:
		if (newType != oldType) {
			new(&(this->_PlayAnimation)) Anki::Cozmo::U2G_PlayAnimation(buffer);
		}
		else {
			this->_PlayAnimation.Unpack(buffer);
		}
		break;
	case Type::ReadAnimationFile:
		if (newType != oldType) {
			new(&(this->_ReadAnimationFile)) Anki::Cozmo::U2G_ReadAnimationFile(buffer);
		}
		else {
			this->_ReadAnimationFile.Unpack(buffer);
		}
		break;
	case Type::StartFaceTracking:
		if (newType != oldType) {
			new(&(this->_StartFaceTracking)) Anki::Cozmo::U2G_StartFaceTracking(buffer);
		}
		else {
			this->_StartFaceTracking.Unpack(buffer);
		}
		break;
	case Type::StopFaceTracking:
		if (newType != oldType) {
			new(&(this->_StopFaceTracking)) Anki::Cozmo::U2G_StopFaceTracking(buffer);
		}
		else {
			this->_StopFaceTracking.Unpack(buffer);
		}
		break;
	case Type::StartLookingForMarkers:
		if (newType != oldType) {
			new(&(this->_StartLookingForMarkers)) Anki::Cozmo::U2G_StartLookingForMarkers(buffer);
		}
		else {
			this->_StartLookingForMarkers.Unpack(buffer);
		}
		break;
	case Type::StopLookingForMarkers:
		if (newType != oldType) {
			new(&(this->_StopLookingForMarkers)) Anki::Cozmo::U2G_StopLookingForMarkers(buffer);
		}
		else {
			this->_StopLookingForMarkers.Unpack(buffer);
		}
		break;
	case Type::SetVisionSystemParams:
		if (newType != oldType) {
			new(&(this->_SetVisionSystemParams)) Anki::Cozmo::U2G_SetVisionSystemParams(buffer);
		}
		else {
			this->_SetVisionSystemParams.Unpack(buffer);
		}
		break;
	case Type::SetFaceDetectParams:
		if (newType != oldType) {
			new(&(this->_SetFaceDetectParams)) Anki::Cozmo::U2G_SetFaceDetectParams(buffer);
		}
		else {
			this->_SetFaceDetectParams.Unpack(buffer);
		}
		break;
	default:
		break;
	}
	_type = newType;
	return buffer.GetBytesRead();
}

size_t U2G_Message::Pack(uint8_t* buff, size_t len) const
{
	SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t U2G_Message::Pack(SafeMessageBuffer& buffer) const
{
	buffer.Write(_type);
	switch(GetType()) {
	case Type::Ping:
		this->_Ping.Pack(buffer);
		break;
	case Type::ConnectToRobot:
		this->_ConnectToRobot.Pack(buffer);
		break;
	case Type::ConnectToUiDevice:
		this->_ConnectToUiDevice.Pack(buffer);
		break;
	case Type::DisconnectFromUiDevice:
		this->_DisconnectFromUiDevice.Pack(buffer);
		break;
	case Type::ForceAddRobot:
		this->_ForceAddRobot.Pack(buffer);
		break;
	case Type::StartEngine:
		this->_StartEngine.Pack(buffer);
		break;
	case Type::DriveWheels:
		this->_DriveWheels.Pack(buffer);
		break;
	case Type::TurnInPlace:
		this->_TurnInPlace.Pack(buffer);
		break;
	case Type::MoveHead:
		this->_MoveHead.Pack(buffer);
		break;
	case Type::MoveLift:
		this->_MoveLift.Pack(buffer);
		break;
	case Type::SetLiftHeight:
		this->_SetLiftHeight.Pack(buffer);
		break;
	case Type::SetHeadAngle:
		this->_SetHeadAngle.Pack(buffer);
		break;
	case Type::TrackHeadToObject:
		this->_TrackHeadToObject.Pack(buffer);
		break;
	case Type::StopAllMotors:
		this->_StopAllMotors.Pack(buffer);
		break;
	case Type::ImageRequest:
		this->_ImageRequest.Pack(buffer);
		break;
	case Type::SetRobotImageSendMode:
		this->_SetRobotImageSendMode.Pack(buffer);
		break;
	case Type::SaveImages:
		this->_SaveImages.Pack(buffer);
		break;
	case Type::SaveRobotState:
		this->_SaveRobotState.Pack(buffer);
		break;
	case Type::EnableDisplay:
		this->_EnableDisplay.Pack(buffer);
		break;
	case Type::SetHeadlights:
		this->_SetHeadlights.Pack(buffer);
		break;
	case Type::GotoPose:
		this->_GotoPose.Pack(buffer);
		break;
	case Type::PlaceObjectOnGround:
		this->_PlaceObjectOnGround.Pack(buffer);
		break;
	case Type::PlaceObjectOnGroundHere:
		this->_PlaceObjectOnGroundHere.Pack(buffer);
		break;
	case Type::ExecuteTestPlan:
		this->_ExecuteTestPlan.Pack(buffer);
		break;
	case Type::SelectNextObject:
		this->_SelectNextObject.Pack(buffer);
		break;
	case Type::PickAndPlaceObject:
		this->_PickAndPlaceObject.Pack(buffer);
		break;
	case Type::TraverseObject:
		this->_TraverseObject.Pack(buffer);
		break;
	case Type::SetRobotCarryingObject:
		this->_SetRobotCarryingObject.Pack(buffer);
		break;
	case Type::ClearAllBlocks:
		this->_ClearAllBlocks.Pack(buffer);
		break;
	case Type::VisionWhileMoving:
		this->_VisionWhileMoving.Pack(buffer);
		break;
	case Type::ExecuteBehavior:
		this->_ExecuteBehavior.Pack(buffer);
		break;
	case Type::SetBehaviorState:
		this->_SetBehaviorState.Pack(buffer);
		break;
	case Type::AbortPath:
		this->_AbortPath.Pack(buffer);
		break;
	case Type::AbortAll:
		this->_AbortAll.Pack(buffer);
		break;
	case Type::DrawPoseMarker:
		this->_DrawPoseMarker.Pack(buffer);
		break;
	case Type::ErasePoseMarker:
		this->_ErasePoseMarker.Pack(buffer);
		break;
	case Type::SetHeadControllerGains:
		this->_SetHeadControllerGains.Pack(buffer);
		break;
	case Type::SetLiftControllerGains:
		this->_SetLiftControllerGains.Pack(buffer);
		break;
	case Type::SelectNextSoundScheme:
		this->_SelectNextSoundScheme.Pack(buffer);
		break;
	case Type::StartTestMode:
		this->_StartTestMode.Pack(buffer);
		break;
	case Type::IMURequest:
		this->_IMURequest.Pack(buffer);
		break;
	case Type::PlayAnimation:
		this->_PlayAnimation.Pack(buffer);
		break;
	case Type::ReadAnimationFile:
		this->_ReadAnimationFile.Pack(buffer);
		break;
	case Type::StartFaceTracking:
		this->_StartFaceTracking.Pack(buffer);
		break;
	case Type::StopFaceTracking:
		this->_StopFaceTracking.Pack(buffer);
		break;
	case Type::StartLookingForMarkers:
		this->_StartLookingForMarkers.Pack(buffer);
		break;
	case Type::StopLookingForMarkers:
		this->_StopLookingForMarkers.Pack(buffer);
		break;
	case Type::SetVisionSystemParams:
		this->_SetVisionSystemParams.Pack(buffer);
		break;
	case Type::SetFaceDetectParams:
		this->_SetFaceDetectParams.Pack(buffer);
		break;
	default:
		break;
	}
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t U2G_Message::Size() const
{
	size_t result {1}; // tag = uint_8
	switch(GetType()) {
	case Type::Ping:
		result += _Ping.Size();
		break;
	case Type::ConnectToRobot:
		result += _ConnectToRobot.Size();
		break;
	case Type::ConnectToUiDevice:
		result += _ConnectToUiDevice.Size();
		break;
	case Type::DisconnectFromUiDevice:
		result += _DisconnectFromUiDevice.Size();
		break;
	case Type::ForceAddRobot:
		result += _ForceAddRobot.Size();
		break;
	case Type::StartEngine:
		result += _StartEngine.Size();
		break;
	case Type::DriveWheels:
		result += _DriveWheels.Size();
		break;
	case Type::TurnInPlace:
		result += _TurnInPlace.Size();
		break;
	case Type::MoveHead:
		result += _MoveHead.Size();
		break;
	case Type::MoveLift:
		result += _MoveLift.Size();
		break;
	case Type::SetLiftHeight:
		result += _SetLiftHeight.Size();
		break;
	case Type::SetHeadAngle:
		result += _SetHeadAngle.Size();
		break;
	case Type::TrackHeadToObject:
		result += _TrackHeadToObject.Size();
		break;
	case Type::StopAllMotors:
		result += _StopAllMotors.Size();
		break;
	case Type::ImageRequest:
		result += _ImageRequest.Size();
		break;
	case Type::SetRobotImageSendMode:
		result += _SetRobotImageSendMode.Size();
		break;
	case Type::SaveImages:
		result += _SaveImages.Size();
		break;
	case Type::SaveRobotState:
		result += _SaveRobotState.Size();
		break;
	case Type::EnableDisplay:
		result += _EnableDisplay.Size();
		break;
	case Type::SetHeadlights:
		result += _SetHeadlights.Size();
		break;
	case Type::GotoPose:
		result += _GotoPose.Size();
		break;
	case Type::PlaceObjectOnGround:
		result += _PlaceObjectOnGround.Size();
		break;
	case Type::PlaceObjectOnGroundHere:
		result += _PlaceObjectOnGroundHere.Size();
		break;
	case Type::ExecuteTestPlan:
		result += _ExecuteTestPlan.Size();
		break;
	case Type::SelectNextObject:
		result += _SelectNextObject.Size();
		break;
	case Type::PickAndPlaceObject:
		result += _PickAndPlaceObject.Size();
		break;
	case Type::TraverseObject:
		result += _TraverseObject.Size();
		break;
	case Type::SetRobotCarryingObject:
		result += _SetRobotCarryingObject.Size();
		break;
	case Type::ClearAllBlocks:
		result += _ClearAllBlocks.Size();
		break;
	case Type::VisionWhileMoving:
		result += _VisionWhileMoving.Size();
		break;
	case Type::ExecuteBehavior:
		result += _ExecuteBehavior.Size();
		break;
	case Type::SetBehaviorState:
		result += _SetBehaviorState.Size();
		break;
	case Type::AbortPath:
		result += _AbortPath.Size();
		break;
	case Type::AbortAll:
		result += _AbortAll.Size();
		break;
	case Type::DrawPoseMarker:
		result += _DrawPoseMarker.Size();
		break;
	case Type::ErasePoseMarker:
		result += _ErasePoseMarker.Size();
		break;
	case Type::SetHeadControllerGains:
		result += _SetHeadControllerGains.Size();
		break;
	case Type::SetLiftControllerGains:
		result += _SetLiftControllerGains.Size();
		break;
	case Type::SelectNextSoundScheme:
		result += _SelectNextSoundScheme.Size();
		break;
	case Type::StartTestMode:
		result += _StartTestMode.Size();
		break;
	case Type::IMURequest:
		result += _IMURequest.Size();
		break;
	case Type::PlayAnimation:
		result += _PlayAnimation.Size();
		break;
	case Type::ReadAnimationFile:
		result += _ReadAnimationFile.Size();
		break;
	case Type::StartFaceTracking:
		result += _StartFaceTracking.Size();
		break;
	case Type::StopFaceTracking:
		result += _StopFaceTracking.Size();
		break;
	case Type::StartLookingForMarkers:
		result += _StartLookingForMarkers.Size();
		break;
	case Type::StopLookingForMarkers:
		result += _StopLookingForMarkers.Size();
		break;
	case Type::SetVisionSystemParams:
		result += _SetVisionSystemParams.Size();
		break;
	case Type::SetFaceDetectParams:
		result += _SetFaceDetectParams.Size();
		break;
	default:
		return 0;
	}
	return result;
}


void U2G_Message::ClearCurrent()
{
	switch(GetType()) {
	case Type::Ping:
		_Ping.~U2G_Ping();
		break;
	case Type::ConnectToRobot:
		_ConnectToRobot.~U2G_ConnectToRobot();
		break;
	case Type::ConnectToUiDevice:
		_ConnectToUiDevice.~U2G_ConnectToUiDevice();
		break;
	case Type::DisconnectFromUiDevice:
		_DisconnectFromUiDevice.~U2G_DisconnectFromUiDevice();
		break;
	case Type::ForceAddRobot:
		_ForceAddRobot.~U2G_ForceAddRobot();
		break;
	case Type::StartEngine:
		_StartEngine.~U2G_StartEngine();
		break;
	case Type::DriveWheels:
		_DriveWheels.~U2G_DriveWheels();
		break;
	case Type::TurnInPlace:
		_TurnInPlace.~U2G_TurnInPlace();
		break;
	case Type::MoveHead:
		_MoveHead.~U2G_MoveHead();
		break;
	case Type::MoveLift:
		_MoveLift.~U2G_MoveLift();
		break;
	case Type::SetLiftHeight:
		_SetLiftHeight.~U2G_SetLiftHeight();
		break;
	case Type::SetHeadAngle:
		_SetHeadAngle.~U2G_SetHeadAngle();
		break;
	case Type::TrackHeadToObject:
		_TrackHeadToObject.~U2G_TrackHeadToObject();
		break;
	case Type::StopAllMotors:
		_StopAllMotors.~U2G_StopAllMotors();
		break;
	case Type::ImageRequest:
		_ImageRequest.~U2G_ImageRequest();
		break;
	case Type::SetRobotImageSendMode:
		_SetRobotImageSendMode.~U2G_SetRobotImageSendMode();
		break;
	case Type::SaveImages:
		_SaveImages.~U2G_SaveImages();
		break;
	case Type::SaveRobotState:
		_SaveRobotState.~U2G_SaveRobotState();
		break;
	case Type::EnableDisplay:
		_EnableDisplay.~U2G_EnableDisplay();
		break;
	case Type::SetHeadlights:
		_SetHeadlights.~U2G_SetHeadlights();
		break;
	case Type::GotoPose:
		_GotoPose.~U2G_GotoPose();
		break;
	case Type::PlaceObjectOnGround:
		_PlaceObjectOnGround.~U2G_PlaceObjectOnGround();
		break;
	case Type::PlaceObjectOnGroundHere:
		_PlaceObjectOnGroundHere.~U2G_PlaceObjectOnGroundHere();
		break;
	case Type::ExecuteTestPlan:
		_ExecuteTestPlan.~U2G_ExecuteTestPlan();
		break;
	case Type::SelectNextObject:
		_SelectNextObject.~U2G_SelectNextObject();
		break;
	case Type::PickAndPlaceObject:
		_PickAndPlaceObject.~U2G_PickAndPlaceObject();
		break;
	case Type::TraverseObject:
		_TraverseObject.~U2G_TraverseObject();
		break;
	case Type::SetRobotCarryingObject:
		_SetRobotCarryingObject.~U2G_SetRobotCarryingObject();
		break;
	case Type::ClearAllBlocks:
		_ClearAllBlocks.~U2G_ClearAllBlocks();
		break;
	case Type::VisionWhileMoving:
		_VisionWhileMoving.~U2G_VisionWhileMoving();
		break;
	case Type::ExecuteBehavior:
		_ExecuteBehavior.~U2G_ExecuteBehavior();
		break;
	case Type::SetBehaviorState:
		_SetBehaviorState.~U2G_SetBehaviorState();
		break;
	case Type::AbortPath:
		_AbortPath.~U2G_AbortPath();
		break;
	case Type::AbortAll:
		_AbortAll.~U2G_AbortAll();
		break;
	case Type::DrawPoseMarker:
		_DrawPoseMarker.~U2G_DrawPoseMarker();
		break;
	case Type::ErasePoseMarker:
		_ErasePoseMarker.~U2G_ErasePoseMarker();
		break;
	case Type::SetHeadControllerGains:
		_SetHeadControllerGains.~U2G_SetHeadControllerGains();
		break;
	case Type::SetLiftControllerGains:
		_SetLiftControllerGains.~U2G_SetLiftControllerGains();
		break;
	case Type::SelectNextSoundScheme:
		_SelectNextSoundScheme.~U2G_SelectNextSoundScheme();
		break;
	case Type::StartTestMode:
		_StartTestMode.~U2G_StartTestMode();
		break;
	case Type::IMURequest:
		_IMURequest.~U2G_IMURequest();
		break;
	case Type::PlayAnimation:
		_PlayAnimation.~U2G_PlayAnimation();
		break;
	case Type::ReadAnimationFile:
		_ReadAnimationFile.~U2G_ReadAnimationFile();
		break;
	case Type::StartFaceTracking:
		_StartFaceTracking.~U2G_StartFaceTracking();
		break;
	case Type::StopFaceTracking:
		_StopFaceTracking.~U2G_StopFaceTracking();
		break;
	case Type::StartLookingForMarkers:
		_StartLookingForMarkers.~U2G_StartLookingForMarkers();
		break;
	case Type::StopLookingForMarkers:
		_StopLookingForMarkers.~U2G_StopLookingForMarkers();
		break;
	case Type::SetVisionSystemParams:
		_SetVisionSystemParams.~U2G_SetVisionSystemParams();
		break;
	case Type::SetFaceDetectParams:
		_SetFaceDetectParams.~U2G_SetFaceDetectParams();
		break;
	default:
		break;
	}
	_type = Type::INVALID;
}
} // namespace Anki
} // namespace Cozmo
