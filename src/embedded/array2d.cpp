/*









This file was automatically generated by the python script generateArray_cpp.py. Rather than editing this file, edit that script, then run "python generateArray_cpp.py".









*/

#include "anki/embeddedCommon.h"

namespace Anki
{
  namespace Embedded
  {
    s32 Array_u8::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0);
      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? (HEADER_LENGTH+FOOTER_LENGTH) : 0);
      return static_cast<s32>(RoundUp<size_t>(sizeof(u8)*numCols, MEMORY_ALIGNMENT)) + extraBoundaryPatternBytes;
    } // s32 Array_u8::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)

    s32 Array_u8::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0);
      return numRows * Array_u8::ComputeRequiredStride(numCols, useBoundaryFillPatterns);
    } // s32 Array_u8::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)

    Array_u8::Array_u8()
    {
      InvalidateArray();
    } // Array_u8::Array_u8()

    // Constructor for a Array_u8, pointing to user-allocated data. If the pointer to *data is not
    // aligned to MEMORY_ALIGNMENT, this Array_u8 will start at the next aligned location.
    // Unfortunately, this is more restrictive than most matrix libraries, and as an example,
    // it may make it hard to convert from OpenCV to Array_u8, though the reverse is trivial.
    Array_u8::Array_u8(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      Initialize(numRows,
        numCols,
        data,
        dataLength,
        useBoundaryFillPatterns);
    } // Array_u8::Array_u8(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)

    Array_u8::Array_u8(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0);

      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? static_cast<s32>(MEMORY_ALIGNMENT) : 0);
      const s32 numBytesRequested = numRows * this->stride + extraBoundaryPatternBytes;
      s32 numBytesAllocated = 0;

      void * allocatedBuffer = memory.Allocate(numBytesRequested, &numBytesAllocated);

      Initialize(numRows,
        numCols,
        reinterpret_cast<u8*>(allocatedBuffer),
        numBytesAllocated,
        useBoundaryFillPatterns);
    } // Array_u8::Array_u8(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)

    // Check every element of this array against the input array. If the arrays are different
    // sizes, uninitialized, or if any element is more different than the threshold, then return
    // false.
    bool Array_u8::IsElementwiseEqual(const Array_u8 &array2, const u8 threshold) const
    {
      if(!this->IsEqualSize(array2))
        return false;

      for(s32 y=0; y<size[0]; y++) {
        const u8 * const this_rowPointer = this->Pointer(y, 0);
        const u8 * const array2_rowPointer = array2.Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          if(this_rowPointer[x] > array2_rowPointer[x]) {
            if((this_rowPointer[x] - array2_rowPointer[x]) > threshold)
              return false;
          } else {
            if((array2_rowPointer[x] - this_rowPointer[x]) > threshold)
              return false;
          }
        }
      }

      return true;
    } // bool Array_u8::IsElementwiseEqual(const Array_u8 &array2, const u8 threshold) const

    // Check every element of this array against the input array. If the arrays are different
    // sizes or uninitialized, return false. The threshold is between 0.0 and 1.0. If any element
    // is more than a percentage different than its matching element (calulated from the maximum
    // of the two), return false.
    bool Array_u8::IsElementwiseEqual_PercentThreshold(const Array_u8 &array2, const double percentThreshold, const double absoluteThreshold) const
    {
      if(!this->IsEqualSize(array2))
        return false;

      for(s32 y=0; y<size[0]; y++) {
        const u8 * const this_rowPointer = this->Pointer(y, 0);
        const u8 * const array2_rowPointer = array2.Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          const double value1 = static_cast<double>(this_rowPointer[x]);
          const double value2 = static_cast<double>(array2_rowPointer[x]);
          const double percentThresholdValue = percentThreshold * MAX(value1,value2);

          if(abs(value1 - value2) > percentThresholdValue && abs(value1 - value2) > absoluteThreshold)
            return false;
        }
      }

      return true;
    } // bool Array_u8::IsElementwiseEqual_PercentThreshold(const Array_u8 &array2, const double percentThreshold, const double absoluteThreshold) const

    // If this array or array2 are different sizes or uninitialized, then return false.
    bool Array_u8::IsEqualSize(const Array_u8 &array2) const
    {
      if(!this->IsValid())
        return false;

      if(!array2.IsValid())
        return false;

      if(this->get_size(0) != array2.get_size(0) || this->get_size(1) != array2.get_size(1))
        return false;

      return true;
    } // bool Array_u8::IsEqualSize(const Array_u8 &array2) const

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    void Array_u8::Show(const char * const windowName, const bool waitForKeypress) const
    {
      assert(this->IsValid());
      cv::imshow(windowName, cvMatMirror);
      if(waitForKeypress) {
        cv::waitKey();
      }
    } // void Array_u8::Show(const char * const windowName, const bool waitForKeypress) const
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    // Returns a templated cv::Mat_ that shares the same buffer with this Array_u8. No data is copied.
    cv::Mat_<u8>& Array_u8::get_CvMat_()
    {
      assert(this->IsValid());
      return cvMatMirror;
    } // cv::Mat_<u8>& Array_u8::get_CvMat_()
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

    // Print out the contents of this Array_u8
    void Array_u8::Print(const char * const variableName) const
    {
      assert(this->IsValid());

      printf("%s:\n", variableName);
      for(s32 y=0; y<size[0]; y++) {
        const u8 * const rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          printf("%d ", rowPointer[x]);
        }
        printf("\n");
      }
      printf("\n");
    } // void Array_u8::Print() const

    // If the Array_u8 was constructed with the useBoundaryFillPatterns=true, then
    // return if any memory was written out of bounds (via fill patterns at the
    // beginning and end).  If the Array_u8 was not constructed with the
    // useBoundaryFillPatterns=true, this method always returns true
    bool Array_u8::IsValid() const
    {
      if(this->rawDataPointer == NULL || this->data == NULL) {
        return false;
      }

      if(size[0] < 1 || size[1] < 1) {
        return false;
      }

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1],false);

        for(s32 y=0; y<size[0]; y++) {
          if((reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0]) != FILL_PATTERN_END ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1]) != FILL_PATTERN_END) {
              return false;
          }
        }

        return true;
      } else { // if(useBoundaryFillPatterns) {
        return true;
      } // if(useBoundaryFillPatterns) { ... else
    } // bool Array_u8::IsValid() const

    // Set every element in the Array_u8 to this value
    // Returns the number of values set
    s32 Array_u8::Set(const u8 value)
    {
      assert(this->IsValid());

      for(s32 y=0; y<size[0]; y++) {
        u8 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          rowPointer[x] = value;
        }
      }

      return size[0]*size[1];
    } // s32 Array_u8::Set(const u8 value)

    // Parse a space-seperated string, and copy values to this Array_u8.
    // If the string does not contain enough elements, the remainder of the Array_u8 will be filled with zeros.
    // Returns the number of values set (not counting extra zeros)
    s32 Array_u8::Set(const char * const values)
    {
      assert(this->IsValid());

      s32 numValuesSet = 0;

      const char * startPointer = values;
      char * endPointer = NULL;

      for(s32 y=0; y<size[0]; y++) {
        u8 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          const u8 value = static_cast<u8>(strtol(startPointer, &endPointer, 10));
          if(startPointer != endPointer) {
            rowPointer[x] = value;
            numValuesSet++;
          } else {
            rowPointer[x] = 0;
          }
          startPointer = endPointer;
        }
      }

      return numValuesSet;
    } // s32 Array_u8::Set(const char * const values)

    // Similar to Matlab size(matrix, dimension), and dimension is in {0,1}
    s32 Array_u8::get_size(s32 dimension) const
    {
      assert(dimension >= 0 && this->rawDataPointer != NULL && this->data != NULL);

      if(dimension > 1 || dimension < 0)
        return 0;

      return size[dimension];
    } // s32 Array_u8::get_size(s32 dimension) const

    s32 Array_u8::get_stride() const
    {
      return stride;
    } // s32 Array_u8::get_stride() const

    void* Array_u8::get_rawDataPointer()
    {
      return rawDataPointer;
    } // void* Array_u8::get_rawDataPointer()

    const void* Array_u8::get_rawDataPointer() const
    {
      return rawDataPointer;
    } // const void* Array_u8::get_rawDataPointer() const

    void Array_u8::Initialize(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      this->useBoundaryFillPatterns = useBoundaryFillPatterns;

      if(!rawData) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "input data buffer is NULL");
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->rawDataPointer = rawData;

      const size_t extraBoundaryPatternBytes = useBoundaryFillPatterns ? static_cast<size_t>(HEADER_LENGTH) : 0;
      const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData)+extraBoundaryPatternBytes, MEMORY_ALIGNMENT) - extraBoundaryPatternBytes - reinterpret_cast<size_t>(rawData));
      const s32 requiredBytes = ComputeRequiredStride(numCols,useBoundaryFillPatterns)*numRows + extraAlignmentBytes;

      if(requiredBytes > dataLength) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->size[0] = numRows;
      this->size[1] = numCols;

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1], false);
        this->data = reinterpret_cast<u8*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes + HEADER_LENGTH );
        for(s32 y=0; y<size[0]; y++) {
          // Add the fill patterns just before the data on each line
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0] = FILL_PATTERN_START;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1] = FILL_PATTERN_START;

          // And also just after the data (including normal byte-alignment padding)
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0] = FILL_PATTERN_END;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1] = FILL_PATTERN_END;
        }
      } else {
        this->data = reinterpret_cast<u8*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
      }

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
      cvMatMirror = cv::Mat_<u8>(size[0], size[1], data, stride);
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    } // Array_u8::Initialize()

    // Set all the buffers and sizes to zero, to signal an invalid array
    void Array_u8::InvalidateArray()
    {
      this->size[0] = 0;
      this->size[1] = 0;
      this->stride = 0;
      this->data = NULL;
      this->rawDataPointer = NULL;
    } // void Array_u8::InvalidateArray()

    // Factory method to create an Array_u8 from the heap. The data of the returned Array_u8 must be freed by the user.
    // This is separate from the normal constructor, as Array_u8 objects are not supposed to manage memory
    Array_u8 AllocateArrayFromHeap_u8(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      const s32 requiredMemory = 64 + 2*MEMORY_ALIGNMENT + Array_u8::ComputeMinimumRequiredMemory(numRows, numCols, useBoundaryFillPatterns); // The required memory, plus a bit more

      Array_u8 mat(numRows, numCols, calloc(requiredMemory, 1), requiredMemory, useBoundaryFillPatterns);

      return mat;
    } // Array_u8 AllocateArrayFromHeap_u8(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)


    s32 Array_s8::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0);
      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? (HEADER_LENGTH+FOOTER_LENGTH) : 0);
      return static_cast<s32>(RoundUp<size_t>(sizeof(s8)*numCols, MEMORY_ALIGNMENT)) + extraBoundaryPatternBytes;
    } // s32 Array_s8::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)

    s32 Array_s8::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0);
      return numRows * Array_s8::ComputeRequiredStride(numCols, useBoundaryFillPatterns);
    } // s32 Array_s8::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)

    Array_s8::Array_s8()
    {
      InvalidateArray();
    } // Array_s8::Array_s8()

    // Constructor for a Array_s8, pointing to user-allocated data. If the pointer to *data is not
    // aligned to MEMORY_ALIGNMENT, this Array_s8 will start at the next aligned location.
    // Unfortunately, this is more restrictive than most matrix libraries, and as an example,
    // it may make it hard to convert from OpenCV to Array_s8, though the reverse is trivial.
    Array_s8::Array_s8(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      Initialize(numRows,
        numCols,
        data,
        dataLength,
        useBoundaryFillPatterns);
    } // Array_s8::Array_s8(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)

    Array_s8::Array_s8(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0);

      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? static_cast<s32>(MEMORY_ALIGNMENT) : 0);
      const s32 numBytesRequested = numRows * this->stride + extraBoundaryPatternBytes;
      s32 numBytesAllocated = 0;

      void * allocatedBuffer = memory.Allocate(numBytesRequested, &numBytesAllocated);

      Initialize(numRows,
        numCols,
        reinterpret_cast<s8*>(allocatedBuffer),
        numBytesAllocated,
        useBoundaryFillPatterns);
    } // Array_s8::Array_s8(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)

    // Check every element of this array against the input array. If the arrays are different
    // sizes, uninitialized, or if any element is more different than the threshold, then return
    // false.
    bool Array_s8::IsElementwiseEqual(const Array_s8 &array2, const s8 threshold) const
    {
      if(!this->IsEqualSize(array2))
        return false;

      for(s32 y=0; y<size[0]; y++) {
        const s8 * const this_rowPointer = this->Pointer(y, 0);
        const s8 * const array2_rowPointer = array2.Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          if(this_rowPointer[x] > array2_rowPointer[x]) {
            if((this_rowPointer[x] - array2_rowPointer[x]) > threshold)
              return false;
          } else {
            if((array2_rowPointer[x] - this_rowPointer[x]) > threshold)
              return false;
          }
        }
      }

      return true;
    } // bool Array_s8::IsElementwiseEqual(const Array_s8 &array2, const s8 threshold) const

    // Check every element of this array against the input array. If the arrays are different
    // sizes or uninitialized, return false. The threshold is between 0.0 and 1.0. If any element
    // is more than a percentage different than its matching element (calulated from the maximum
    // of the two), return false.
    bool Array_s8::IsElementwiseEqual_PercentThreshold(const Array_s8 &array2, const double percentThreshold, const double absoluteThreshold) const
    {
      if(!this->IsEqualSize(array2))
        return false;

      for(s32 y=0; y<size[0]; y++) {
        const s8 * const this_rowPointer = this->Pointer(y, 0);
        const s8 * const array2_rowPointer = array2.Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          const double value1 = static_cast<double>(this_rowPointer[x]);
          const double value2 = static_cast<double>(array2_rowPointer[x]);
          const double percentThresholdValue = percentThreshold * MAX(value1,value2);

          if(abs(value1 - value2) > percentThresholdValue && abs(value1 - value2) > absoluteThreshold)
            return false;
        }
      }

      return true;
    } // bool Array_s8::IsElementwiseEqual_PercentThreshold(const Array_s8 &array2, const double percentThreshold, const double absoluteThreshold) const

    // If this array or array2 are different sizes or uninitialized, then return false.
    bool Array_s8::IsEqualSize(const Array_s8 &array2) const
    {
      if(!this->IsValid())
        return false;

      if(!array2.IsValid())
        return false;

      if(this->get_size(0) != array2.get_size(0) || this->get_size(1) != array2.get_size(1))
        return false;

      return true;
    } // bool Array_s8::IsEqualSize(const Array_s8 &array2) const

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    void Array_s8::Show(const char * const windowName, const bool waitForKeypress) const
    {
      assert(this->IsValid());
      cv::imshow(windowName, cvMatMirror);
      if(waitForKeypress) {
        cv::waitKey();
      }
    } // void Array_s8::Show(const char * const windowName, const bool waitForKeypress) const
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    // Returns a templated cv::Mat_ that shares the same buffer with this Array_s8. No data is copied.
    cv::Mat_<s8>& Array_s8::get_CvMat_()
    {
      assert(this->IsValid());
      return cvMatMirror;
    } // cv::Mat_<s8>& Array_s8::get_CvMat_()
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

    // Print out the contents of this Array_s8
    void Array_s8::Print(const char * const variableName) const
    {
      assert(this->IsValid());

      printf("%s:\n", variableName);
      for(s32 y=0; y<size[0]; y++) {
        const s8 * const rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          printf("%d ", rowPointer[x]);
        }
        printf("\n");
      }
      printf("\n");
    } // void Array_s8::Print() const

    // If the Array_s8 was constructed with the useBoundaryFillPatterns=true, then
    // return if any memory was written out of bounds (via fill patterns at the
    // beginning and end).  If the Array_s8 was not constructed with the
    // useBoundaryFillPatterns=true, this method always returns true
    bool Array_s8::IsValid() const
    {
      if(this->rawDataPointer == NULL || this->data == NULL) {
        return false;
      }

      if(size[0] < 1 || size[1] < 1) {
        return false;
      }

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1],false);

        for(s32 y=0; y<size[0]; y++) {
          if((reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0]) != FILL_PATTERN_END ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1]) != FILL_PATTERN_END) {
              return false;
          }
        }

        return true;
      } else { // if(useBoundaryFillPatterns) {
        return true;
      } // if(useBoundaryFillPatterns) { ... else
    } // bool Array_s8::IsValid() const

    // Set every element in the Array_s8 to this value
    // Returns the number of values set
    s32 Array_s8::Set(const s8 value)
    {
      assert(this->IsValid());

      for(s32 y=0; y<size[0]; y++) {
        s8 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          rowPointer[x] = value;
        }
      }

      return size[0]*size[1];
    } // s32 Array_s8::Set(const s8 value)

    // Parse a space-seperated string, and copy values to this Array_s8.
    // If the string does not contain enough elements, the remainder of the Array_s8 will be filled with zeros.
    // Returns the number of values set (not counting extra zeros)
    s32 Array_s8::Set(const char * const values)
    {
      assert(this->IsValid());

      s32 numValuesSet = 0;

      const char * startPointer = values;
      char * endPointer = NULL;

      for(s32 y=0; y<size[0]; y++) {
        s8 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          const s8 value = static_cast<s8>(strtol(startPointer, &endPointer, 10));
          if(startPointer != endPointer) {
            rowPointer[x] = value;
            numValuesSet++;
          } else {
            rowPointer[x] = 0;
          }
          startPointer = endPointer;
        }
      }

      return numValuesSet;
    } // s32 Array_s8::Set(const char * const values)

    // Similar to Matlab size(matrix, dimension), and dimension is in {0,1}
    s32 Array_s8::get_size(s32 dimension) const
    {
      assert(dimension >= 0 && this->rawDataPointer != NULL && this->data != NULL);

      if(dimension > 1 || dimension < 0)
        return 0;

      return size[dimension];
    } // s32 Array_s8::get_size(s32 dimension) const

    s32 Array_s8::get_stride() const
    {
      return stride;
    } // s32 Array_s8::get_stride() const

    void* Array_s8::get_rawDataPointer()
    {
      return rawDataPointer;
    } // void* Array_s8::get_rawDataPointer()

    const void* Array_s8::get_rawDataPointer() const
    {
      return rawDataPointer;
    } // const void* Array_s8::get_rawDataPointer() const

    void Array_s8::Initialize(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      this->useBoundaryFillPatterns = useBoundaryFillPatterns;

      if(!rawData) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "input data buffer is NULL");
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->rawDataPointer = rawData;

      const size_t extraBoundaryPatternBytes = useBoundaryFillPatterns ? static_cast<size_t>(HEADER_LENGTH) : 0;
      const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData)+extraBoundaryPatternBytes, MEMORY_ALIGNMENT) - extraBoundaryPatternBytes - reinterpret_cast<size_t>(rawData));
      const s32 requiredBytes = ComputeRequiredStride(numCols,useBoundaryFillPatterns)*numRows + extraAlignmentBytes;

      if(requiredBytes > dataLength) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->size[0] = numRows;
      this->size[1] = numCols;

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1], false);
        this->data = reinterpret_cast<s8*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes + HEADER_LENGTH );
        for(s32 y=0; y<size[0]; y++) {
          // Add the fill patterns just before the data on each line
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0] = FILL_PATTERN_START;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1] = FILL_PATTERN_START;

          // And also just after the data (including normal byte-alignment padding)
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0] = FILL_PATTERN_END;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1] = FILL_PATTERN_END;
        }
      } else {
        this->data = reinterpret_cast<s8*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
      }

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
      cvMatMirror = cv::Mat_<s8>(size[0], size[1], data, stride);
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    } // Array_s8::Initialize()

    // Set all the buffers and sizes to zero, to signal an invalid array
    void Array_s8::InvalidateArray()
    {
      this->size[0] = 0;
      this->size[1] = 0;
      this->stride = 0;
      this->data = NULL;
      this->rawDataPointer = NULL;
    } // void Array_s8::InvalidateArray()

    // Factory method to create an Array_s8 from the heap. The data of the returned Array_s8 must be freed by the user.
    // This is separate from the normal constructor, as Array_s8 objects are not supposed to manage memory
    Array_s8 AllocateArrayFromHeap_s8(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      const s32 requiredMemory = 64 + 2*MEMORY_ALIGNMENT + Array_s8::ComputeMinimumRequiredMemory(numRows, numCols, useBoundaryFillPatterns); // The required memory, plus a bit more

      Array_s8 mat(numRows, numCols, calloc(requiredMemory, 1), requiredMemory, useBoundaryFillPatterns);

      return mat;
    } // Array_s8 AllocateArrayFromHeap_s8(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)


    s32 Array_u16::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0);
      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? (HEADER_LENGTH+FOOTER_LENGTH) : 0);
      return static_cast<s32>(RoundUp<size_t>(sizeof(u16)*numCols, MEMORY_ALIGNMENT)) + extraBoundaryPatternBytes;
    } // s32 Array_u16::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)

    s32 Array_u16::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0);
      return numRows * Array_u16::ComputeRequiredStride(numCols, useBoundaryFillPatterns);
    } // s32 Array_u16::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)

    Array_u16::Array_u16()
    {
      InvalidateArray();
    } // Array_u16::Array_u16()

    // Constructor for a Array_u16, pointing to user-allocated data. If the pointer to *data is not
    // aligned to MEMORY_ALIGNMENT, this Array_u16 will start at the next aligned location.
    // Unfortunately, this is more restrictive than most matrix libraries, and as an example,
    // it may make it hard to convert from OpenCV to Array_u16, though the reverse is trivial.
    Array_u16::Array_u16(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      Initialize(numRows,
        numCols,
        data,
        dataLength,
        useBoundaryFillPatterns);
    } // Array_u16::Array_u16(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)

    Array_u16::Array_u16(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0);

      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? static_cast<s32>(MEMORY_ALIGNMENT) : 0);
      const s32 numBytesRequested = numRows * this->stride + extraBoundaryPatternBytes;
      s32 numBytesAllocated = 0;

      void * allocatedBuffer = memory.Allocate(numBytesRequested, &numBytesAllocated);

      Initialize(numRows,
        numCols,
        reinterpret_cast<u16*>(allocatedBuffer),
        numBytesAllocated,
        useBoundaryFillPatterns);
    } // Array_u16::Array_u16(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)

    // Check every element of this array against the input array. If the arrays are different
    // sizes, uninitialized, or if any element is more different than the threshold, then return
    // false.
    bool Array_u16::IsElementwiseEqual(const Array_u16 &array2, const u16 threshold) const
    {
      if(!this->IsEqualSize(array2))
        return false;

      for(s32 y=0; y<size[0]; y++) {
        const u16 * const this_rowPointer = this->Pointer(y, 0);
        const u16 * const array2_rowPointer = array2.Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          if(this_rowPointer[x] > array2_rowPointer[x]) {
            if((this_rowPointer[x] - array2_rowPointer[x]) > threshold)
              return false;
          } else {
            if((array2_rowPointer[x] - this_rowPointer[x]) > threshold)
              return false;
          }
        }
      }

      return true;
    } // bool Array_u16::IsElementwiseEqual(const Array_u16 &array2, const u16 threshold) const

    // Check every element of this array against the input array. If the arrays are different
    // sizes or uninitialized, return false. The threshold is between 0.0 and 1.0. If any element
    // is more than a percentage different than its matching element (calulated from the maximum
    // of the two), return false.
    bool Array_u16::IsElementwiseEqual_PercentThreshold(const Array_u16 &array2, const double percentThreshold, const double absoluteThreshold) const
    {
      if(!this->IsEqualSize(array2))
        return false;

      for(s32 y=0; y<size[0]; y++) {
        const u16 * const this_rowPointer = this->Pointer(y, 0);
        const u16 * const array2_rowPointer = array2.Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          const double value1 = static_cast<double>(this_rowPointer[x]);
          const double value2 = static_cast<double>(array2_rowPointer[x]);
          const double percentThresholdValue = percentThreshold * MAX(value1,value2);

          if(abs(value1 - value2) > percentThresholdValue && abs(value1 - value2) > absoluteThreshold)
            return false;
        }
      }

      return true;
    } // bool Array_u16::IsElementwiseEqual_PercentThreshold(const Array_u16 &array2, const double percentThreshold, const double absoluteThreshold) const

    // If this array or array2 are different sizes or uninitialized, then return false.
    bool Array_u16::IsEqualSize(const Array_u16 &array2) const
    {
      if(!this->IsValid())
        return false;

      if(!array2.IsValid())
        return false;

      if(this->get_size(0) != array2.get_size(0) || this->get_size(1) != array2.get_size(1))
        return false;

      return true;
    } // bool Array_u16::IsEqualSize(const Array_u16 &array2) const

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    void Array_u16::Show(const char * const windowName, const bool waitForKeypress) const
    {
      assert(this->IsValid());
      cv::imshow(windowName, cvMatMirror);
      if(waitForKeypress) {
        cv::waitKey();
      }
    } // void Array_u16::Show(const char * const windowName, const bool waitForKeypress) const
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    // Returns a templated cv::Mat_ that shares the same buffer with this Array_u16. No data is copied.
    cv::Mat_<u16>& Array_u16::get_CvMat_()
    {
      assert(this->IsValid());
      return cvMatMirror;
    } // cv::Mat_<u16>& Array_u16::get_CvMat_()
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

    // Print out the contents of this Array_u16
    void Array_u16::Print(const char * const variableName) const
    {
      assert(this->IsValid());

      printf("%s:\n", variableName);
      for(s32 y=0; y<size[0]; y++) {
        const u16 * const rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          printf("%d ", rowPointer[x]);
        }
        printf("\n");
      }
      printf("\n");
    } // void Array_u16::Print() const

    // If the Array_u16 was constructed with the useBoundaryFillPatterns=true, then
    // return if any memory was written out of bounds (via fill patterns at the
    // beginning and end).  If the Array_u16 was not constructed with the
    // useBoundaryFillPatterns=true, this method always returns true
    bool Array_u16::IsValid() const
    {
      if(this->rawDataPointer == NULL || this->data == NULL) {
        return false;
      }

      if(size[0] < 1 || size[1] < 1) {
        return false;
      }

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1],false);

        for(s32 y=0; y<size[0]; y++) {
          if((reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0]) != FILL_PATTERN_END ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1]) != FILL_PATTERN_END) {
              return false;
          }
        }

        return true;
      } else { // if(useBoundaryFillPatterns) {
        return true;
      } // if(useBoundaryFillPatterns) { ... else
    } // bool Array_u16::IsValid() const

    // Set every element in the Array_u16 to this value
    // Returns the number of values set
    s32 Array_u16::Set(const u16 value)
    {
      assert(this->IsValid());

      for(s32 y=0; y<size[0]; y++) {
        u16 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          rowPointer[x] = value;
        }
      }

      return size[0]*size[1];
    } // s32 Array_u16::Set(const u16 value)

    // Parse a space-seperated string, and copy values to this Array_u16.
    // If the string does not contain enough elements, the remainder of the Array_u16 will be filled with zeros.
    // Returns the number of values set (not counting extra zeros)
    s32 Array_u16::Set(const char * const values)
    {
      assert(this->IsValid());

      s32 numValuesSet = 0;

      const char * startPointer = values;
      char * endPointer = NULL;

      for(s32 y=0; y<size[0]; y++) {
        u16 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          const u16 value = static_cast<u16>(strtol(startPointer, &endPointer, 10));
          if(startPointer != endPointer) {
            rowPointer[x] = value;
            numValuesSet++;
          } else {
            rowPointer[x] = 0;
          }
          startPointer = endPointer;
        }
      }

      return numValuesSet;
    } // s32 Array_u16::Set(const char * const values)

    // Similar to Matlab size(matrix, dimension), and dimension is in {0,1}
    s32 Array_u16::get_size(s32 dimension) const
    {
      assert(dimension >= 0 && this->rawDataPointer != NULL && this->data != NULL);

      if(dimension > 1 || dimension < 0)
        return 0;

      return size[dimension];
    } // s32 Array_u16::get_size(s32 dimension) const

    s32 Array_u16::get_stride() const
    {
      return stride;
    } // s32 Array_u16::get_stride() const

    void* Array_u16::get_rawDataPointer()
    {
      return rawDataPointer;
    } // void* Array_u16::get_rawDataPointer()

    const void* Array_u16::get_rawDataPointer() const
    {
      return rawDataPointer;
    } // const void* Array_u16::get_rawDataPointer() const

    void Array_u16::Initialize(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      this->useBoundaryFillPatterns = useBoundaryFillPatterns;

      if(!rawData) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "input data buffer is NULL");
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->rawDataPointer = rawData;

      const size_t extraBoundaryPatternBytes = useBoundaryFillPatterns ? static_cast<size_t>(HEADER_LENGTH) : 0;
      const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData)+extraBoundaryPatternBytes, MEMORY_ALIGNMENT) - extraBoundaryPatternBytes - reinterpret_cast<size_t>(rawData));
      const s32 requiredBytes = ComputeRequiredStride(numCols,useBoundaryFillPatterns)*numRows + extraAlignmentBytes;

      if(requiredBytes > dataLength) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->size[0] = numRows;
      this->size[1] = numCols;

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1], false);
        this->data = reinterpret_cast<u16*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes + HEADER_LENGTH );
        for(s32 y=0; y<size[0]; y++) {
          // Add the fill patterns just before the data on each line
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0] = FILL_PATTERN_START;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1] = FILL_PATTERN_START;

          // And also just after the data (including normal byte-alignment padding)
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0] = FILL_PATTERN_END;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1] = FILL_PATTERN_END;
        }
      } else {
        this->data = reinterpret_cast<u16*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
      }

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
      cvMatMirror = cv::Mat_<u16>(size[0], size[1], data, stride);
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    } // Array_u16::Initialize()

    // Set all the buffers and sizes to zero, to signal an invalid array
    void Array_u16::InvalidateArray()
    {
      this->size[0] = 0;
      this->size[1] = 0;
      this->stride = 0;
      this->data = NULL;
      this->rawDataPointer = NULL;
    } // void Array_u16::InvalidateArray()

    // Factory method to create an Array_u16 from the heap. The data of the returned Array_u16 must be freed by the user.
    // This is separate from the normal constructor, as Array_u16 objects are not supposed to manage memory
    Array_u16 AllocateArrayFromHeap_u16(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      const s32 requiredMemory = 64 + 2*MEMORY_ALIGNMENT + Array_u16::ComputeMinimumRequiredMemory(numRows, numCols, useBoundaryFillPatterns); // The required memory, plus a bit more

      Array_u16 mat(numRows, numCols, calloc(requiredMemory, 1), requiredMemory, useBoundaryFillPatterns);

      return mat;
    } // Array_u16 AllocateArrayFromHeap_u16(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)


    s32 Array_s16::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0);
      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? (HEADER_LENGTH+FOOTER_LENGTH) : 0);
      return static_cast<s32>(RoundUp<size_t>(sizeof(s16)*numCols, MEMORY_ALIGNMENT)) + extraBoundaryPatternBytes;
    } // s32 Array_s16::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)

    s32 Array_s16::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0);
      return numRows * Array_s16::ComputeRequiredStride(numCols, useBoundaryFillPatterns);
    } // s32 Array_s16::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)

    Array_s16::Array_s16()
    {
      InvalidateArray();
    } // Array_s16::Array_s16()

    // Constructor for a Array_s16, pointing to user-allocated data. If the pointer to *data is not
    // aligned to MEMORY_ALIGNMENT, this Array_s16 will start at the next aligned location.
    // Unfortunately, this is more restrictive than most matrix libraries, and as an example,
    // it may make it hard to convert from OpenCV to Array_s16, though the reverse is trivial.
    Array_s16::Array_s16(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      Initialize(numRows,
        numCols,
        data,
        dataLength,
        useBoundaryFillPatterns);
    } // Array_s16::Array_s16(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)

    Array_s16::Array_s16(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0);

      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? static_cast<s32>(MEMORY_ALIGNMENT) : 0);
      const s32 numBytesRequested = numRows * this->stride + extraBoundaryPatternBytes;
      s32 numBytesAllocated = 0;

      void * allocatedBuffer = memory.Allocate(numBytesRequested, &numBytesAllocated);

      Initialize(numRows,
        numCols,
        reinterpret_cast<s16*>(allocatedBuffer),
        numBytesAllocated,
        useBoundaryFillPatterns);
    } // Array_s16::Array_s16(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)

    // Check every element of this array against the input array. If the arrays are different
    // sizes, uninitialized, or if any element is more different than the threshold, then return
    // false.
    bool Array_s16::IsElementwiseEqual(const Array_s16 &array2, const s16 threshold) const
    {
      if(!this->IsEqualSize(array2))
        return false;

      for(s32 y=0; y<size[0]; y++) {
        const s16 * const this_rowPointer = this->Pointer(y, 0);
        const s16 * const array2_rowPointer = array2.Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          if(this_rowPointer[x] > array2_rowPointer[x]) {
            if((this_rowPointer[x] - array2_rowPointer[x]) > threshold)
              return false;
          } else {
            if((array2_rowPointer[x] - this_rowPointer[x]) > threshold)
              return false;
          }
        }
      }

      return true;
    } // bool Array_s16::IsElementwiseEqual(const Array_s16 &array2, const s16 threshold) const

    // Check every element of this array against the input array. If the arrays are different
    // sizes or uninitialized, return false. The threshold is between 0.0 and 1.0. If any element
    // is more than a percentage different than its matching element (calulated from the maximum
    // of the two), return false.
    bool Array_s16::IsElementwiseEqual_PercentThreshold(const Array_s16 &array2, const double percentThreshold, const double absoluteThreshold) const
    {
      if(!this->IsEqualSize(array2))
        return false;

      for(s32 y=0; y<size[0]; y++) {
        const s16 * const this_rowPointer = this->Pointer(y, 0);
        const s16 * const array2_rowPointer = array2.Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          const double value1 = static_cast<double>(this_rowPointer[x]);
          const double value2 = static_cast<double>(array2_rowPointer[x]);
          const double percentThresholdValue = percentThreshold * MAX(value1,value2);

          if(abs(value1 - value2) > percentThresholdValue && abs(value1 - value2) > absoluteThreshold)
            return false;
        }
      }

      return true;
    } // bool Array_s16::IsElementwiseEqual_PercentThreshold(const Array_s16 &array2, const double percentThreshold, const double absoluteThreshold) const

    // If this array or array2 are different sizes or uninitialized, then return false.
    bool Array_s16::IsEqualSize(const Array_s16 &array2) const
    {
      if(!this->IsValid())
        return false;

      if(!array2.IsValid())
        return false;

      if(this->get_size(0) != array2.get_size(0) || this->get_size(1) != array2.get_size(1))
        return false;

      return true;
    } // bool Array_s16::IsEqualSize(const Array_s16 &array2) const

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    void Array_s16::Show(const char * const windowName, const bool waitForKeypress) const
    {
      assert(this->IsValid());
      cv::imshow(windowName, cvMatMirror);
      if(waitForKeypress) {
        cv::waitKey();
      }
    } // void Array_s16::Show(const char * const windowName, const bool waitForKeypress) const
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    // Returns a templated cv::Mat_ that shares the same buffer with this Array_s16. No data is copied.
    cv::Mat_<s16>& Array_s16::get_CvMat_()
    {
      assert(this->IsValid());
      return cvMatMirror;
    } // cv::Mat_<s16>& Array_s16::get_CvMat_()
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

    // Print out the contents of this Array_s16
    void Array_s16::Print(const char * const variableName) const
    {
      assert(this->IsValid());

      printf("%s:\n", variableName);
      for(s32 y=0; y<size[0]; y++) {
        const s16 * const rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          printf("%d ", rowPointer[x]);
        }
        printf("\n");
      }
      printf("\n");
    } // void Array_s16::Print() const

    // If the Array_s16 was constructed with the useBoundaryFillPatterns=true, then
    // return if any memory was written out of bounds (via fill patterns at the
    // beginning and end).  If the Array_s16 was not constructed with the
    // useBoundaryFillPatterns=true, this method always returns true
    bool Array_s16::IsValid() const
    {
      if(this->rawDataPointer == NULL || this->data == NULL) {
        return false;
      }

      if(size[0] < 1 || size[1] < 1) {
        return false;
      }

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1],false);

        for(s32 y=0; y<size[0]; y++) {
          if((reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0]) != FILL_PATTERN_END ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1]) != FILL_PATTERN_END) {
              return false;
          }
        }

        return true;
      } else { // if(useBoundaryFillPatterns) {
        return true;
      } // if(useBoundaryFillPatterns) { ... else
    } // bool Array_s16::IsValid() const

    // Set every element in the Array_s16 to this value
    // Returns the number of values set
    s32 Array_s16::Set(const s16 value)
    {
      assert(this->IsValid());

      for(s32 y=0; y<size[0]; y++) {
        s16 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          rowPointer[x] = value;
        }
      }

      return size[0]*size[1];
    } // s32 Array_s16::Set(const s16 value)

    // Parse a space-seperated string, and copy values to this Array_s16.
    // If the string does not contain enough elements, the remainder of the Array_s16 will be filled with zeros.
    // Returns the number of values set (not counting extra zeros)
    s32 Array_s16::Set(const char * const values)
    {
      assert(this->IsValid());

      s32 numValuesSet = 0;

      const char * startPointer = values;
      char * endPointer = NULL;

      for(s32 y=0; y<size[0]; y++) {
        s16 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          const s16 value = static_cast<s16>(strtol(startPointer, &endPointer, 10));
          if(startPointer != endPointer) {
            rowPointer[x] = value;
            numValuesSet++;
          } else {
            rowPointer[x] = 0;
          }
          startPointer = endPointer;
        }
      }

      return numValuesSet;
    } // s32 Array_s16::Set(const char * const values)

    // Similar to Matlab size(matrix, dimension), and dimension is in {0,1}
    s32 Array_s16::get_size(s32 dimension) const
    {
      assert(dimension >= 0 && this->rawDataPointer != NULL && this->data != NULL);

      if(dimension > 1 || dimension < 0)
        return 0;

      return size[dimension];
    } // s32 Array_s16::get_size(s32 dimension) const

    s32 Array_s16::get_stride() const
    {
      return stride;
    } // s32 Array_s16::get_stride() const

    void* Array_s16::get_rawDataPointer()
    {
      return rawDataPointer;
    } // void* Array_s16::get_rawDataPointer()

    const void* Array_s16::get_rawDataPointer() const
    {
      return rawDataPointer;
    } // const void* Array_s16::get_rawDataPointer() const

    void Array_s16::Initialize(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      this->useBoundaryFillPatterns = useBoundaryFillPatterns;

      if(!rawData) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "input data buffer is NULL");
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->rawDataPointer = rawData;

      const size_t extraBoundaryPatternBytes = useBoundaryFillPatterns ? static_cast<size_t>(HEADER_LENGTH) : 0;
      const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData)+extraBoundaryPatternBytes, MEMORY_ALIGNMENT) - extraBoundaryPatternBytes - reinterpret_cast<size_t>(rawData));
      const s32 requiredBytes = ComputeRequiredStride(numCols,useBoundaryFillPatterns)*numRows + extraAlignmentBytes;

      if(requiredBytes > dataLength) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->size[0] = numRows;
      this->size[1] = numCols;

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1], false);
        this->data = reinterpret_cast<s16*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes + HEADER_LENGTH );
        for(s32 y=0; y<size[0]; y++) {
          // Add the fill patterns just before the data on each line
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0] = FILL_PATTERN_START;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1] = FILL_PATTERN_START;

          // And also just after the data (including normal byte-alignment padding)
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0] = FILL_PATTERN_END;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1] = FILL_PATTERN_END;
        }
      } else {
        this->data = reinterpret_cast<s16*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
      }

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
      cvMatMirror = cv::Mat_<s16>(size[0], size[1], data, stride);
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    } // Array_s16::Initialize()

    // Set all the buffers and sizes to zero, to signal an invalid array
    void Array_s16::InvalidateArray()
    {
      this->size[0] = 0;
      this->size[1] = 0;
      this->stride = 0;
      this->data = NULL;
      this->rawDataPointer = NULL;
    } // void Array_s16::InvalidateArray()

    // Factory method to create an Array_s16 from the heap. The data of the returned Array_s16 must be freed by the user.
    // This is separate from the normal constructor, as Array_s16 objects are not supposed to manage memory
    Array_s16 AllocateArrayFromHeap_s16(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      const s32 requiredMemory = 64 + 2*MEMORY_ALIGNMENT + Array_s16::ComputeMinimumRequiredMemory(numRows, numCols, useBoundaryFillPatterns); // The required memory, plus a bit more

      Array_s16 mat(numRows, numCols, calloc(requiredMemory, 1), requiredMemory, useBoundaryFillPatterns);

      return mat;
    } // Array_s16 AllocateArrayFromHeap_s16(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)


    s32 Array_u32::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0);
      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? (HEADER_LENGTH+FOOTER_LENGTH) : 0);
      return static_cast<s32>(RoundUp<size_t>(sizeof(u32)*numCols, MEMORY_ALIGNMENT)) + extraBoundaryPatternBytes;
    } // s32 Array_u32::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)

    s32 Array_u32::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0);
      return numRows * Array_u32::ComputeRequiredStride(numCols, useBoundaryFillPatterns);
    } // s32 Array_u32::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)

    Array_u32::Array_u32()
    {
      InvalidateArray();
    } // Array_u32::Array_u32()

    // Constructor for a Array_u32, pointing to user-allocated data. If the pointer to *data is not
    // aligned to MEMORY_ALIGNMENT, this Array_u32 will start at the next aligned location.
    // Unfortunately, this is more restrictive than most matrix libraries, and as an example,
    // it may make it hard to convert from OpenCV to Array_u32, though the reverse is trivial.
    Array_u32::Array_u32(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      Initialize(numRows,
        numCols,
        data,
        dataLength,
        useBoundaryFillPatterns);
    } // Array_u32::Array_u32(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)

    Array_u32::Array_u32(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0);

      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? static_cast<s32>(MEMORY_ALIGNMENT) : 0);
      const s32 numBytesRequested = numRows * this->stride + extraBoundaryPatternBytes;
      s32 numBytesAllocated = 0;

      void * allocatedBuffer = memory.Allocate(numBytesRequested, &numBytesAllocated);

      Initialize(numRows,
        numCols,
        reinterpret_cast<u32*>(allocatedBuffer),
        numBytesAllocated,
        useBoundaryFillPatterns);
    } // Array_u32::Array_u32(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)

    // Check every element of this array against the input array. If the arrays are different
    // sizes, uninitialized, or if any element is more different than the threshold, then return
    // false.
    bool Array_u32::IsElementwiseEqual(const Array_u32 &array2, const u32 threshold) const
    {
      if(!this->IsEqualSize(array2))
        return false;

      for(s32 y=0; y<size[0]; y++) {
        const u32 * const this_rowPointer = this->Pointer(y, 0);
        const u32 * const array2_rowPointer = array2.Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          if(this_rowPointer[x] > array2_rowPointer[x]) {
            if((this_rowPointer[x] - array2_rowPointer[x]) > threshold)
              return false;
          } else {
            if((array2_rowPointer[x] - this_rowPointer[x]) > threshold)
              return false;
          }
        }
      }

      return true;
    } // bool Array_u32::IsElementwiseEqual(const Array_u32 &array2, const u32 threshold) const

    // Check every element of this array against the input array. If the arrays are different
    // sizes or uninitialized, return false. The threshold is between 0.0 and 1.0. If any element
    // is more than a percentage different than its matching element (calulated from the maximum
    // of the two), return false.
    bool Array_u32::IsElementwiseEqual_PercentThreshold(const Array_u32 &array2, const double percentThreshold, const double absoluteThreshold) const
    {
      if(!this->IsEqualSize(array2))
        return false;

      for(s32 y=0; y<size[0]; y++) {
        const u32 * const this_rowPointer = this->Pointer(y, 0);
        const u32 * const array2_rowPointer = array2.Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          const double value1 = static_cast<double>(this_rowPointer[x]);
          const double value2 = static_cast<double>(array2_rowPointer[x]);
          const double percentThresholdValue = percentThreshold * MAX(value1,value2);

          if(abs(value1 - value2) > percentThresholdValue && abs(value1 - value2) > absoluteThreshold)
            return false;
        }
      }

      return true;
    } // bool Array_u32::IsElementwiseEqual_PercentThreshold(const Array_u32 &array2, const double percentThreshold, const double absoluteThreshold) const

    // If this array or array2 are different sizes or uninitialized, then return false.
    bool Array_u32::IsEqualSize(const Array_u32 &array2) const
    {
      if(!this->IsValid())
        return false;

      if(!array2.IsValid())
        return false;

      if(this->get_size(0) != array2.get_size(0) || this->get_size(1) != array2.get_size(1))
        return false;

      return true;
    } // bool Array_u32::IsEqualSize(const Array_u32 &array2) const

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    void Array_u32::Show(const char * const windowName, const bool waitForKeypress) const
    {
      assert(this->IsValid());
      cv::imshow(windowName, cvMatMirror);
      if(waitForKeypress) {
        cv::waitKey();
      }
    } // void Array_u32::Show(const char * const windowName, const bool waitForKeypress) const
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    // Returns a templated cv::Mat_ that shares the same buffer with this Array_u32. No data is copied.
    cv::Mat_<u32>& Array_u32::get_CvMat_()
    {
      assert(this->IsValid());
      return cvMatMirror;
    } // cv::Mat_<u32>& Array_u32::get_CvMat_()
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

    // Print out the contents of this Array_u32
    void Array_u32::Print(const char * const variableName) const
    {
      assert(this->IsValid());

      printf("%s:\n", variableName);
      for(s32 y=0; y<size[0]; y++) {
        const u32 * const rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          printf("%d ", rowPointer[x]);
        }
        printf("\n");
      }
      printf("\n");
    } // void Array_u32::Print() const

    // If the Array_u32 was constructed with the useBoundaryFillPatterns=true, then
    // return if any memory was written out of bounds (via fill patterns at the
    // beginning and end).  If the Array_u32 was not constructed with the
    // useBoundaryFillPatterns=true, this method always returns true
    bool Array_u32::IsValid() const
    {
      if(this->rawDataPointer == NULL || this->data == NULL) {
        return false;
      }

      if(size[0] < 1 || size[1] < 1) {
        return false;
      }

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1],false);

        for(s32 y=0; y<size[0]; y++) {
          if((reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0]) != FILL_PATTERN_END ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1]) != FILL_PATTERN_END) {
              return false;
          }
        }

        return true;
      } else { // if(useBoundaryFillPatterns) {
        return true;
      } // if(useBoundaryFillPatterns) { ... else
    } // bool Array_u32::IsValid() const

    // Set every element in the Array_u32 to this value
    // Returns the number of values set
    s32 Array_u32::Set(const u32 value)
    {
      assert(this->IsValid());

      for(s32 y=0; y<size[0]; y++) {
        u32 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          rowPointer[x] = value;
        }
      }

      return size[0]*size[1];
    } // s32 Array_u32::Set(const u32 value)

    // Parse a space-seperated string, and copy values to this Array_u32.
    // If the string does not contain enough elements, the remainder of the Array_u32 will be filled with zeros.
    // Returns the number of values set (not counting extra zeros)
    s32 Array_u32::Set(const char * const values)
    {
      assert(this->IsValid());

      s32 numValuesSet = 0;

      const char * startPointer = values;
      char * endPointer = NULL;

      for(s32 y=0; y<size[0]; y++) {
        u32 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          const u32 value = static_cast<u32>(strtol(startPointer, &endPointer, 10));
          if(startPointer != endPointer) {
            rowPointer[x] = value;
            numValuesSet++;
          } else {
            rowPointer[x] = 0;
          }
          startPointer = endPointer;
        }
      }

      return numValuesSet;
    } // s32 Array_u32::Set(const char * const values)

    // Similar to Matlab size(matrix, dimension), and dimension is in {0,1}
    s32 Array_u32::get_size(s32 dimension) const
    {
      assert(dimension >= 0 && this->rawDataPointer != NULL && this->data != NULL);

      if(dimension > 1 || dimension < 0)
        return 0;

      return size[dimension];
    } // s32 Array_u32::get_size(s32 dimension) const

    s32 Array_u32::get_stride() const
    {
      return stride;
    } // s32 Array_u32::get_stride() const

    void* Array_u32::get_rawDataPointer()
    {
      return rawDataPointer;
    } // void* Array_u32::get_rawDataPointer()

    const void* Array_u32::get_rawDataPointer() const
    {
      return rawDataPointer;
    } // const void* Array_u32::get_rawDataPointer() const

    void Array_u32::Initialize(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      this->useBoundaryFillPatterns = useBoundaryFillPatterns;

      if(!rawData) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "input data buffer is NULL");
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->rawDataPointer = rawData;

      const size_t extraBoundaryPatternBytes = useBoundaryFillPatterns ? static_cast<size_t>(HEADER_LENGTH) : 0;
      const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData)+extraBoundaryPatternBytes, MEMORY_ALIGNMENT) - extraBoundaryPatternBytes - reinterpret_cast<size_t>(rawData));
      const s32 requiredBytes = ComputeRequiredStride(numCols,useBoundaryFillPatterns)*numRows + extraAlignmentBytes;

      if(requiredBytes > dataLength) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->size[0] = numRows;
      this->size[1] = numCols;

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1], false);
        this->data = reinterpret_cast<u32*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes + HEADER_LENGTH );
        for(s32 y=0; y<size[0]; y++) {
          // Add the fill patterns just before the data on each line
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0] = FILL_PATTERN_START;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1] = FILL_PATTERN_START;

          // And also just after the data (including normal byte-alignment padding)
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0] = FILL_PATTERN_END;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1] = FILL_PATTERN_END;
        }
      } else {
        this->data = reinterpret_cast<u32*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
      }

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
      cvMatMirror = cv::Mat_<u32>(size[0], size[1], data, stride);
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    } // Array_u32::Initialize()

    // Set all the buffers and sizes to zero, to signal an invalid array
    void Array_u32::InvalidateArray()
    {
      this->size[0] = 0;
      this->size[1] = 0;
      this->stride = 0;
      this->data = NULL;
      this->rawDataPointer = NULL;
    } // void Array_u32::InvalidateArray()

    // Factory method to create an Array_u32 from the heap. The data of the returned Array_u32 must be freed by the user.
    // This is separate from the normal constructor, as Array_u32 objects are not supposed to manage memory
    Array_u32 AllocateArrayFromHeap_u32(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      const s32 requiredMemory = 64 + 2*MEMORY_ALIGNMENT + Array_u32::ComputeMinimumRequiredMemory(numRows, numCols, useBoundaryFillPatterns); // The required memory, plus a bit more

      Array_u32 mat(numRows, numCols, calloc(requiredMemory, 1), requiredMemory, useBoundaryFillPatterns);

      return mat;
    } // Array_u32 AllocateArrayFromHeap_u32(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)


    s32 Array_s32::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0);
      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? (HEADER_LENGTH+FOOTER_LENGTH) : 0);
      return static_cast<s32>(RoundUp<size_t>(sizeof(s32)*numCols, MEMORY_ALIGNMENT)) + extraBoundaryPatternBytes;
    } // s32 Array_s32::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)

    s32 Array_s32::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0);
      return numRows * Array_s32::ComputeRequiredStride(numCols, useBoundaryFillPatterns);
    } // s32 Array_s32::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)

    Array_s32::Array_s32()
    {
      InvalidateArray();
    } // Array_s32::Array_s32()

    // Constructor for a Array_s32, pointing to user-allocated data. If the pointer to *data is not
    // aligned to MEMORY_ALIGNMENT, this Array_s32 will start at the next aligned location.
    // Unfortunately, this is more restrictive than most matrix libraries, and as an example,
    // it may make it hard to convert from OpenCV to Array_s32, though the reverse is trivial.
    Array_s32::Array_s32(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      Initialize(numRows,
        numCols,
        data,
        dataLength,
        useBoundaryFillPatterns);
    } // Array_s32::Array_s32(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)

    Array_s32::Array_s32(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0);

      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? static_cast<s32>(MEMORY_ALIGNMENT) : 0);
      const s32 numBytesRequested = numRows * this->stride + extraBoundaryPatternBytes;
      s32 numBytesAllocated = 0;

      void * allocatedBuffer = memory.Allocate(numBytesRequested, &numBytesAllocated);

      Initialize(numRows,
        numCols,
        reinterpret_cast<s32*>(allocatedBuffer),
        numBytesAllocated,
        useBoundaryFillPatterns);
    } // Array_s32::Array_s32(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)

    // Check every element of this array against the input array. If the arrays are different
    // sizes, uninitialized, or if any element is more different than the threshold, then return
    // false.
    bool Array_s32::IsElementwiseEqual(const Array_s32 &array2, const s32 threshold) const
    {
      if(!this->IsEqualSize(array2))
        return false;

      for(s32 y=0; y<size[0]; y++) {
        const s32 * const this_rowPointer = this->Pointer(y, 0);
        const s32 * const array2_rowPointer = array2.Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          if(this_rowPointer[x] > array2_rowPointer[x]) {
            if((this_rowPointer[x] - array2_rowPointer[x]) > threshold)
              return false;
          } else {
            if((array2_rowPointer[x] - this_rowPointer[x]) > threshold)
              return false;
          }
        }
      }

      return true;
    } // bool Array_s32::IsElementwiseEqual(const Array_s32 &array2, const s32 threshold) const

    // Check every element of this array against the input array. If the arrays are different
    // sizes or uninitialized, return false. The threshold is between 0.0 and 1.0. If any element
    // is more than a percentage different than its matching element (calulated from the maximum
    // of the two), return false.
    bool Array_s32::IsElementwiseEqual_PercentThreshold(const Array_s32 &array2, const double percentThreshold, const double absoluteThreshold) const
    {
      if(!this->IsEqualSize(array2))
        return false;

      for(s32 y=0; y<size[0]; y++) {
        const s32 * const this_rowPointer = this->Pointer(y, 0);
        const s32 * const array2_rowPointer = array2.Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          const double value1 = static_cast<double>(this_rowPointer[x]);
          const double value2 = static_cast<double>(array2_rowPointer[x]);
          const double percentThresholdValue = percentThreshold * MAX(value1,value2);

          if(abs(value1 - value2) > percentThresholdValue && abs(value1 - value2) > absoluteThreshold)
            return false;
        }
      }

      return true;
    } // bool Array_s32::IsElementwiseEqual_PercentThreshold(const Array_s32 &array2, const double percentThreshold, const double absoluteThreshold) const

    // If this array or array2 are different sizes or uninitialized, then return false.
    bool Array_s32::IsEqualSize(const Array_s32 &array2) const
    {
      if(!this->IsValid())
        return false;

      if(!array2.IsValid())
        return false;

      if(this->get_size(0) != array2.get_size(0) || this->get_size(1) != array2.get_size(1))
        return false;

      return true;
    } // bool Array_s32::IsEqualSize(const Array_s32 &array2) const

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    void Array_s32::Show(const char * const windowName, const bool waitForKeypress) const
    {
      assert(this->IsValid());
      cv::imshow(windowName, cvMatMirror);
      if(waitForKeypress) {
        cv::waitKey();
      }
    } // void Array_s32::Show(const char * const windowName, const bool waitForKeypress) const
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    // Returns a templated cv::Mat_ that shares the same buffer with this Array_s32. No data is copied.
    cv::Mat_<s32>& Array_s32::get_CvMat_()
    {
      assert(this->IsValid());
      return cvMatMirror;
    } // cv::Mat_<s32>& Array_s32::get_CvMat_()
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

    // Print out the contents of this Array_s32
    void Array_s32::Print(const char * const variableName) const
    {
      assert(this->IsValid());

      printf("%s:\n", variableName);
      for(s32 y=0; y<size[0]; y++) {
        const s32 * const rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          printf("%d ", rowPointer[x]);
        }
        printf("\n");
      }
      printf("\n");
    } // void Array_s32::Print() const

    // If the Array_s32 was constructed with the useBoundaryFillPatterns=true, then
    // return if any memory was written out of bounds (via fill patterns at the
    // beginning and end).  If the Array_s32 was not constructed with the
    // useBoundaryFillPatterns=true, this method always returns true
    bool Array_s32::IsValid() const
    {
      if(this->rawDataPointer == NULL || this->data == NULL) {
        return false;
      }

      if(size[0] < 1 || size[1] < 1) {
        return false;
      }

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1],false);

        for(s32 y=0; y<size[0]; y++) {
          if((reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0]) != FILL_PATTERN_END ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1]) != FILL_PATTERN_END) {
              return false;
          }
        }

        return true;
      } else { // if(useBoundaryFillPatterns) {
        return true;
      } // if(useBoundaryFillPatterns) { ... else
    } // bool Array_s32::IsValid() const

    // Set every element in the Array_s32 to this value
    // Returns the number of values set
    s32 Array_s32::Set(const s32 value)
    {
      assert(this->IsValid());

      for(s32 y=0; y<size[0]; y++) {
        s32 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          rowPointer[x] = value;
        }
      }

      return size[0]*size[1];
    } // s32 Array_s32::Set(const s32 value)

    // Parse a space-seperated string, and copy values to this Array_s32.
    // If the string does not contain enough elements, the remainder of the Array_s32 will be filled with zeros.
    // Returns the number of values set (not counting extra zeros)
    s32 Array_s32::Set(const char * const values)
    {
      assert(this->IsValid());

      s32 numValuesSet = 0;

      const char * startPointer = values;
      char * endPointer = NULL;

      for(s32 y=0; y<size[0]; y++) {
        s32 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          const s32 value = static_cast<s32>(strtol(startPointer, &endPointer, 10));
          if(startPointer != endPointer) {
            rowPointer[x] = value;
            numValuesSet++;
          } else {
            rowPointer[x] = 0;
          }
          startPointer = endPointer;
        }
      }

      return numValuesSet;
    } // s32 Array_s32::Set(const char * const values)

    // Similar to Matlab size(matrix, dimension), and dimension is in {0,1}
    s32 Array_s32::get_size(s32 dimension) const
    {
      assert(dimension >= 0 && this->rawDataPointer != NULL && this->data != NULL);

      if(dimension > 1 || dimension < 0)
        return 0;

      return size[dimension];
    } // s32 Array_s32::get_size(s32 dimension) const

    s32 Array_s32::get_stride() const
    {
      return stride;
    } // s32 Array_s32::get_stride() const

    void* Array_s32::get_rawDataPointer()
    {
      return rawDataPointer;
    } // void* Array_s32::get_rawDataPointer()

    const void* Array_s32::get_rawDataPointer() const
    {
      return rawDataPointer;
    } // const void* Array_s32::get_rawDataPointer() const

    void Array_s32::Initialize(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      this->useBoundaryFillPatterns = useBoundaryFillPatterns;

      if(!rawData) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "input data buffer is NULL");
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->rawDataPointer = rawData;

      const size_t extraBoundaryPatternBytes = useBoundaryFillPatterns ? static_cast<size_t>(HEADER_LENGTH) : 0;
      const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData)+extraBoundaryPatternBytes, MEMORY_ALIGNMENT) - extraBoundaryPatternBytes - reinterpret_cast<size_t>(rawData));
      const s32 requiredBytes = ComputeRequiredStride(numCols,useBoundaryFillPatterns)*numRows + extraAlignmentBytes;

      if(requiredBytes > dataLength) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->size[0] = numRows;
      this->size[1] = numCols;

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1], false);
        this->data = reinterpret_cast<s32*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes + HEADER_LENGTH );
        for(s32 y=0; y<size[0]; y++) {
          // Add the fill patterns just before the data on each line
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0] = FILL_PATTERN_START;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1] = FILL_PATTERN_START;

          // And also just after the data (including normal byte-alignment padding)
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0] = FILL_PATTERN_END;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1] = FILL_PATTERN_END;
        }
      } else {
        this->data = reinterpret_cast<s32*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
      }

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
      cvMatMirror = cv::Mat_<s32>(size[0], size[1], data, stride);
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    } // Array_s32::Initialize()

    // Set all the buffers and sizes to zero, to signal an invalid array
    void Array_s32::InvalidateArray()
    {
      this->size[0] = 0;
      this->size[1] = 0;
      this->stride = 0;
      this->data = NULL;
      this->rawDataPointer = NULL;
    } // void Array_s32::InvalidateArray()

    // Factory method to create an Array_s32 from the heap. The data of the returned Array_s32 must be freed by the user.
    // This is separate from the normal constructor, as Array_s32 objects are not supposed to manage memory
    Array_s32 AllocateArrayFromHeap_s32(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      const s32 requiredMemory = 64 + 2*MEMORY_ALIGNMENT + Array_s32::ComputeMinimumRequiredMemory(numRows, numCols, useBoundaryFillPatterns); // The required memory, plus a bit more

      Array_s32 mat(numRows, numCols, calloc(requiredMemory, 1), requiredMemory, useBoundaryFillPatterns);

      return mat;
    } // Array_s32 AllocateArrayFromHeap_s32(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)


    s32 Array_u64::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0);
      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? (HEADER_LENGTH+FOOTER_LENGTH) : 0);
      return static_cast<s32>(RoundUp<size_t>(sizeof(u64)*numCols, MEMORY_ALIGNMENT)) + extraBoundaryPatternBytes;
    } // s32 Array_u64::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)

    s32 Array_u64::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0);
      return numRows * Array_u64::ComputeRequiredStride(numCols, useBoundaryFillPatterns);
    } // s32 Array_u64::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)

    Array_u64::Array_u64()
    {
      InvalidateArray();
    } // Array_u64::Array_u64()

    // Constructor for a Array_u64, pointing to user-allocated data. If the pointer to *data is not
    // aligned to MEMORY_ALIGNMENT, this Array_u64 will start at the next aligned location.
    // Unfortunately, this is more restrictive than most matrix libraries, and as an example,
    // it may make it hard to convert from OpenCV to Array_u64, though the reverse is trivial.
    Array_u64::Array_u64(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      Initialize(numRows,
        numCols,
        data,
        dataLength,
        useBoundaryFillPatterns);
    } // Array_u64::Array_u64(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)

    Array_u64::Array_u64(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0);

      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? static_cast<s32>(MEMORY_ALIGNMENT) : 0);
      const s32 numBytesRequested = numRows * this->stride + extraBoundaryPatternBytes;
      s32 numBytesAllocated = 0;

      void * allocatedBuffer = memory.Allocate(numBytesRequested, &numBytesAllocated);

      Initialize(numRows,
        numCols,
        reinterpret_cast<u64*>(allocatedBuffer),
        numBytesAllocated,
        useBoundaryFillPatterns);
    } // Array_u64::Array_u64(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)

    // Check every element of this array against the input array. If the arrays are different
    // sizes, uninitialized, or if any element is more different than the threshold, then return
    // false.
    bool Array_u64::IsElementwiseEqual(const Array_u64 &array2, const u64 threshold) const
    {
      if(!this->IsEqualSize(array2))
        return false;

      for(s32 y=0; y<size[0]; y++) {
        const u64 * const this_rowPointer = this->Pointer(y, 0);
        const u64 * const array2_rowPointer = array2.Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          if(this_rowPointer[x] > array2_rowPointer[x]) {
            if((this_rowPointer[x] - array2_rowPointer[x]) > threshold)
              return false;
          } else {
            if((array2_rowPointer[x] - this_rowPointer[x]) > threshold)
              return false;
          }
        }
      }

      return true;
    } // bool Array_u64::IsElementwiseEqual(const Array_u64 &array2, const u64 threshold) const

    // Check every element of this array against the input array. If the arrays are different
    // sizes or uninitialized, return false. The threshold is between 0.0 and 1.0. If any element
    // is more than a percentage different than its matching element (calulated from the maximum
    // of the two), return false.
    bool Array_u64::IsElementwiseEqual_PercentThreshold(const Array_u64 &array2, const double percentThreshold, const double absoluteThreshold) const
    {
      if(!this->IsEqualSize(array2))
        return false;

      for(s32 y=0; y<size[0]; y++) {
        const u64 * const this_rowPointer = this->Pointer(y, 0);
        const u64 * const array2_rowPointer = array2.Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          const double value1 = static_cast<double>(this_rowPointer[x]);
          const double value2 = static_cast<double>(array2_rowPointer[x]);
          const double percentThresholdValue = percentThreshold * MAX(value1,value2);

          if(abs(value1 - value2) > percentThresholdValue && abs(value1 - value2) > absoluteThreshold)
            return false;
        }
      }

      return true;
    } // bool Array_u64::IsElementwiseEqual_PercentThreshold(const Array_u64 &array2, const double percentThreshold, const double absoluteThreshold) const

    // If this array or array2 are different sizes or uninitialized, then return false.
    bool Array_u64::IsEqualSize(const Array_u64 &array2) const
    {
      if(!this->IsValid())
        return false;

      if(!array2.IsValid())
        return false;

      if(this->get_size(0) != array2.get_size(0) || this->get_size(1) != array2.get_size(1))
        return false;

      return true;
    } // bool Array_u64::IsEqualSize(const Array_u64 &array2) const

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    void Array_u64::Show(const char * const windowName, const bool waitForKeypress) const
    {
      assert(this->IsValid());
      cv::imshow(windowName, cvMatMirror);
      if(waitForKeypress) {
        cv::waitKey();
      }
    } // void Array_u64::Show(const char * const windowName, const bool waitForKeypress) const
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    // Returns a templated cv::Mat_ that shares the same buffer with this Array_u64. No data is copied.
    cv::Mat_<u64>& Array_u64::get_CvMat_()
    {
      assert(this->IsValid());
      return cvMatMirror;
    } // cv::Mat_<u64>& Array_u64::get_CvMat_()
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

    // Print out the contents of this Array_u64
    void Array_u64::Print(const char * const variableName) const
    {
      assert(this->IsValid());

      printf("%s:\n", variableName);
      for(s32 y=0; y<size[0]; y++) {
        const u64 * const rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          printf("%d ", rowPointer[x]);
        }
        printf("\n");
      }
      printf("\n");
    } // void Array_u64::Print() const

    // If the Array_u64 was constructed with the useBoundaryFillPatterns=true, then
    // return if any memory was written out of bounds (via fill patterns at the
    // beginning and end).  If the Array_u64 was not constructed with the
    // useBoundaryFillPatterns=true, this method always returns true
    bool Array_u64::IsValid() const
    {
      if(this->rawDataPointer == NULL || this->data == NULL) {
        return false;
      }

      if(size[0] < 1 || size[1] < 1) {
        return false;
      }

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1],false);

        for(s32 y=0; y<size[0]; y++) {
          if((reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0]) != FILL_PATTERN_END ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1]) != FILL_PATTERN_END) {
              return false;
          }
        }

        return true;
      } else { // if(useBoundaryFillPatterns) {
        return true;
      } // if(useBoundaryFillPatterns) { ... else
    } // bool Array_u64::IsValid() const

    // Set every element in the Array_u64 to this value
    // Returns the number of values set
    s32 Array_u64::Set(const u64 value)
    {
      assert(this->IsValid());

      for(s32 y=0; y<size[0]; y++) {
        u64 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          rowPointer[x] = value;
        }
      }

      return size[0]*size[1];
    } // s32 Array_u64::Set(const u64 value)

    // Parse a space-seperated string, and copy values to this Array_u64.
    // If the string does not contain enough elements, the remainder of the Array_u64 will be filled with zeros.
    // Returns the number of values set (not counting extra zeros)
    s32 Array_u64::Set(const char * const values)
    {
      assert(this->IsValid());

      s32 numValuesSet = 0;

      const char * startPointer = values;
      char * endPointer = NULL;

      for(s32 y=0; y<size[0]; y++) {
        u64 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          const u64 value = static_cast<u64>(strtol(startPointer, &endPointer, 10));
          if(startPointer != endPointer) {
            rowPointer[x] = value;
            numValuesSet++;
          } else {
            rowPointer[x] = 0;
          }
          startPointer = endPointer;
        }
      }

      return numValuesSet;
    } // s32 Array_u64::Set(const char * const values)

    // Similar to Matlab size(matrix, dimension), and dimension is in {0,1}
    s32 Array_u64::get_size(s32 dimension) const
    {
      assert(dimension >= 0 && this->rawDataPointer != NULL && this->data != NULL);

      if(dimension > 1 || dimension < 0)
        return 0;

      return size[dimension];
    } // s32 Array_u64::get_size(s32 dimension) const

    s32 Array_u64::get_stride() const
    {
      return stride;
    } // s32 Array_u64::get_stride() const

    void* Array_u64::get_rawDataPointer()
    {
      return rawDataPointer;
    } // void* Array_u64::get_rawDataPointer()

    const void* Array_u64::get_rawDataPointer() const
    {
      return rawDataPointer;
    } // const void* Array_u64::get_rawDataPointer() const

    void Array_u64::Initialize(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      this->useBoundaryFillPatterns = useBoundaryFillPatterns;

      if(!rawData) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "input data buffer is NULL");
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->rawDataPointer = rawData;

      const size_t extraBoundaryPatternBytes = useBoundaryFillPatterns ? static_cast<size_t>(HEADER_LENGTH) : 0;
      const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData)+extraBoundaryPatternBytes, MEMORY_ALIGNMENT) - extraBoundaryPatternBytes - reinterpret_cast<size_t>(rawData));
      const s32 requiredBytes = ComputeRequiredStride(numCols,useBoundaryFillPatterns)*numRows + extraAlignmentBytes;

      if(requiredBytes > dataLength) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->size[0] = numRows;
      this->size[1] = numCols;

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1], false);
        this->data = reinterpret_cast<u64*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes + HEADER_LENGTH );
        for(s32 y=0; y<size[0]; y++) {
          // Add the fill patterns just before the data on each line
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0] = FILL_PATTERN_START;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1] = FILL_PATTERN_START;

          // And also just after the data (including normal byte-alignment padding)
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0] = FILL_PATTERN_END;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1] = FILL_PATTERN_END;
        }
      } else {
        this->data = reinterpret_cast<u64*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
      }

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
      cvMatMirror = cv::Mat_<u64>(size[0], size[1], data, stride);
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    } // Array_u64::Initialize()

    // Set all the buffers and sizes to zero, to signal an invalid array
    void Array_u64::InvalidateArray()
    {
      this->size[0] = 0;
      this->size[1] = 0;
      this->stride = 0;
      this->data = NULL;
      this->rawDataPointer = NULL;
    } // void Array_u64::InvalidateArray()

    // Factory method to create an Array_u64 from the heap. The data of the returned Array_u64 must be freed by the user.
    // This is separate from the normal constructor, as Array_u64 objects are not supposed to manage memory
    Array_u64 AllocateArrayFromHeap_u64(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      const s32 requiredMemory = 64 + 2*MEMORY_ALIGNMENT + Array_u64::ComputeMinimumRequiredMemory(numRows, numCols, useBoundaryFillPatterns); // The required memory, plus a bit more

      Array_u64 mat(numRows, numCols, calloc(requiredMemory, 1), requiredMemory, useBoundaryFillPatterns);

      return mat;
    } // Array_u64 AllocateArrayFromHeap_u64(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)


    s32 Array_s64::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0);
      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? (HEADER_LENGTH+FOOTER_LENGTH) : 0);
      return static_cast<s32>(RoundUp<size_t>(sizeof(s64)*numCols, MEMORY_ALIGNMENT)) + extraBoundaryPatternBytes;
    } // s32 Array_s64::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)

    s32 Array_s64::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0);
      return numRows * Array_s64::ComputeRequiredStride(numCols, useBoundaryFillPatterns);
    } // s32 Array_s64::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)

    Array_s64::Array_s64()
    {
      InvalidateArray();
    } // Array_s64::Array_s64()

    // Constructor for a Array_s64, pointing to user-allocated data. If the pointer to *data is not
    // aligned to MEMORY_ALIGNMENT, this Array_s64 will start at the next aligned location.
    // Unfortunately, this is more restrictive than most matrix libraries, and as an example,
    // it may make it hard to convert from OpenCV to Array_s64, though the reverse is trivial.
    Array_s64::Array_s64(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      Initialize(numRows,
        numCols,
        data,
        dataLength,
        useBoundaryFillPatterns);
    } // Array_s64::Array_s64(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)

    Array_s64::Array_s64(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0);

      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? static_cast<s32>(MEMORY_ALIGNMENT) : 0);
      const s32 numBytesRequested = numRows * this->stride + extraBoundaryPatternBytes;
      s32 numBytesAllocated = 0;

      void * allocatedBuffer = memory.Allocate(numBytesRequested, &numBytesAllocated);

      Initialize(numRows,
        numCols,
        reinterpret_cast<s64*>(allocatedBuffer),
        numBytesAllocated,
        useBoundaryFillPatterns);
    } // Array_s64::Array_s64(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)

    // Check every element of this array against the input array. If the arrays are different
    // sizes, uninitialized, or if any element is more different than the threshold, then return
    // false.
    bool Array_s64::IsElementwiseEqual(const Array_s64 &array2, const s64 threshold) const
    {
      if(!this->IsEqualSize(array2))
        return false;

      for(s32 y=0; y<size[0]; y++) {
        const s64 * const this_rowPointer = this->Pointer(y, 0);
        const s64 * const array2_rowPointer = array2.Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          if(this_rowPointer[x] > array2_rowPointer[x]) {
            if((this_rowPointer[x] - array2_rowPointer[x]) > threshold)
              return false;
          } else {
            if((array2_rowPointer[x] - this_rowPointer[x]) > threshold)
              return false;
          }
        }
      }

      return true;
    } // bool Array_s64::IsElementwiseEqual(const Array_s64 &array2, const s64 threshold) const

    // Check every element of this array against the input array. If the arrays are different
    // sizes or uninitialized, return false. The threshold is between 0.0 and 1.0. If any element
    // is more than a percentage different than its matching element (calulated from the maximum
    // of the two), return false.
    bool Array_s64::IsElementwiseEqual_PercentThreshold(const Array_s64 &array2, const double percentThreshold, const double absoluteThreshold) const
    {
      if(!this->IsEqualSize(array2))
        return false;

      for(s32 y=0; y<size[0]; y++) {
        const s64 * const this_rowPointer = this->Pointer(y, 0);
        const s64 * const array2_rowPointer = array2.Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          const double value1 = static_cast<double>(this_rowPointer[x]);
          const double value2 = static_cast<double>(array2_rowPointer[x]);
          const double percentThresholdValue = percentThreshold * MAX(value1,value2);

          if(abs(value1 - value2) > percentThresholdValue && abs(value1 - value2) > absoluteThreshold)
            return false;
        }
      }

      return true;
    } // bool Array_s64::IsElementwiseEqual_PercentThreshold(const Array_s64 &array2, const double percentThreshold, const double absoluteThreshold) const

    // If this array or array2 are different sizes or uninitialized, then return false.
    bool Array_s64::IsEqualSize(const Array_s64 &array2) const
    {
      if(!this->IsValid())
        return false;

      if(!array2.IsValid())
        return false;

      if(this->get_size(0) != array2.get_size(0) || this->get_size(1) != array2.get_size(1))
        return false;

      return true;
    } // bool Array_s64::IsEqualSize(const Array_s64 &array2) const

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    void Array_s64::Show(const char * const windowName, const bool waitForKeypress) const
    {
      assert(this->IsValid());
      cv::imshow(windowName, cvMatMirror);
      if(waitForKeypress) {
        cv::waitKey();
      }
    } // void Array_s64::Show(const char * const windowName, const bool waitForKeypress) const
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    // Returns a templated cv::Mat_ that shares the same buffer with this Array_s64. No data is copied.
    cv::Mat_<s64>& Array_s64::get_CvMat_()
    {
      assert(this->IsValid());
      return cvMatMirror;
    } // cv::Mat_<s64>& Array_s64::get_CvMat_()
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

    // Print out the contents of this Array_s64
    void Array_s64::Print(const char * const variableName) const
    {
      assert(this->IsValid());

      printf("%s:\n", variableName);
      for(s32 y=0; y<size[0]; y++) {
        const s64 * const rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          printf("%d ", rowPointer[x]);
        }
        printf("\n");
      }
      printf("\n");
    } // void Array_s64::Print() const

    // If the Array_s64 was constructed with the useBoundaryFillPatterns=true, then
    // return if any memory was written out of bounds (via fill patterns at the
    // beginning and end).  If the Array_s64 was not constructed with the
    // useBoundaryFillPatterns=true, this method always returns true
    bool Array_s64::IsValid() const
    {
      if(this->rawDataPointer == NULL || this->data == NULL) {
        return false;
      }

      if(size[0] < 1 || size[1] < 1) {
        return false;
      }

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1],false);

        for(s32 y=0; y<size[0]; y++) {
          if((reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0]) != FILL_PATTERN_END ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1]) != FILL_PATTERN_END) {
              return false;
          }
        }

        return true;
      } else { // if(useBoundaryFillPatterns) {
        return true;
      } // if(useBoundaryFillPatterns) { ... else
    } // bool Array_s64::IsValid() const

    // Set every element in the Array_s64 to this value
    // Returns the number of values set
    s32 Array_s64::Set(const s64 value)
    {
      assert(this->IsValid());

      for(s32 y=0; y<size[0]; y++) {
        s64 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          rowPointer[x] = value;
        }
      }

      return size[0]*size[1];
    } // s32 Array_s64::Set(const s64 value)

    // Parse a space-seperated string, and copy values to this Array_s64.
    // If the string does not contain enough elements, the remainder of the Array_s64 will be filled with zeros.
    // Returns the number of values set (not counting extra zeros)
    s32 Array_s64::Set(const char * const values)
    {
      assert(this->IsValid());

      s32 numValuesSet = 0;

      const char * startPointer = values;
      char * endPointer = NULL;

      for(s32 y=0; y<size[0]; y++) {
        s64 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          const s64 value = static_cast<s64>(strtol(startPointer, &endPointer, 10));
          if(startPointer != endPointer) {
            rowPointer[x] = value;
            numValuesSet++;
          } else {
            rowPointer[x] = 0;
          }
          startPointer = endPointer;
        }
      }

      return numValuesSet;
    } // s32 Array_s64::Set(const char * const values)

    // Similar to Matlab size(matrix, dimension), and dimension is in {0,1}
    s32 Array_s64::get_size(s32 dimension) const
    {
      assert(dimension >= 0 && this->rawDataPointer != NULL && this->data != NULL);

      if(dimension > 1 || dimension < 0)
        return 0;

      return size[dimension];
    } // s32 Array_s64::get_size(s32 dimension) const

    s32 Array_s64::get_stride() const
    {
      return stride;
    } // s32 Array_s64::get_stride() const

    void* Array_s64::get_rawDataPointer()
    {
      return rawDataPointer;
    } // void* Array_s64::get_rawDataPointer()

    const void* Array_s64::get_rawDataPointer() const
    {
      return rawDataPointer;
    } // const void* Array_s64::get_rawDataPointer() const

    void Array_s64::Initialize(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      this->useBoundaryFillPatterns = useBoundaryFillPatterns;

      if(!rawData) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "input data buffer is NULL");
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->rawDataPointer = rawData;

      const size_t extraBoundaryPatternBytes = useBoundaryFillPatterns ? static_cast<size_t>(HEADER_LENGTH) : 0;
      const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData)+extraBoundaryPatternBytes, MEMORY_ALIGNMENT) - extraBoundaryPatternBytes - reinterpret_cast<size_t>(rawData));
      const s32 requiredBytes = ComputeRequiredStride(numCols,useBoundaryFillPatterns)*numRows + extraAlignmentBytes;

      if(requiredBytes > dataLength) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->size[0] = numRows;
      this->size[1] = numCols;

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1], false);
        this->data = reinterpret_cast<s64*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes + HEADER_LENGTH );
        for(s32 y=0; y<size[0]; y++) {
          // Add the fill patterns just before the data on each line
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0] = FILL_PATTERN_START;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1] = FILL_PATTERN_START;

          // And also just after the data (including normal byte-alignment padding)
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0] = FILL_PATTERN_END;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1] = FILL_PATTERN_END;
        }
      } else {
        this->data = reinterpret_cast<s64*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
      }

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
      cvMatMirror = cv::Mat_<s64>(size[0], size[1], data, stride);
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    } // Array_s64::Initialize()

    // Set all the buffers and sizes to zero, to signal an invalid array
    void Array_s64::InvalidateArray()
    {
      this->size[0] = 0;
      this->size[1] = 0;
      this->stride = 0;
      this->data = NULL;
      this->rawDataPointer = NULL;
    } // void Array_s64::InvalidateArray()

    // Factory method to create an Array_s64 from the heap. The data of the returned Array_s64 must be freed by the user.
    // This is separate from the normal constructor, as Array_s64 objects are not supposed to manage memory
    Array_s64 AllocateArrayFromHeap_s64(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      const s32 requiredMemory = 64 + 2*MEMORY_ALIGNMENT + Array_s64::ComputeMinimumRequiredMemory(numRows, numCols, useBoundaryFillPatterns); // The required memory, plus a bit more

      Array_s64 mat(numRows, numCols, calloc(requiredMemory, 1), requiredMemory, useBoundaryFillPatterns);

      return mat;
    } // Array_s64 AllocateArrayFromHeap_s64(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)


    s32 Array_f32::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0);
      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? (HEADER_LENGTH+FOOTER_LENGTH) : 0);
      return static_cast<s32>(RoundUp<size_t>(sizeof(f32)*numCols, MEMORY_ALIGNMENT)) + extraBoundaryPatternBytes;
    } // s32 Array_f32::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)

    s32 Array_f32::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0);
      return numRows * Array_f32::ComputeRequiredStride(numCols, useBoundaryFillPatterns);
    } // s32 Array_f32::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)

    Array_f32::Array_f32()
    {
      InvalidateArray();
    } // Array_f32::Array_f32()

    // Constructor for a Array_f32, pointing to user-allocated data. If the pointer to *data is not
    // aligned to MEMORY_ALIGNMENT, this Array_f32 will start at the next aligned location.
    // Unfortunately, this is more restrictive than most matrix libraries, and as an example,
    // it may make it hard to convert from OpenCV to Array_f32, though the reverse is trivial.
    Array_f32::Array_f32(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      Initialize(numRows,
        numCols,
        data,
        dataLength,
        useBoundaryFillPatterns);
    } // Array_f32::Array_f32(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)

    Array_f32::Array_f32(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0);

      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? static_cast<s32>(MEMORY_ALIGNMENT) : 0);
      const s32 numBytesRequested = numRows * this->stride + extraBoundaryPatternBytes;
      s32 numBytesAllocated = 0;

      void * allocatedBuffer = memory.Allocate(numBytesRequested, &numBytesAllocated);

      Initialize(numRows,
        numCols,
        reinterpret_cast<f32*>(allocatedBuffer),
        numBytesAllocated,
        useBoundaryFillPatterns);
    } // Array_f32::Array_f32(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)

    // Check every element of this array against the input array. If the arrays are different
    // sizes, uninitialized, or if any element is more different than the threshold, then return
    // false.
    bool Array_f32::IsElementwiseEqual(const Array_f32 &array2, const f32 threshold) const
    {
      if(!this->IsEqualSize(array2))
        return false;

      for(s32 y=0; y<size[0]; y++) {
        const f32 * const this_rowPointer = this->Pointer(y, 0);
        const f32 * const array2_rowPointer = array2.Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          if(this_rowPointer[x] > array2_rowPointer[x]) {
            if((this_rowPointer[x] - array2_rowPointer[x]) > threshold)
              return false;
          } else {
            if((array2_rowPointer[x] - this_rowPointer[x]) > threshold)
              return false;
          }
        }
      }

      return true;
    } // bool Array_f32::IsElementwiseEqual(const Array_f32 &array2, const f32 threshold) const

    // Check every element of this array against the input array. If the arrays are different
    // sizes or uninitialized, return false. The threshold is between 0.0 and 1.0. If any element
    // is more than a percentage different than its matching element (calulated from the maximum
    // of the two), return false.
    bool Array_f32::IsElementwiseEqual_PercentThreshold(const Array_f32 &array2, const double percentThreshold, const double absoluteThreshold) const
    {
      if(!this->IsEqualSize(array2))
        return false;

      for(s32 y=0; y<size[0]; y++) {
        const f32 * const this_rowPointer = this->Pointer(y, 0);
        const f32 * const array2_rowPointer = array2.Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          const double value1 = static_cast<double>(this_rowPointer[x]);
          const double value2 = static_cast<double>(array2_rowPointer[x]);
          const double percentThresholdValue = percentThreshold * MAX(value1,value2);

          if(abs(value1 - value2) > percentThresholdValue && abs(value1 - value2) > absoluteThreshold)
            return false;
        }
      }

      return true;
    } // bool Array_f32::IsElementwiseEqual_PercentThreshold(const Array_f32 &array2, const double percentThreshold, const double absoluteThreshold) const

    // If this array or array2 are different sizes or uninitialized, then return false.
    bool Array_f32::IsEqualSize(const Array_f32 &array2) const
    {
      if(!this->IsValid())
        return false;

      if(!array2.IsValid())
        return false;

      if(this->get_size(0) != array2.get_size(0) || this->get_size(1) != array2.get_size(1))
        return false;

      return true;
    } // bool Array_f32::IsEqualSize(const Array_f32 &array2) const

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    void Array_f32::Show(const char * const windowName, const bool waitForKeypress) const
    {
      assert(this->IsValid());
      cv::imshow(windowName, cvMatMirror);
      if(waitForKeypress) {
        cv::waitKey();
      }
    } // void Array_f32::Show(const char * const windowName, const bool waitForKeypress) const
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    // Returns a templated cv::Mat_ that shares the same buffer with this Array_f32. No data is copied.
    cv::Mat_<f32>& Array_f32::get_CvMat_()
    {
      assert(this->IsValid());
      return cvMatMirror;
    } // cv::Mat_<f32>& Array_f32::get_CvMat_()
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

    // Print out the contents of this Array_f32
    void Array_f32::Print(const char * const variableName) const
    {
      assert(this->IsValid());

      printf("%s:\n", variableName);
      for(s32 y=0; y<size[0]; y++) {
        const f32 * const rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          printf("%f ", rowPointer[x]);
        }
        printf("\n");
      }
      printf("\n");
    } // void Array_f32::Print() const

    // If the Array_f32 was constructed with the useBoundaryFillPatterns=true, then
    // return if any memory was written out of bounds (via fill patterns at the
    // beginning and end).  If the Array_f32 was not constructed with the
    // useBoundaryFillPatterns=true, this method always returns true
    bool Array_f32::IsValid() const
    {
      if(this->rawDataPointer == NULL || this->data == NULL) {
        return false;
      }

      if(size[0] < 1 || size[1] < 1) {
        return false;
      }

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1],false);

        for(s32 y=0; y<size[0]; y++) {
          if((reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0]) != FILL_PATTERN_END ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1]) != FILL_PATTERN_END) {
              return false;
          }
        }

        return true;
      } else { // if(useBoundaryFillPatterns) {
        return true;
      } // if(useBoundaryFillPatterns) { ... else
    } // bool Array_f32::IsValid() const

    // Set every element in the Array_f32 to this value
    // Returns the number of values set
    s32 Array_f32::Set(const f32 value)
    {
      assert(this->IsValid());

      for(s32 y=0; y<size[0]; y++) {
        f32 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          rowPointer[x] = value;
        }
      }

      return size[0]*size[1];
    } // s32 Array_f32::Set(const f32 value)

    // Parse a space-seperated string, and copy values to this Array_f32.
    // If the string does not contain enough elements, the remainder of the Array_f32 will be filled with zeros.
    // Returns the number of values set (not counting extra zeros)
    s32 Array_f32::Set(const char * const values)
    {
      assert(this->IsValid());

      s32 numValuesSet = 0;

      const char * startPointer = values;
      char * endPointer = NULL;

      for(s32 y=0; y<size[0]; y++) {
        f32 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          const f32 value = static_cast<f32>(strtod(startPointer, &endPointer));
          if(startPointer != endPointer) {
            rowPointer[x] = value;
            numValuesSet++;
          } else {
            rowPointer[x] = 0;
          }
          startPointer = endPointer;
        }
      }

      return numValuesSet;
    } // s32 Array_f32::Set(const char * const values)

    // Similar to Matlab size(matrix, dimension), and dimension is in {0,1}
    s32 Array_f32::get_size(s32 dimension) const
    {
      assert(dimension >= 0 && this->rawDataPointer != NULL && this->data != NULL);

      if(dimension > 1 || dimension < 0)
        return 0;

      return size[dimension];
    } // s32 Array_f32::get_size(s32 dimension) const

    s32 Array_f32::get_stride() const
    {
      return stride;
    } // s32 Array_f32::get_stride() const

    void* Array_f32::get_rawDataPointer()
    {
      return rawDataPointer;
    } // void* Array_f32::get_rawDataPointer()

    const void* Array_f32::get_rawDataPointer() const
    {
      return rawDataPointer;
    } // const void* Array_f32::get_rawDataPointer() const

    void Array_f32::Initialize(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      this->useBoundaryFillPatterns = useBoundaryFillPatterns;

      if(!rawData) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "input data buffer is NULL");
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->rawDataPointer = rawData;

      const size_t extraBoundaryPatternBytes = useBoundaryFillPatterns ? static_cast<size_t>(HEADER_LENGTH) : 0;
      const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData)+extraBoundaryPatternBytes, MEMORY_ALIGNMENT) - extraBoundaryPatternBytes - reinterpret_cast<size_t>(rawData));
      const s32 requiredBytes = ComputeRequiredStride(numCols,useBoundaryFillPatterns)*numRows + extraAlignmentBytes;

      if(requiredBytes > dataLength) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->size[0] = numRows;
      this->size[1] = numCols;

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1], false);
        this->data = reinterpret_cast<f32*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes + HEADER_LENGTH );
        for(s32 y=0; y<size[0]; y++) {
          // Add the fill patterns just before the data on each line
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0] = FILL_PATTERN_START;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1] = FILL_PATTERN_START;

          // And also just after the data (including normal byte-alignment padding)
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0] = FILL_PATTERN_END;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1] = FILL_PATTERN_END;
        }
      } else {
        this->data = reinterpret_cast<f32*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
      }

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
      cvMatMirror = cv::Mat_<f32>(size[0], size[1], data, stride);
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    } // Array_f32::Initialize()

    // Set all the buffers and sizes to zero, to signal an invalid array
    void Array_f32::InvalidateArray()
    {
      this->size[0] = 0;
      this->size[1] = 0;
      this->stride = 0;
      this->data = NULL;
      this->rawDataPointer = NULL;
    } // void Array_f32::InvalidateArray()

    // Factory method to create an Array_f32 from the heap. The data of the returned Array_f32 must be freed by the user.
    // This is separate from the normal constructor, as Array_f32 objects are not supposed to manage memory
    Array_f32 AllocateArrayFromHeap_f32(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      const s32 requiredMemory = 64 + 2*MEMORY_ALIGNMENT + Array_f32::ComputeMinimumRequiredMemory(numRows, numCols, useBoundaryFillPatterns); // The required memory, plus a bit more

      Array_f32 mat(numRows, numCols, calloc(requiredMemory, 1), requiredMemory, useBoundaryFillPatterns);

      return mat;
    } // Array_f32 AllocateArrayFromHeap_f32(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)


    s32 Array_f64::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0);
      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? (HEADER_LENGTH+FOOTER_LENGTH) : 0);
      return static_cast<s32>(RoundUp<size_t>(sizeof(f64)*numCols, MEMORY_ALIGNMENT)) + extraBoundaryPatternBytes;
    } // s32 Array_f64::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)

    s32 Array_f64::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0);
      return numRows * Array_f64::ComputeRequiredStride(numCols, useBoundaryFillPatterns);
    } // s32 Array_f64::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)

    Array_f64::Array_f64()
    {
      InvalidateArray();
    } // Array_f64::Array_f64()

    // Constructor for a Array_f64, pointing to user-allocated data. If the pointer to *data is not
    // aligned to MEMORY_ALIGNMENT, this Array_f64 will start at the next aligned location.
    // Unfortunately, this is more restrictive than most matrix libraries, and as an example,
    // it may make it hard to convert from OpenCV to Array_f64, though the reverse is trivial.
    Array_f64::Array_f64(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      Initialize(numRows,
        numCols,
        data,
        dataLength,
        useBoundaryFillPatterns);
    } // Array_f64::Array_f64(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)

    Array_f64::Array_f64(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0);

      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? static_cast<s32>(MEMORY_ALIGNMENT) : 0);
      const s32 numBytesRequested = numRows * this->stride + extraBoundaryPatternBytes;
      s32 numBytesAllocated = 0;

      void * allocatedBuffer = memory.Allocate(numBytesRequested, &numBytesAllocated);

      Initialize(numRows,
        numCols,
        reinterpret_cast<f64*>(allocatedBuffer),
        numBytesAllocated,
        useBoundaryFillPatterns);
    } // Array_f64::Array_f64(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)

    // Check every element of this array against the input array. If the arrays are different
    // sizes, uninitialized, or if any element is more different than the threshold, then return
    // false.
    bool Array_f64::IsElementwiseEqual(const Array_f64 &array2, const f64 threshold) const
    {
      if(!this->IsEqualSize(array2))
        return false;

      for(s32 y=0; y<size[0]; y++) {
        const f64 * const this_rowPointer = this->Pointer(y, 0);
        const f64 * const array2_rowPointer = array2.Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          if(this_rowPointer[x] > array2_rowPointer[x]) {
            if((this_rowPointer[x] - array2_rowPointer[x]) > threshold)
              return false;
          } else {
            if((array2_rowPointer[x] - this_rowPointer[x]) > threshold)
              return false;
          }
        }
      }

      return true;
    } // bool Array_f64::IsElementwiseEqual(const Array_f64 &array2, const f64 threshold) const

    // Check every element of this array against the input array. If the arrays are different
    // sizes or uninitialized, return false. The threshold is between 0.0 and 1.0. If any element
    // is more than a percentage different than its matching element (calulated from the maximum
    // of the two), return false.
    bool Array_f64::IsElementwiseEqual_PercentThreshold(const Array_f64 &array2, const double percentThreshold, const double absoluteThreshold) const
    {
      if(!this->IsEqualSize(array2))
        return false;

      for(s32 y=0; y<size[0]; y++) {
        const f64 * const this_rowPointer = this->Pointer(y, 0);
        const f64 * const array2_rowPointer = array2.Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          const double value1 = static_cast<double>(this_rowPointer[x]);
          const double value2 = static_cast<double>(array2_rowPointer[x]);
          const double percentThresholdValue = percentThreshold * MAX(value1,value2);

          if(abs(value1 - value2) > percentThresholdValue && abs(value1 - value2) > absoluteThreshold)
            return false;
        }
      }

      return true;
    } // bool Array_f64::IsElementwiseEqual_PercentThreshold(const Array_f64 &array2, const double percentThreshold, const double absoluteThreshold) const

    // If this array or array2 are different sizes or uninitialized, then return false.
    bool Array_f64::IsEqualSize(const Array_f64 &array2) const
    {
      if(!this->IsValid())
        return false;

      if(!array2.IsValid())
        return false;

      if(this->get_size(0) != array2.get_size(0) || this->get_size(1) != array2.get_size(1))
        return false;

      return true;
    } // bool Array_f64::IsEqualSize(const Array_f64 &array2) const

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    void Array_f64::Show(const char * const windowName, const bool waitForKeypress) const
    {
      assert(this->IsValid());
      cv::imshow(windowName, cvMatMirror);
      if(waitForKeypress) {
        cv::waitKey();
      }
    } // void Array_f64::Show(const char * const windowName, const bool waitForKeypress) const
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    // Returns a templated cv::Mat_ that shares the same buffer with this Array_f64. No data is copied.
    cv::Mat_<f64>& Array_f64::get_CvMat_()
    {
      assert(this->IsValid());
      return cvMatMirror;
    } // cv::Mat_<f64>& Array_f64::get_CvMat_()
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

    // Print out the contents of this Array_f64
    void Array_f64::Print(const char * const variableName) const
    {
      assert(this->IsValid());

      printf("%s:\n", variableName);
      for(s32 y=0; y<size[0]; y++) {
        const f64 * const rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          printf("%f ", rowPointer[x]);
        }
        printf("\n");
      }
      printf("\n");
    } // void Array_f64::Print() const

    // If the Array_f64 was constructed with the useBoundaryFillPatterns=true, then
    // return if any memory was written out of bounds (via fill patterns at the
    // beginning and end).  If the Array_f64 was not constructed with the
    // useBoundaryFillPatterns=true, this method always returns true
    bool Array_f64::IsValid() const
    {
      if(this->rawDataPointer == NULL || this->data == NULL) {
        return false;
      }

      if(size[0] < 1 || size[1] < 1) {
        return false;
      }

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1],false);

        for(s32 y=0; y<size[0]; y++) {
          if((reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0]) != FILL_PATTERN_END ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1]) != FILL_PATTERN_END) {
              return false;
          }
        }

        return true;
      } else { // if(useBoundaryFillPatterns) {
        return true;
      } // if(useBoundaryFillPatterns) { ... else
    } // bool Array_f64::IsValid() const

    // Set every element in the Array_f64 to this value
    // Returns the number of values set
    s32 Array_f64::Set(const f64 value)
    {
      assert(this->IsValid());

      for(s32 y=0; y<size[0]; y++) {
        f64 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          rowPointer[x] = value;
        }
      }

      return size[0]*size[1];
    } // s32 Array_f64::Set(const f64 value)

    // Parse a space-seperated string, and copy values to this Array_f64.
    // If the string does not contain enough elements, the remainder of the Array_f64 will be filled with zeros.
    // Returns the number of values set (not counting extra zeros)
    s32 Array_f64::Set(const char * const values)
    {
      assert(this->IsValid());

      s32 numValuesSet = 0;

      const char * startPointer = values;
      char * endPointer = NULL;

      for(s32 y=0; y<size[0]; y++) {
        f64 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          const f64 value = static_cast<f64>(strtod(startPointer, &endPointer));
          if(startPointer != endPointer) {
            rowPointer[x] = value;
            numValuesSet++;
          } else {
            rowPointer[x] = 0;
          }
          startPointer = endPointer;
        }
      }

      return numValuesSet;
    } // s32 Array_f64::Set(const char * const values)

    // Similar to Matlab size(matrix, dimension), and dimension is in {0,1}
    s32 Array_f64::get_size(s32 dimension) const
    {
      assert(dimension >= 0 && this->rawDataPointer != NULL && this->data != NULL);

      if(dimension > 1 || dimension < 0)
        return 0;

      return size[dimension];
    } // s32 Array_f64::get_size(s32 dimension) const

    s32 Array_f64::get_stride() const
    {
      return stride;
    } // s32 Array_f64::get_stride() const

    void* Array_f64::get_rawDataPointer()
    {
      return rawDataPointer;
    } // void* Array_f64::get_rawDataPointer()

    const void* Array_f64::get_rawDataPointer() const
    {
      return rawDataPointer;
    } // const void* Array_f64::get_rawDataPointer() const

    void Array_f64::Initialize(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      this->useBoundaryFillPatterns = useBoundaryFillPatterns;

      if(!rawData) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "input data buffer is NULL");
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->rawDataPointer = rawData;

      const size_t extraBoundaryPatternBytes = useBoundaryFillPatterns ? static_cast<size_t>(HEADER_LENGTH) : 0;
      const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData)+extraBoundaryPatternBytes, MEMORY_ALIGNMENT) - extraBoundaryPatternBytes - reinterpret_cast<size_t>(rawData));
      const s32 requiredBytes = ComputeRequiredStride(numCols,useBoundaryFillPatterns)*numRows + extraAlignmentBytes;

      if(requiredBytes > dataLength) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->size[0] = numRows;
      this->size[1] = numCols;

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1], false);
        this->data = reinterpret_cast<f64*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes + HEADER_LENGTH );
        for(s32 y=0; y<size[0]; y++) {
          // Add the fill patterns just before the data on each line
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0] = FILL_PATTERN_START;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1] = FILL_PATTERN_START;

          // And also just after the data (including normal byte-alignment padding)
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0] = FILL_PATTERN_END;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1] = FILL_PATTERN_END;
        }
      } else {
        this->data = reinterpret_cast<f64*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
      }

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
      cvMatMirror = cv::Mat_<f64>(size[0], size[1], data, stride);
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    } // Array_f64::Initialize()

    // Set all the buffers and sizes to zero, to signal an invalid array
    void Array_f64::InvalidateArray()
    {
      this->size[0] = 0;
      this->size[1] = 0;
      this->stride = 0;
      this->data = NULL;
      this->rawDataPointer = NULL;
    } // void Array_f64::InvalidateArray()

    // Factory method to create an Array_f64 from the heap. The data of the returned Array_f64 must be freed by the user.
    // This is separate from the normal constructor, as Array_f64 objects are not supposed to manage memory
    Array_f64 AllocateArrayFromHeap_f64(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      const s32 requiredMemory = 64 + 2*MEMORY_ALIGNMENT + Array_f64::ComputeMinimumRequiredMemory(numRows, numCols, useBoundaryFillPatterns); // The required memory, plus a bit more

      Array_f64 mat(numRows, numCols, calloc(requiredMemory, 1), requiredMemory, useBoundaryFillPatterns);

      return mat;
    } // Array_f64 AllocateArrayFromHeap_f64(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)


    s32 Array_Point_s16::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0);
      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? (HEADER_LENGTH+FOOTER_LENGTH) : 0);
      return static_cast<s32>(RoundUp<size_t>(sizeof(Point_s16)*numCols, MEMORY_ALIGNMENT)) + extraBoundaryPatternBytes;
    } // s32 Array_Point_s16::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)

    s32 Array_Point_s16::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0);
      return numRows * Array_Point_s16::ComputeRequiredStride(numCols, useBoundaryFillPatterns);
    } // s32 Array_Point_s16::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)

    Array_Point_s16::Array_Point_s16()
    {
      InvalidateArray();
    } // Array_Point_s16::Array_Point_s16()

    // Constructor for a Array_Point_s16, pointing to user-allocated data. If the pointer to *data is not
    // aligned to MEMORY_ALIGNMENT, this Array_Point_s16 will start at the next aligned location.
    // Unfortunately, this is more restrictive than most matrix libraries, and as an example,
    // it may make it hard to convert from OpenCV to Array_Point_s16, though the reverse is trivial.
    Array_Point_s16::Array_Point_s16(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      Initialize(numRows,
        numCols,
        data,
        dataLength,
        useBoundaryFillPatterns);
    } // Array_Point_s16::Array_Point_s16(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)

    Array_Point_s16::Array_Point_s16(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0);

      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? static_cast<s32>(MEMORY_ALIGNMENT) : 0);
      const s32 numBytesRequested = numRows * this->stride + extraBoundaryPatternBytes;
      s32 numBytesAllocated = 0;

      void * allocatedBuffer = memory.Allocate(numBytesRequested, &numBytesAllocated);

      Initialize(numRows,
        numCols,
        reinterpret_cast<Point_s16*>(allocatedBuffer),
        numBytesAllocated,
        useBoundaryFillPatterns);
    } // Array_Point_s16::Array_Point_s16(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)

    // If this array or array2 are different sizes or uninitialized, then return false.
    bool Array_Point_s16::IsEqualSize(const Array_Point_s16 &array2) const
    {
      if(!this->IsValid())
        return false;

      if(!array2.IsValid())
        return false;

      if(this->get_size(0) != array2.get_size(0) || this->get_size(1) != array2.get_size(1))
        return false;

      return true;
    } // bool Array_Point_s16::IsEqualSize(const Array_Point_s16 &array2) const

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    // Returns a templated cv::Mat_ that shares the same buffer with this Array_Point_s16. No data is copied.
    cv::Mat_<Point_s16>& Array_Point_s16::get_CvMat_()
    {
      assert(this->IsValid());
      return cvMatMirror;
    } // cv::Mat_<Point_s16>& Array_Point_s16::get_CvMat_()
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

    // Print out the contents of this Array_Point_s16
    void Array_Point_s16::Print(const char * const variableName) const
    {
      assert(this->IsValid());

      printf("%s:\n", variableName);
      for(s32 y=0; y<size[0]; y++) {
        const Point_s16 * const rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          rowPointer[x].Print();
          printf(" ");
        }
        printf("\n");
      }
      printf("\n");
    } // void Array_Point_s16::Print() const

    // If the Array_Point_s16 was constructed with the useBoundaryFillPatterns=true, then
    // return if any memory was written out of bounds (via fill patterns at the
    // beginning and end).  If the Array_Point_s16 was not constructed with the
    // useBoundaryFillPatterns=true, this method always returns true
    bool Array_Point_s16::IsValid() const
    {
      if(this->rawDataPointer == NULL || this->data == NULL) {
        return false;
      }

      if(size[0] < 1 || size[1] < 1) {
        return false;
      }

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1],false);

        for(s32 y=0; y<size[0]; y++) {
          if((reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0]) != FILL_PATTERN_END ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1]) != FILL_PATTERN_END) {
              return false;
          }
        }

        return true;
      } else { // if(useBoundaryFillPatterns) {
        return true;
      } // if(useBoundaryFillPatterns) { ... else
    } // bool Array_Point_s16::IsValid() const

    // Set every element in the Array_Point_s16 to this value
    // Returns the number of values set
    s32 Array_Point_s16::Set(const Point_s16 value)
    {
      assert(this->IsValid());

      for(s32 y=0; y<size[0]; y++) {
        Point_s16 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          rowPointer[x] = value;
        }
      }

      return size[0]*size[1];
    } // s32 Array_Point_s16::Set(const Point_s16 value)

    // Similar to Matlab size(matrix, dimension), and dimension is in {0,1}
    s32 Array_Point_s16::get_size(s32 dimension) const
    {
      assert(dimension >= 0 && this->rawDataPointer != NULL && this->data != NULL);

      if(dimension > 1 || dimension < 0)
        return 0;

      return size[dimension];
    } // s32 Array_Point_s16::get_size(s32 dimension) const

    s32 Array_Point_s16::get_stride() const
    {
      return stride;
    } // s32 Array_Point_s16::get_stride() const

    void* Array_Point_s16::get_rawDataPointer()
    {
      return rawDataPointer;
    } // void* Array_Point_s16::get_rawDataPointer()

    const void* Array_Point_s16::get_rawDataPointer() const
    {
      return rawDataPointer;
    } // const void* Array_Point_s16::get_rawDataPointer() const

    void Array_Point_s16::Initialize(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      this->useBoundaryFillPatterns = useBoundaryFillPatterns;

      if(!rawData) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "input data buffer is NULL");
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->rawDataPointer = rawData;

      const size_t extraBoundaryPatternBytes = useBoundaryFillPatterns ? static_cast<size_t>(HEADER_LENGTH) : 0;
      const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData)+extraBoundaryPatternBytes, MEMORY_ALIGNMENT) - extraBoundaryPatternBytes - reinterpret_cast<size_t>(rawData));
      const s32 requiredBytes = ComputeRequiredStride(numCols,useBoundaryFillPatterns)*numRows + extraAlignmentBytes;

      if(requiredBytes > dataLength) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->size[0] = numRows;
      this->size[1] = numCols;

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1], false);
        this->data = reinterpret_cast<Point_s16*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes + HEADER_LENGTH );
        for(s32 y=0; y<size[0]; y++) {
          // Add the fill patterns just before the data on each line
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0] = FILL_PATTERN_START;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1] = FILL_PATTERN_START;

          // And also just after the data (including normal byte-alignment padding)
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0] = FILL_PATTERN_END;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1] = FILL_PATTERN_END;
        }
      } else {
        this->data = reinterpret_cast<Point_s16*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
      }

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
      cvMatMirror = cv::Mat_<Point_s16>(size[0], size[1], data, stride);
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    } // Array_Point_s16::Initialize()

    // Set all the buffers and sizes to zero, to signal an invalid array
    void Array_Point_s16::InvalidateArray()
    {
      this->size[0] = 0;
      this->size[1] = 0;
      this->stride = 0;
      this->data = NULL;
      this->rawDataPointer = NULL;
    } // void Array_Point_s16::InvalidateArray()

    // Factory method to create an Array_Point_s16 from the heap. The data of the returned Array_Point_s16 must be freed by the user.
    // This is separate from the normal constructor, as Array_Point_s16 objects are not supposed to manage memory
    Array_Point_s16 AllocateArrayFromHeap_Point_s16(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      const s32 requiredMemory = 64 + 2*MEMORY_ALIGNMENT + Array_Point_s16::ComputeMinimumRequiredMemory(numRows, numCols, useBoundaryFillPatterns); // The required memory, plus a bit more

      Array_Point_s16 mat(numRows, numCols, calloc(requiredMemory, 1), requiredMemory, useBoundaryFillPatterns);

      return mat;
    } // Array_Point_s16 AllocateArrayFromHeap_Point_s16(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)


    s32 Array_Point_f32::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0);
      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? (HEADER_LENGTH+FOOTER_LENGTH) : 0);
      return static_cast<s32>(RoundUp<size_t>(sizeof(Point_f32)*numCols, MEMORY_ALIGNMENT)) + extraBoundaryPatternBytes;
    } // s32 Array_Point_f32::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)

    s32 Array_Point_f32::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0);
      return numRows * Array_Point_f32::ComputeRequiredStride(numCols, useBoundaryFillPatterns);
    } // s32 Array_Point_f32::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)

    Array_Point_f32::Array_Point_f32()
    {
      InvalidateArray();
    } // Array_Point_f32::Array_Point_f32()

    // Constructor for a Array_Point_f32, pointing to user-allocated data. If the pointer to *data is not
    // aligned to MEMORY_ALIGNMENT, this Array_Point_f32 will start at the next aligned location.
    // Unfortunately, this is more restrictive than most matrix libraries, and as an example,
    // it may make it hard to convert from OpenCV to Array_Point_f32, though the reverse is trivial.
    Array_Point_f32::Array_Point_f32(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      Initialize(numRows,
        numCols,
        data,
        dataLength,
        useBoundaryFillPatterns);
    } // Array_Point_f32::Array_Point_f32(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)

    Array_Point_f32::Array_Point_f32(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0);

      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? static_cast<s32>(MEMORY_ALIGNMENT) : 0);
      const s32 numBytesRequested = numRows * this->stride + extraBoundaryPatternBytes;
      s32 numBytesAllocated = 0;

      void * allocatedBuffer = memory.Allocate(numBytesRequested, &numBytesAllocated);

      Initialize(numRows,
        numCols,
        reinterpret_cast<Point_f32*>(allocatedBuffer),
        numBytesAllocated,
        useBoundaryFillPatterns);
    } // Array_Point_f32::Array_Point_f32(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)

    // If this array or array2 are different sizes or uninitialized, then return false.
    bool Array_Point_f32::IsEqualSize(const Array_Point_f32 &array2) const
    {
      if(!this->IsValid())
        return false;

      if(!array2.IsValid())
        return false;

      if(this->get_size(0) != array2.get_size(0) || this->get_size(1) != array2.get_size(1))
        return false;

      return true;
    } // bool Array_Point_f32::IsEqualSize(const Array_Point_f32 &array2) const

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    // Returns a templated cv::Mat_ that shares the same buffer with this Array_Point_f32. No data is copied.
    cv::Mat_<Point_f32>& Array_Point_f32::get_CvMat_()
    {
      assert(this->IsValid());
      return cvMatMirror;
    } // cv::Mat_<Point_f32>& Array_Point_f32::get_CvMat_()
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

    // Print out the contents of this Array_Point_f32
    void Array_Point_f32::Print(const char * const variableName) const
    {
      assert(this->IsValid());

      printf("%s:\n", variableName);
      for(s32 y=0; y<size[0]; y++) {
        const Point_f32 * const rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          rowPointer[x].Print();
          printf(" ");
        }
        printf("\n");
      }
      printf("\n");
    } // void Array_Point_f32::Print() const

    // If the Array_Point_f32 was constructed with the useBoundaryFillPatterns=true, then
    // return if any memory was written out of bounds (via fill patterns at the
    // beginning and end).  If the Array_Point_f32 was not constructed with the
    // useBoundaryFillPatterns=true, this method always returns true
    bool Array_Point_f32::IsValid() const
    {
      if(this->rawDataPointer == NULL || this->data == NULL) {
        return false;
      }

      if(size[0] < 1 || size[1] < 1) {
        return false;
      }

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1],false);

        for(s32 y=0; y<size[0]; y++) {
          if((reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0]) != FILL_PATTERN_END ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1]) != FILL_PATTERN_END) {
              return false;
          }
        }

        return true;
      } else { // if(useBoundaryFillPatterns) {
        return true;
      } // if(useBoundaryFillPatterns) { ... else
    } // bool Array_Point_f32::IsValid() const

    // Set every element in the Array_Point_f32 to this value
    // Returns the number of values set
    s32 Array_Point_f32::Set(const Point_f32 value)
    {
      assert(this->IsValid());

      for(s32 y=0; y<size[0]; y++) {
        Point_f32 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          rowPointer[x] = value;
        }
      }

      return size[0]*size[1];
    } // s32 Array_Point_f32::Set(const Point_f32 value)

    // Similar to Matlab size(matrix, dimension), and dimension is in {0,1}
    s32 Array_Point_f32::get_size(s32 dimension) const
    {
      assert(dimension >= 0 && this->rawDataPointer != NULL && this->data != NULL);

      if(dimension > 1 || dimension < 0)
        return 0;

      return size[dimension];
    } // s32 Array_Point_f32::get_size(s32 dimension) const

    s32 Array_Point_f32::get_stride() const
    {
      return stride;
    } // s32 Array_Point_f32::get_stride() const

    void* Array_Point_f32::get_rawDataPointer()
    {
      return rawDataPointer;
    } // void* Array_Point_f32::get_rawDataPointer()

    const void* Array_Point_f32::get_rawDataPointer() const
    {
      return rawDataPointer;
    } // const void* Array_Point_f32::get_rawDataPointer() const

    void Array_Point_f32::Initialize(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      this->useBoundaryFillPatterns = useBoundaryFillPatterns;

      if(!rawData) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "input data buffer is NULL");
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->rawDataPointer = rawData;

      const size_t extraBoundaryPatternBytes = useBoundaryFillPatterns ? static_cast<size_t>(HEADER_LENGTH) : 0;
      const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData)+extraBoundaryPatternBytes, MEMORY_ALIGNMENT) - extraBoundaryPatternBytes - reinterpret_cast<size_t>(rawData));
      const s32 requiredBytes = ComputeRequiredStride(numCols,useBoundaryFillPatterns)*numRows + extraAlignmentBytes;

      if(requiredBytes > dataLength) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->size[0] = numRows;
      this->size[1] = numCols;

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1], false);
        this->data = reinterpret_cast<Point_f32*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes + HEADER_LENGTH );
        for(s32 y=0; y<size[0]; y++) {
          // Add the fill patterns just before the data on each line
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0] = FILL_PATTERN_START;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1] = FILL_PATTERN_START;

          // And also just after the data (including normal byte-alignment padding)
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0] = FILL_PATTERN_END;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1] = FILL_PATTERN_END;
        }
      } else {
        this->data = reinterpret_cast<Point_f32*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
      }

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
      cvMatMirror = cv::Mat_<Point_f32>(size[0], size[1], data, stride);
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    } // Array_Point_f32::Initialize()

    // Set all the buffers and sizes to zero, to signal an invalid array
    void Array_Point_f32::InvalidateArray()
    {
      this->size[0] = 0;
      this->size[1] = 0;
      this->stride = 0;
      this->data = NULL;
      this->rawDataPointer = NULL;
    } // void Array_Point_f32::InvalidateArray()

    // Factory method to create an Array_Point_f32 from the heap. The data of the returned Array_Point_f32 must be freed by the user.
    // This is separate from the normal constructor, as Array_Point_f32 objects are not supposed to manage memory
    Array_Point_f32 AllocateArrayFromHeap_Point_f32(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      const s32 requiredMemory = 64 + 2*MEMORY_ALIGNMENT + Array_Point_f32::ComputeMinimumRequiredMemory(numRows, numCols, useBoundaryFillPatterns); // The required memory, plus a bit more

      Array_Point_f32 mat(numRows, numCols, calloc(requiredMemory, 1), requiredMemory, useBoundaryFillPatterns);

      return mat;
    } // Array_Point_f32 AllocateArrayFromHeap_Point_f32(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)


    s32 Array_Point_f64::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0);
      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? (HEADER_LENGTH+FOOTER_LENGTH) : 0);
      return static_cast<s32>(RoundUp<size_t>(sizeof(Point_f64)*numCols, MEMORY_ALIGNMENT)) + extraBoundaryPatternBytes;
    } // s32 Array_Point_f64::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)

    s32 Array_Point_f64::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0);
      return numRows * Array_Point_f64::ComputeRequiredStride(numCols, useBoundaryFillPatterns);
    } // s32 Array_Point_f64::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)

    Array_Point_f64::Array_Point_f64()
    {
      InvalidateArray();
    } // Array_Point_f64::Array_Point_f64()

    // Constructor for a Array_Point_f64, pointing to user-allocated data. If the pointer to *data is not
    // aligned to MEMORY_ALIGNMENT, this Array_Point_f64 will start at the next aligned location.
    // Unfortunately, this is more restrictive than most matrix libraries, and as an example,
    // it may make it hard to convert from OpenCV to Array_Point_f64, though the reverse is trivial.
    Array_Point_f64::Array_Point_f64(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      Initialize(numRows,
        numCols,
        data,
        dataLength,
        useBoundaryFillPatterns);
    } // Array_Point_f64::Array_Point_f64(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)

    Array_Point_f64::Array_Point_f64(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)
      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))
    {
      assert(numCols > 0 && numRows > 0);

      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? static_cast<s32>(MEMORY_ALIGNMENT) : 0);
      const s32 numBytesRequested = numRows * this->stride + extraBoundaryPatternBytes;
      s32 numBytesAllocated = 0;

      void * allocatedBuffer = memory.Allocate(numBytesRequested, &numBytesAllocated);

      Initialize(numRows,
        numCols,
        reinterpret_cast<Point_f64*>(allocatedBuffer),
        numBytesAllocated,
        useBoundaryFillPatterns);
    } // Array_Point_f64::Array_Point_f64(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)

    // If this array or array2 are different sizes or uninitialized, then return false.
    bool Array_Point_f64::IsEqualSize(const Array_Point_f64 &array2) const
    {
      if(!this->IsValid())
        return false;

      if(!array2.IsValid())
        return false;

      if(this->get_size(0) != array2.get_size(0) || this->get_size(1) != array2.get_size(1))
        return false;

      return true;
    } // bool Array_Point_f64::IsEqualSize(const Array_Point_f64 &array2) const

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    // Returns a templated cv::Mat_ that shares the same buffer with this Array_Point_f64. No data is copied.
    cv::Mat_<Point_f64>& Array_Point_f64::get_CvMat_()
    {
      assert(this->IsValid());
      return cvMatMirror;
    } // cv::Mat_<Point_f64>& Array_Point_f64::get_CvMat_()
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

    // Print out the contents of this Array_Point_f64
    void Array_Point_f64::Print(const char * const variableName) const
    {
      assert(this->IsValid());

      printf("%s:\n", variableName);
      for(s32 y=0; y<size[0]; y++) {
        const Point_f64 * const rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          rowPointer[x].Print();
          printf(" ");
        }
        printf("\n");
      }
      printf("\n");
    } // void Array_Point_f64::Print() const

    // If the Array_Point_f64 was constructed with the useBoundaryFillPatterns=true, then
    // return if any memory was written out of bounds (via fill patterns at the
    // beginning and end).  If the Array_Point_f64 was not constructed with the
    // useBoundaryFillPatterns=true, this method always returns true
    bool Array_Point_f64::IsValid() const
    {
      if(this->rawDataPointer == NULL || this->data == NULL) {
        return false;
      }

      if(size[0] < 1 || size[1] < 1) {
        return false;
      }

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1],false);

        for(s32 y=0; y<size[0]; y++) {
          if((reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1]) != FILL_PATTERN_START ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0]) != FILL_PATTERN_END ||
            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1]) != FILL_PATTERN_END) {
              return false;
          }
        }

        return true;
      } else { // if(useBoundaryFillPatterns) {
        return true;
      } // if(useBoundaryFillPatterns) { ... else
    } // bool Array_Point_f64::IsValid() const

    // Set every element in the Array_Point_f64 to this value
    // Returns the number of values set
    s32 Array_Point_f64::Set(const Point_f64 value)
    {
      assert(this->IsValid());

      for(s32 y=0; y<size[0]; y++) {
        Point_f64 * restrict rowPointer = Pointer(y, 0);
        for(s32 x=0; x<size[1]; x++) {
          rowPointer[x] = value;
        }
      }

      return size[0]*size[1];
    } // s32 Array_Point_f64::Set(const Point_f64 value)

    // Similar to Matlab size(matrix, dimension), and dimension is in {0,1}
    s32 Array_Point_f64::get_size(s32 dimension) const
    {
      assert(dimension >= 0 && this->rawDataPointer != NULL && this->data != NULL);

      if(dimension > 1 || dimension < 0)
        return 0;

      return size[dimension];
    } // s32 Array_Point_f64::get_size(s32 dimension) const

    s32 Array_Point_f64::get_stride() const
    {
      return stride;
    } // s32 Array_Point_f64::get_stride() const

    void* Array_Point_f64::get_rawDataPointer()
    {
      return rawDataPointer;
    } // void* Array_Point_f64::get_rawDataPointer()

    const void* Array_Point_f64::get_rawDataPointer() const
    {
      return rawDataPointer;
    } // const void* Array_Point_f64::get_rawDataPointer() const

    void Array_Point_f64::Initialize(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const bool useBoundaryFillPatterns)
    {
      assert(numCols > 0 && numRows > 0 && dataLength > 0);

      this->useBoundaryFillPatterns = useBoundaryFillPatterns;

      if(!rawData) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "input data buffer is NULL");
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->rawDataPointer = rawData;

      const size_t extraBoundaryPatternBytes = useBoundaryFillPatterns ? static_cast<size_t>(HEADER_LENGTH) : 0;
      const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData)+extraBoundaryPatternBytes, MEMORY_ALIGNMENT) - extraBoundaryPatternBytes - reinterpret_cast<size_t>(rawData));
      const s32 requiredBytes = ComputeRequiredStride(numCols,useBoundaryFillPatterns)*numRows + extraAlignmentBytes;

      if(requiredBytes > dataLength) {
#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        DASError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH
        InvalidateArray();
        return;
      }

      this->size[0] = numRows;
      this->size[1] = numCols;

      if(useBoundaryFillPatterns) {
        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1], false);
        this->data = reinterpret_cast<Point_f64*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes + HEADER_LENGTH );
        for(s32 y=0; y<size[0]; y++) {
          // Add the fill patterns just before the data on each line
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0] = FILL_PATTERN_START;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1] = FILL_PATTERN_START;

          // And also just after the data (including normal byte-alignment padding)
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0] = FILL_PATTERN_END;
          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1] = FILL_PATTERN_END;
        }
      } else {
        this->data = reinterpret_cast<Point_f64*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
      }

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
      cvMatMirror = cv::Mat_<Point_f64>(size[0], size[1], data, stride);
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    } // Array_Point_f64::Initialize()

    // Set all the buffers and sizes to zero, to signal an invalid array
    void Array_Point_f64::InvalidateArray()
    {
      this->size[0] = 0;
      this->size[1] = 0;
      this->stride = 0;
      this->data = NULL;
      this->rawDataPointer = NULL;
    } // void Array_Point_f64::InvalidateArray()

    // Factory method to create an Array_Point_f64 from the heap. The data of the returned Array_Point_f64 must be freed by the user.
    // This is separate from the normal constructor, as Array_Point_f64 objects are not supposed to manage memory
    Array_Point_f64 AllocateArrayFromHeap_Point_f64(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)
    {
      const s32 requiredMemory = 64 + 2*MEMORY_ALIGNMENT + Array_Point_f64::ComputeMinimumRequiredMemory(numRows, numCols, useBoundaryFillPatterns); // The required memory, plus a bit more

      Array_Point_f64 mat(numRows, numCols, calloc(requiredMemory, 1), requiredMemory, useBoundaryFillPatterns);

      return mat;
    } // Array_Point_f64 AllocateArrayFromHeap_Point_f64(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)


  } // namespace Embedded
} // namespace Anki