/*









This file was automatically generated by the python script generateFixedLengthList_cpp.py. Rather than editing this file, edit that script, then run "python generateFixedLengthList_cpp.py".









*/

#include "anki/embeddedCommon.h"

namespace Anki
{
  namespace Embedded
  {
    FixedLengthList_Point_s16::FixedLengthList_Point_s16()
      : Array_Point_s16(), capacityUsed(0)
    {
    } // FixedLengthList_Point_s16::FixedLengthList_Point_s16()

    FixedLengthList_Point_s16::FixedLengthList_Point_s16(s32 maximumSize, void * data, s32 dataLength, bool useBoundaryFillPatterns)
      : Array_Point_s16(1, maximumSize, data, dataLength, useBoundaryFillPatterns), capacityUsed(0)
    {
    } // FixedLengthList_Point_s16::FixedLengthList_Point_s16(s32 maximumSize, void * data, s32 dataLength, bool useBoundaryFillPatterns)

    FixedLengthList_Point_s16::FixedLengthList_Point_s16(s32 maximumSize, MemoryStack &memory, bool useBoundaryFillPatterns)
      : Array_Point_s16(1, maximumSize, memory, useBoundaryFillPatterns), capacityUsed(0)
    {
    } // FixedLengthList_Point_s16::FixedLengthList_Point_s16(s32 maximumSize, MemoryStack &memory, bool useBoundaryFillPatterns)

    bool FixedLengthList_Point_s16::IsValid() const
    {
      if(capacityUsed > this->get_maximumSize()) {
        return false;
      }

      return Array_Point_s16::IsValid();
    } // bool FixedLengthList_Point_s16::IsValid() const

    Result FixedLengthList_Point_s16::PushBack(const Point_s16 &value)
    {
      if(capacityUsed >= this->get_maximumSize()) {
        return RESULT_FAIL;
      }

      *this->Pointer(capacityUsed) = value;
      capacityUsed++;

      return RESULT_OK;
    } // Result FixedLengthList_Point_s16::PushBack(const Point_s16 &value)

    Point_s16 FixedLengthList_Point_s16::PopBack()
    {
      if(capacityUsed == 0) {
        return *this->Pointer(0);
      }

      const Point_s16 value = *this->Pointer(capacityUsed-1);
      capacityUsed--;

      return value;
    } // Point_s16 FixedLengthList_Point_s16::PopBack()

    void FixedLengthList_Point_s16::Clear()
    {
      this->capacityUsed = 0;
    } // void FixedLengthList_Point_s16::Clear()

    s32 FixedLengthList_Point_s16::get_maximumSize() const
    {
      return Array_Point_s16::get_size(1);
    } // s32 FixedLengthList_Point_s16::get_maximumSize() const

    s32 FixedLengthList_Point_s16::get_size() const
    {
      return capacityUsed;
    } // s32 FixedLengthList_Point_s16::get_size() const

    FixedLengthList_Point_s16 AllocateFixedLengthListFromHeap_Point_s16(s32 maximumSize, bool useBoundaryFillPatterns)
    {
      // const s32 stride = FixedLengthList_Point_s16::ComputeRequiredStride(maximumSize, useBoundaryFillPatterns);
      const s32 requiredMemory = 64 + 2*MEMORY_ALIGNMENT + Array_Point_s16::ComputeMinimumRequiredMemory(1, maximumSize, useBoundaryFillPatterns); // The required memory, plus a bit more

      FixedLengthList_Point_s16 mat(maximumSize, calloc(requiredMemory, 1), requiredMemory, useBoundaryFillPatterns);

      return mat;
    } // FixedLengthList_Point_s16 AllocateFixedLengthListFromHeap_Point_s16(s32 maximumSize, bool useBoundaryFillPatterns)


    FixedLengthList_Point_f32::FixedLengthList_Point_f32()
      : Array_Point_f32(), capacityUsed(0)
    {
    } // FixedLengthList_Point_f32::FixedLengthList_Point_f32()

    FixedLengthList_Point_f32::FixedLengthList_Point_f32(s32 maximumSize, void * data, s32 dataLength, bool useBoundaryFillPatterns)
      : Array_Point_f32(1, maximumSize, data, dataLength, useBoundaryFillPatterns), capacityUsed(0)
    {
    } // FixedLengthList_Point_f32::FixedLengthList_Point_f32(s32 maximumSize, void * data, s32 dataLength, bool useBoundaryFillPatterns)

    FixedLengthList_Point_f32::FixedLengthList_Point_f32(s32 maximumSize, MemoryStack &memory, bool useBoundaryFillPatterns)
      : Array_Point_f32(1, maximumSize, memory, useBoundaryFillPatterns), capacityUsed(0)
    {
    } // FixedLengthList_Point_f32::FixedLengthList_Point_f32(s32 maximumSize, MemoryStack &memory, bool useBoundaryFillPatterns)

    bool FixedLengthList_Point_f32::IsValid() const
    {
      if(capacityUsed > this->get_maximumSize()) {
        return false;
      }

      return Array_Point_f32::IsValid();
    } // bool FixedLengthList_Point_f32::IsValid() const

    Result FixedLengthList_Point_f32::PushBack(const Point_f32 &value)
    {
      if(capacityUsed >= this->get_maximumSize()) {
        return RESULT_FAIL;
      }

      *this->Pointer(capacityUsed) = value;
      capacityUsed++;

      return RESULT_OK;
    } // Result FixedLengthList_Point_f32::PushBack(const Point_f32 &value)

    Point_f32 FixedLengthList_Point_f32::PopBack()
    {
      if(capacityUsed == 0) {
        return *this->Pointer(0);
      }

      const Point_f32 value = *this->Pointer(capacityUsed-1);
      capacityUsed--;

      return value;
    } // Point_f32 FixedLengthList_Point_f32::PopBack()

    void FixedLengthList_Point_f32::Clear()
    {
      this->capacityUsed = 0;
    } // void FixedLengthList_Point_f32::Clear()

    s32 FixedLengthList_Point_f32::get_maximumSize() const
    {
      return Array_Point_f32::get_size(1);
    } // s32 FixedLengthList_Point_f32::get_maximumSize() const

    s32 FixedLengthList_Point_f32::get_size() const
    {
      return capacityUsed;
    } // s32 FixedLengthList_Point_f32::get_size() const

    FixedLengthList_Point_f32 AllocateFixedLengthListFromHeap_Point_f32(s32 maximumSize, bool useBoundaryFillPatterns)
    {
      // const s32 stride = FixedLengthList_Point_f32::ComputeRequiredStride(maximumSize, useBoundaryFillPatterns);
      const s32 requiredMemory = 64 + 2*MEMORY_ALIGNMENT + Array_Point_f32::ComputeMinimumRequiredMemory(1, maximumSize, useBoundaryFillPatterns); // The required memory, plus a bit more

      FixedLengthList_Point_f32 mat(maximumSize, calloc(requiredMemory, 1), requiredMemory, useBoundaryFillPatterns);

      return mat;
    } // FixedLengthList_Point_f32 AllocateFixedLengthListFromHeap_Point_f32(s32 maximumSize, bool useBoundaryFillPatterns)


    FixedLengthList_Point_f64::FixedLengthList_Point_f64()
      : Array_Point_f64(), capacityUsed(0)
    {
    } // FixedLengthList_Point_f64::FixedLengthList_Point_f64()

    FixedLengthList_Point_f64::FixedLengthList_Point_f64(s32 maximumSize, void * data, s32 dataLength, bool useBoundaryFillPatterns)
      : Array_Point_f64(1, maximumSize, data, dataLength, useBoundaryFillPatterns), capacityUsed(0)
    {
    } // FixedLengthList_Point_f64::FixedLengthList_Point_f64(s32 maximumSize, void * data, s32 dataLength, bool useBoundaryFillPatterns)

    FixedLengthList_Point_f64::FixedLengthList_Point_f64(s32 maximumSize, MemoryStack &memory, bool useBoundaryFillPatterns)
      : Array_Point_f64(1, maximumSize, memory, useBoundaryFillPatterns), capacityUsed(0)
    {
    } // FixedLengthList_Point_f64::FixedLengthList_Point_f64(s32 maximumSize, MemoryStack &memory, bool useBoundaryFillPatterns)

    bool FixedLengthList_Point_f64::IsValid() const
    {
      if(capacityUsed > this->get_maximumSize()) {
        return false;
      }

      return Array_Point_f64::IsValid();
    } // bool FixedLengthList_Point_f64::IsValid() const

    Result FixedLengthList_Point_f64::PushBack(const Point_f64 &value)
    {
      if(capacityUsed >= this->get_maximumSize()) {
        return RESULT_FAIL;
      }

      *this->Pointer(capacityUsed) = value;
      capacityUsed++;

      return RESULT_OK;
    } // Result FixedLengthList_Point_f64::PushBack(const Point_f64 &value)

    Point_f64 FixedLengthList_Point_f64::PopBack()
    {
      if(capacityUsed == 0) {
        return *this->Pointer(0);
      }

      const Point_f64 value = *this->Pointer(capacityUsed-1);
      capacityUsed--;

      return value;
    } // Point_f64 FixedLengthList_Point_f64::PopBack()

    void FixedLengthList_Point_f64::Clear()
    {
      this->capacityUsed = 0;
    } // void FixedLengthList_Point_f64::Clear()

    s32 FixedLengthList_Point_f64::get_maximumSize() const
    {
      return Array_Point_f64::get_size(1);
    } // s32 FixedLengthList_Point_f64::get_maximumSize() const

    s32 FixedLengthList_Point_f64::get_size() const
    {
      return capacityUsed;
    } // s32 FixedLengthList_Point_f64::get_size() const

    FixedLengthList_Point_f64 AllocateFixedLengthListFromHeap_Point_f64(s32 maximumSize, bool useBoundaryFillPatterns)
    {
      // const s32 stride = FixedLengthList_Point_f64::ComputeRequiredStride(maximumSize, useBoundaryFillPatterns);
      const s32 requiredMemory = 64 + 2*MEMORY_ALIGNMENT + Array_Point_f64::ComputeMinimumRequiredMemory(1, maximumSize, useBoundaryFillPatterns); // The required memory, plus a bit more

      FixedLengthList_Point_f64 mat(maximumSize, calloc(requiredMemory, 1), requiredMemory, useBoundaryFillPatterns);

      return mat;
    } // FixedLengthList_Point_f64 AllocateFixedLengthListFromHeap_Point_f64(s32 maximumSize, bool useBoundaryFillPatterns)


  } // namespace Embedded
} // namespace Anki