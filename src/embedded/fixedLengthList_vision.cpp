/*









This file was automatically generated by the python script generateFixedLengthList_vision_cpp.py. Rather than editing this file, edit that script, then run "python generateFixedLengthList_vision_cpp.py".









*/

#include "anki/embeddedVision.h"

namespace Anki
{
  namespace Embedded
  {
    FixedLengthList_ConnectedComponentSegment::FixedLengthList_ConnectedComponentSegment()
      : Array_ConnectedComponentSegment(), capacityUsed(0)
    {
    } // FixedLengthList_ConnectedComponentSegment::FixedLengthList_ConnectedComponentSegment()

    FixedLengthList_ConnectedComponentSegment::FixedLengthList_ConnectedComponentSegment(s32 maximumSize, void * data, s32 dataLength, bool useBoundaryFillPatterns)
      : Array_ConnectedComponentSegment(1, maximumSize, data, dataLength, useBoundaryFillPatterns), capacityUsed(0)
    {
    } // FixedLengthList_ConnectedComponentSegment::FixedLengthList_ConnectedComponentSegment(s32 maximumSize, void * data, s32 dataLength, bool useBoundaryFillPatterns)

    FixedLengthList_ConnectedComponentSegment::FixedLengthList_ConnectedComponentSegment(s32 maximumSize, MemoryStack &memory, bool useBoundaryFillPatterns)
      : Array_ConnectedComponentSegment(1, maximumSize, memory, useBoundaryFillPatterns), capacityUsed(0)
    {
    } // FixedLengthList_ConnectedComponentSegment::FixedLengthList_ConnectedComponentSegment(s32 maximumSize, MemoryStack &memory, bool useBoundaryFillPatterns)

    bool FixedLengthList_ConnectedComponentSegment::IsValid() const
    {
      if(capacityUsed > this->get_maximumSize()) {
        return false;
      }

      return Array_ConnectedComponentSegment::IsValid();
    } // bool FixedLengthList_ConnectedComponentSegment::IsValid() const

    Result FixedLengthList_ConnectedComponentSegment::PushBack(const ConnectedComponentSegment &value)
    {
      if(capacityUsed >= this->get_maximumSize()) {
        return RESULT_FAIL;
      }

      *this->Pointer(capacityUsed) = value;
      capacityUsed++;

      return RESULT_OK;
    } // Result FixedLengthList_ConnectedComponentSegment::PushBack(const ConnectedComponentSegment &value)

    ConnectedComponentSegment FixedLengthList_ConnectedComponentSegment::PopBack()
    {
      if(capacityUsed == 0) {
        return *this->Pointer(0);
      }

      const ConnectedComponentSegment value = *this->Pointer(capacityUsed-1);
      capacityUsed--;

      return value;
    } // ConnectedComponentSegment FixedLengthList_ConnectedComponentSegment::PopBack()

    void FixedLengthList_ConnectedComponentSegment::Clear()
    {
      this->capacityUsed = 0;
    } // void FixedLengthList_ConnectedComponentSegment::Clear()

    // Does this ever need to be declared explicitly?
    /*FixedLengthList_ConnectedComponentSegment& FixedLengthList_ConnectedComponentSegment::operator= (const FixedLengthList_ConnectedComponentSegment & rightHandSide)
    {
      Array_ConnectedComponentSegment::operator=(static_cast<Array_ConnectedComponentSegment>(rightHandSide));
      this->capacityUsed = rightHandSide.capacityUsed;

      return *this;
    }*/ // FixedLengthList_ConnectedComponentSegment& FixedLengthList_ConnectedComponentSegment::operator= (const FixedLengthList_ConnectedComponentSegment & rightHandSide)

    s32 FixedLengthList_ConnectedComponentSegment::get_maximumSize() const
    {
      return Array_ConnectedComponentSegment::get_size(1);
    } // s32 FixedLengthList_ConnectedComponentSegment::get_maximumSize() const

    s32 FixedLengthList_ConnectedComponentSegment::get_size() const
    {
      return capacityUsed;
    } // s32 FixedLengthList_ConnectedComponentSegment::get_size() const

    // Attempt to set the size to newSize. Returns the value that was actually set.
    s32 FixedLengthList_ConnectedComponentSegment::set_size(s32 newSize)
    {
      this->capacityUsed = MIN(this->get_maximumSize(), MAX(0,newSize));
      return this->capacityUsed;
    } // s32 FixedLengthList_ConnectedComponentSegment::set_size(s32 newSize)

    FixedLengthList_ConnectedComponentSegment AllocateFixedLengthListFromHeap_ConnectedComponentSegment(s32 maximumSize, bool useBoundaryFillPatterns)
    {
      // const s32 stride = FixedLengthList_ConnectedComponentSegment::ComputeRequiredStride(maximumSize, useBoundaryFillPatterns);
      const s32 requiredMemory = 64 + 2*MEMORY_ALIGNMENT + Array_ConnectedComponentSegment::ComputeMinimumRequiredMemory(1, maximumSize, useBoundaryFillPatterns); // The required memory, plus a bit more

      FixedLengthList_ConnectedComponentSegment mat(maximumSize, calloc(requiredMemory, 1), requiredMemory, useBoundaryFillPatterns);

      return mat;
    } // FixedLengthList_ConnectedComponentSegment AllocateFixedLengthListFromHeap_ConnectedComponentSegment(s32 maximumSize, bool useBoundaryFillPatterns)

    // Print out the contents of this FixedLengthList_ConnectedComponentSegment
    Result FixedLengthList_ConnectedComponentSegment::Print(const char * const variableName, const s32 minIndex, const s32 maxIndex) const
    {
      return Array_ConnectedComponentSegment::Print(variableName, 0, 0, MAX(0,minIndex), MIN(maxIndex, this->get_size()-1));
    } // Result FixedLengthList_ConnectedComponentSegment::Print(const char * const variableName, const s32 minIndex, const s32 maxIndex) const


  } // namespace Embedded
} // namespace Anki