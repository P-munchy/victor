#!/usr/bin/env python2

"""
* File: plotBehaviors.py
*
* Author: ross
* Created: Jan 4 2017
*
* Description: Plots a directed graph of behaviors, informed by
*              recursive calls to the IBehavior::GetAllDelegates() method. For
*              this, the script looks for a behavior_transitions.txt file
*              that is output from the test_engine unit test.
*              Supply a behavior name as an arg for a graph of just that behavior
*
* Copyright: Anki, Inc. 2018
*
**/

"""

import os
import sys
import tempfile as tmp
import subprocess
import functools
import graphviz as gv
import argparse

kShowDisconnectedNodes = True
kRenderEngine = 'neato'

def extractTree( inputEdges, root, nodes=None, edges=None, depth=0 ):
  """ Recursively pull out tree from root. Only supply first 2 args
  """

  if depth > 100:
    print('WARNING: depth ({0}) unexpectedly large'.format(depth))
    return nodes,edges
  
  if nodes is None:
    nodes = []
    edges = {}
  if root not in nodes:
    nodes.append(root)
  if root in inputEdges:
    for outNode in inputEdges[root]:
      if root not in edges:
        edges[root] = []
      edges[root].append( outNode )
      extractTree( inputEdges, outNode, nodes, edges, 1 + depth )
  return nodes, edges


def makeGraph( nodes, edges, ext, startNodes ):
  """ Gathers nodes and edges into a graphviz graph"""
  digraph = functools.partial(gv.Digraph, format=ext, engine=kRenderEngine)
  G = digraph()

  for node in nodes:
    G.attr('node', shape='box', fillcolor='white', fontcolor='black')
    if node in startNodes:
      G.attr('node', shape='box', fillcolor='red', fontcolor='white', style='filled')
    G.node( node )
  for node, edgeList in edges.iteritems():
    for node2 in edgeList:
      G.edge( node, node2 )

  G.attr(overlap='false',splines='true')

  return G

def tryLoadCpp(filename, nodes, edges):
  """ If the cpp dump file exists, parse it 
  todo: anonymousBehaviors?
  """
  if not os.path.isfile(filename):
    return
  with open( filename, 'r' ) as f:
    content = [x.strip() for x in f.readlines()]
  for line in content:
    segs = line.split(' ')
    if len(segs) == 2:
      nodeId = segs[0]
      outId = segs[1]
      if nodeId not in nodes:
        nodes.append(nodeId)
      if nodeId not in edges:
        edges[nodeId] = []
      if outId not in edges[nodeId]:
        edges[nodeId].append(outId)
      if outId not in nodes:
        nodes.append(outId)

def hasGraphViz():
  fnull = open(os.devnull, 'w')
  try:
    subprocess.check_call('neato -V',shell=True, stdout=fnull, stderr=subprocess.STDOUT)
    fnull.close()
    return True
  except:
    fnull.close()
    return False

def main():

  if not hasGraphViz():
    print('This script requires GraphViz. Run "brew install graphviz" and try again')
    sys.exit(1)

  parser = argparse.ArgumentParser(description='Draws a graph of Victor behaviors.')
  parser.add_argument('-r', '--root', action="store", dest='rootBehavior', metavar='ROOTNODE',
                      help='draw a tree from this root node, ignoring other nodes')
  parser.add_argument('-o', '--output', action="store", dest='outputFilename', metavar='OUTPUTFILE',
                      help='output file (extension determines filetype)')
  parser.add_argument('inputFilename', metavar='INPUTFILE',
                      help='the file generated by the unit test that dumps all behaviors')
  

  args = parser.parse_args()

  inputFilename = args.inputFilename
  outputFilename = args.outputFilename
  rootBehavior = args.rootBehavior

  if not os.path.isfile(inputFilename):
    print('Cannot find input file ' + inputFilename)
    sys.exit(1)
  if outputFilename:
    if len(outputFilename) < 3 or '.' not in outputFilename:
      print('Cannot determine output format from extension')
      sys.exit(1)

  nodes = []
  edges = {}

  tryLoadCpp( inputFilename, nodes, edges )

  # if we're only showing a partial tree in the graph, find that tree
  
  if rootBehavior:
    if rootBehavior not in edges:
      print( 'Root {0} not found in edges (if it exists, does it have outbound edges?)'.format(rootBehavior) )
      sys.exit(1)
    nodes, edges = extractTree( edges, rootBehavior )

  # makes the job of graphviz easier if unconnected nodes are ignored

  if not kShowDisconnectedNodes:
    # remove nodes with no edges
    nodes = [node for node in nodes if node in edges]

  # identify source nodes

  nonStartNodes = set()
  for node, edgeList in edges.iteritems():
    for outNode in edgeList:
      nonStartNodes.add(outNode)
  startNodes = [x for x in nodes if x not in nonStartNodes]

  # render 

  ext = 'pdf'
  if outputFilename:
    idx = outputFilename.rindex('.') + 1
    ext = outputFilename[idx:]

  G = makeGraph( nodes, edges, ext, startNodes )

  if outputFilename:
    fname = outputFilename
  else:
    tempFile = tmp.NamedTemporaryFile(delete=False)
    fname = tempFile.name + '.' + ext

  writeSuccess = False
  unflattenRet = 0

  try:
    with tmp.NamedTemporaryFile() as dotFile:
      dotFile.write( str(G) )
      dotFile.flush()

      # run unflatted on it to avoid a (SUPER WIDE by short) aspect ratio
      cmd = 'unflatten -c 2 {0} | {1} -T{2} -o {3}'.format(dotFile.name, kRenderEngine, ext, fname)
      
      unflattenRet = subprocess.call(cmd, shell=True)
      writeSuccess = (unflattenRet == 0)

      dotFile.close()
  finally:
    if not outputFilename:
      tempFile.close()

  if writeSuccess and not outputFilename:
    print( 'Output saved to {0}'.format( fname ) )
  elif not writeSuccess:
    print('Error saving file ' + fname)
    sys.exit(unflattenRet)
  
if __name__ == "__main__":
  main()
