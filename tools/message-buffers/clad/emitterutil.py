"""
Shared __main__ method functionality for emitters.
"""

from __future__ import absolute_import
from __future__ import print_function

import argparse
import contextlib
import errno
import inspect
import os
import pipes
import re
import sys
import textwrap

from . import clad

def get_included_file(file, suffix):
    return file[:file.find('.', max(file.find('/'), 0))] + suffix

@contextlib.contextmanager
def _disable_with(context):
    yield context

_py3 = sys.version_info[0] >= 3
def open_linux(filename, mode):
    if _py3:
        return open(filename, mode, newline='\n')
    else:
        return open(filename, '{mode}b'.format(mode=mode))

def _get_input(options):
    if options.input_file != '-':
        real_path = os.path.join(options.input_directory, options.input_file)
        return open(real_path, 'r')
    else:
        return _disable_with(sys.stdin)

def get_output_file(options, suffix):
    if options.output_file:
        if options.output_file == '-':
            return '-'
        else:
            return options.output_file
    elif options.input_file != '-':
        return get_included_file(options.input_file, suffix)
    else:
        return '-'

def _get_output(output_directory, output_file):
    if output_directory != '-' and output_file != '-':
        real_path = os.path.join(output_directory, output_file)
        
        mkdir_p(os.path.dirname(real_path))
        return open_linux(real_path, 'w')
    else:
        return _disable_with(sys.stdout)

def create_file(path):
    "Creates an empty file unless it already exists, in which case it does nothing."
    if not os.path.exists(path):
        with open(path, 'a'):
            pass

# See: http://stackoverflow.com/a/600612/4093018
def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as exc: # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else: raise

def make_path_relative(path, start=None):
    "Does os.path.relpath, first resolving to an absolute path."
    if start:
        start = os.path.normpath(os.path.abspath(start))
    path = os.path.normpath(os.path.abspath(path))
    return os.path.relpath(path, start)
    
def make_path_portable(path):
    "Makes a path as portable if possible. Can't fix absolute paths."
    path = os.path.normpath(path)
    if os.path.isabs(path):
        return path 
    return path.replace('\\', '/')

def get_comment_lines(options, language):
    if options.input_file != '-':
        source = options.input_file
    else:
        source = '<stdin>'
    command_line = ' '.join(pipes.quote(arg) for arg in sys.argv)
    return [
        'Autogenerated {language} message buffer code.'.format(language=language),
        'Source: {source}'.format(source=source),
        'Full command line: {command_line}'.format(command_line=command_line)
    ]
    
#http://stackoverflow.com/a/1176023/4093018
def convert_camelcase_to_underscores(identifier):
    identifier = re.sub('([A-Za-z0-9])([A-Z][a-z]+)', r'\1_\2', identifier)
    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', identifier).lower()

def c_inclusion_guard(output_file):
    "Creates a C-style macro inclusion guard."
    guard = output_file
    guard = re.sub('[^A-Za-z0-9_./-]', '', guard)
    guard = guard.strip('./-')
    guard = re.sub('[./-]', '_', guard)
    guard = convert_camelcase_to_underscores(guard).upper()
    guard = guard or 'clad'
    guard = '__{guard}__'.format(guard=guard)
    return guard

class SimpleArgumentParser(argparse.ArgumentParser):
    """
    The bare-minimum arguments for parsing. No output arguments.
    
    Calculates the following arguments and metavalues:
    input_file -- the filename of the file to read from (made portable)
    input_directory -- the directory to resolve includes from
    debug_yacc -- turn on yacc debug
    
    You may add your own arguments like a normal argparse.ArgumentParser.
    """
    
    def __init__(self, *args, **kwargs):
        super(SimpleArgumentParser, self).__init__(*args, **kwargs)
        self.add_argument('input_file', metavar='input-file',
            help='The .clad file to parse.')
        self.add_argument('-C', '--input-directory', default='./', metavar='dir',
            help='The input prefix directory.')
        self.add_argument('-I', '--include-directory', default=(), metavar='dir',
            nargs='*', dest='include_directories',
            help='Additional directories in which to search for included files.')
    
    def parse_known_args(self, *args, **kwargs):
        # add this argument last
        self.add_argument('-d', '--debug-yacc', action='store_true',
            help='Turn on yacc debug.')
        
        args, argv = super(SimpleArgumentParser, self).parse_known_args(*args, **kwargs)
        self.postprocess(args)
        return args, argv
    
    def postprocess(self, args):
        args.input_file = make_path_portable(args.input_file)

class StandardArgumentParser(SimpleArgumentParser):
    """
    An argparse.ArgumentParser used to parse arguments supported in every language.
    
    Calculates the additional arguments and metavalues:
    output_directory -- the directory to output to
    output_file (if permitted) -- the file to output to
    """
    
    def __init__(self, language, allow_override_output=False, *args, **kwargs):
        description = 'Generate {language} code from a .clad file.'.format(language=language)
        super(StandardArgumentParser, self).__init__(description=description, *args, **kwargs)
        
        self._allow_override_output = allow_override_output
        if allow_override_output:
            group = self.add_mutually_exclusive_group()
            group.add_argument('-o', '--output-directory', default='-', metavar='dir',
                help='The directory to output the {language} file to.'.format(language=language))
            group.add_argument('--output-file', metavar='file',
                help='The file path to write the {language} file to.'.format(language=language))
        else:
            self.add_argument('-o', '--output-directory', default='-', metavar='dir',
                help='The directory to output the {language} file(s) to.'.format(language=language))
    
    def postprocess(self, args):
        super(StandardArgumentParser, self).postprocess(args)
        if self._allow_override_output and args.output_file:
            args.output_directory = os.getcwd()
        else:
            args.output_file = None

def parse(options, yacc_optimize=False):
    "Parses a clad input file."
    with _get_input(options) as input:
        input_directories = [options.input_directory]
        input_directories.extend(options.include_directories)
        clad_parser = clad.AnkiBufferParser(yacc_optimize=yacc_optimize,
            yacc_debug=options.debug_yacc, input_directories=input_directories)
        text = input.read()
        try:
            return clad_parser.parse(text, filename=options.input_file, debuglevel=0)
        except clad.ParseError as e:
            msg = e[1]
            coord = e[0]
            sys.stderr.write('Syntax Error: {msg}\n{file} line {line} col {column}:\n'.format(
                msg=msg, file=coord.file, line=coord.line, column=coord.column))
            
            if coord.file is not None:
                spacing = len(str(coord.line + 3))
                real_file_path = os.path.join(options.input_directory, coord.file)
                with open(real_file_path, "r") as debug_input:
                    for i, line in enumerate(debug_input):
                        line_number = i + 1
                        if line_number > coord.line + 3:
                            break
                        elif line_number >= coord.line - 3:
                            sys.stderr.write(' ' * (spacing - len(str(line_number))))
                            sys.stderr.write('{spacer}{line_number} {line}\n'.format(
                                line_number=str(line_number).rjust(3, ' '),
                                line=line.rstrip('\n'),
                                spacer=('>>' if line_number == coord.line else '  ')))
            sys.exit(1)

def c_main(language, extension, emitter_types,
        allow_custom_extension=False, allow_override_output=False,
        use_inclusion_guards=False,
        system_headers=None, local_headers=None, usings=None):
    """
    Entry point for a simple C-like language.
    
    language -- C, C++, C#
    extension -- .h, .cs
    emitter_types -- a list of emitters to have visit the ast
    use_inclusion_guards -- put inclusion guards around the header file
    system_headers -- a list of headers: #include <foo>
    local_headers -- a list of headers: #include "foo"
    usings -- a list of namespaces: using foo;
    """
    
    option_parser = StandardArgumentParser(language, allow_override_output)
    if allow_custom_extension:
        option_parser.add_argument('--header-output-extension', default=extension, metavar='ext',
            help='The extension to use for header files. (Helps work around a CMake Xcode issue.)')
    options = option_parser.parse_args()
    if allow_custom_extension:
        extension = options.header_output_extension
    
    tree = parse(options)
    main_output_file = get_output_file(options, extension)
    comment_lines = get_comment_lines(options, language)
    
    def output_callback(output):
        for emitter_type in emitter_types:
            emitter_type(output, include_extension=extension).visit(tree)
    
    write_c_file(options.output_directory, main_output_file, output_callback, 
        comment_lines, use_inclusion_guards,
        system_headers, local_headers, usings)

def write_c_file(output_directory, output_file, output_callback,
        comment_lines=None, use_inclusion_guards=False,
        system_headers=None, local_headers=None, usings=None):
    
    with _get_output(output_directory, output_file) as output:
        if comment_lines:
            output.write('\n'.join('// {0}'.format(line) for line in comment_lines))
            output.write('\n\n')
    
        if use_inclusion_guards:
            inclusion_guard = c_inclusion_guard(output_file)
            output.write('#ifndef {inclusion_guard}\n'.format(inclusion_guard=inclusion_guard))
            output.write('#define {inclusion_guard}\n\n'.format(inclusion_guard=inclusion_guard))
    
        if system_headers:
            for header in sorted(system_headers):
                output.write('#include <{header}>\n'.format(header=header))
            output.write('\n')
        if local_headers:
            for header in sorted(local_headers):
                output.write('#include "{header}"\n'.format(header=header))
            output.write('\n')
        if usings:
            for using in sorted(usings):
                output.write('using {using};\n'.format(using=using))
            output.write('\n')
    
        output_callback(output)

        if use_inclusion_guards:
            output.write('#endif // {inclusion_guard}\n'.format(inclusion_guard=inclusion_guard))    

def write_python_file(output_directory, output_file, output_callback,
        comment_lines=None, future_features=('absolute_import', 'print_function'),
        additional_paths=None, import_modules=None):
    
    with _get_output(output_directory, output_file) as output:
        if comment_lines:
            output.write('"""\n')
            output.write('\n'.join('{0}'.format(line) for line in comment_lines))
            output.write('\n"""\n\n')
        
        if future_features:
            for feature in future_features:
                output.write('from __future__ import {feature}\n'.format(feature=feature))
            output.write('\n')
        
        if output != sys.stdout:
            additional_paths = [output_directory] + (additional_paths or [])
        if additional_paths:
            _write_python_modify_path(
                output, os.path.join(output_directory, output_file), additional_paths)
        
        if import_modules:
            for module in import_modules:
                if isinstance(module, tuple):
                    source, target = module
                    output.write('from {source} import {target}\n'.format(source=source, target=target))
                else:
                    output.write('import {module}\n'.format(module=module))
            output.write('\n')
        
        output_callback(output)

def _pretty_print_list(output, paths, depth=1):
    if not paths:
        output.write('[]')
    else:
        inner_depth = depth + 1
        output.write('[\n')
        for path in paths:
            output.write('\t' * inner_depth)
            output.write(repr(path))
            output.write(',\n')
        output.write('\t' * depth)
        output.write(']')

def _write_python_modify_path(output, output_file, additional_paths):
    
    if output != sys.stdout:
        currentpath = os.path.dirname(output_file)
        additional_paths = [make_path_relative(path, currentpath) for path in additional_paths]
    else:
        additional_paths = [os.path.normpath(os.path.abspath(path)) for path in additional_paths]
    
    output.write(textwrap.dedent('''\
        def _modify_path():
        \timport inspect, os, sys
        \tsearch_paths = '''))
    _pretty_print_list(output, additional_paths, depth=1)
    output.write('\n')
    
    if output != sys.stdout:
        output.write('\tcurrentpath = os.path.abspath(os.path.dirname(inspect.getfile(inspect.currentframe())))\n')
    
    output.write('\tfor search_path in search_paths:\n')
    
    if output != sys.stdout:
        output.write('\t\tsearch_path = os.path.normpath(os.path.abspath(os.path.realpath(os.path.join(currentpath, search_path))))\n')
    
    output.write(textwrap.dedent('''\
        \t\tif search_path not in sys.path:
        \t\t\tsys.path.insert(0, search_path)
        _modify_path()
        
        '''))
