//
//  csharp-binding.h
//  CozmoGame
//
//  Created by Greg Nagel on 2/3/15.
//
//

#include "csharp-binding.h"
#include "anki/cozmo/basestation/cozmoEngine.h"
#include "anki/cozmo/basestation/robot.h"
#include "anki/cozmo/basestation/signals/cozmoEngineSignals.h"
#include <algorithm>
#include <string>
#include <vector>

using namespace Anki;
//using namespace Anki::Cozmo;

Cozmo::CozmoEngineHost* host = nullptr;
Cozmo::CozmoEngine* engine = nullptr;

std::vector<Signal::SmartHandle> _signalHandles;

std::deque<std::string> error_messages;


// Queues for messages generated by signals coming out of the engine.
// Each of these can be polled at each tick using the associated
// "cozmo_engine_check_for_*" functions.

template<class MSG_TYPE>
class MessageQueue
{
public:
    MessageQueue() { }
  
  void add(MSG_TYPE msg) {
    _queue.emplace(msg);
  }
  
  bool check(MSG_TYPE* msg) {
    if(_queue.empty()) {
      return false;
    } else {
      *msg = _queue.front();
      _queue.pop();
      return true;
    }
  }
  
private:
  std::queue<MSG_TYPE> _queue;
};

MessageQueue<MessageG2U_RobotAvailable>         _queueRobotAvailable;
MessageQueue<MessageG2U_RobotConnected>         _queueRobotConnected;
MessageQueue<MessageG2U_RobotObservedObject>    _queueRobotObservedObject;


void add_log(std::string log_string)
{
    error_messages.push_back(log_string);
}

bool cozmo_has_log(int* receive_length)
{
    if (error_messages.empty()) {
        *receive_length = 0;
        return false;
    }
    *receive_length = (int)error_messages.back().length();
    return true;
}

void cozmo_pop_log(char* buffer, int buffer_length)
{
    if (error_messages.empty()) {
        return;
    }
    int length = std::min(buffer_length, (int)error_messages.back().length());
    std::memcpy(buffer, error_messages.back().data(), length);
    error_messages.pop_back();
}

int cozmo_engine_host_create(const char* configurationData, const char* visIP)
{
  using namespace Cozmo;
  
    if (engine != nullptr) {
        return (int)BINDING_ERROR_ALREADY_INITIALIZED;
    }
    
    if (configurationData == nullptr) {
        return (int)BINDING_ERROR_INVALID_CONFIGURATION;
    }
    
    Json::Reader reader;
    Json::Value config;
    if (!reader.parse(configurationData, configurationData + std::strlen(configurationData), config)) {
        add_log("Json Parsing Error: " + reader.getFormattedErrorMessages());
        return (int)BINDING_ERROR_INVALID_CONFIGURATION;
    }
    
    CozmoEngineHost* created_host = new CozmoEngineHost();
    config["VizHostIP"] = visIP;
    printf("config[VizHostIP] = %s;", visIP);
    
    Result result = created_host->Init(config);
    if (result == RESULT_OK) {
        created_host->ListenForRobotConnections(true);
    }
    if (result != RESULT_OK) {
        delete created_host;
        return result;
    }
    
    host = created_host;
    engine = host;
  
    // Register callbacks to turn signals into messages and queue them for polling:
    auto cbRobotAvailable = [](RobotID_t robotID) {
      _queueRobotAvailable.add(MessageG2U_RobotAvailable{robotID});
    };
    _signalHandles.emplace_back( CozmoEngineSignals::RobotAvailableSignal().ScopedSubscribe(cbRobotAvailable) );
  
    auto cbRobotConnected = [](RobotID_t robotID, bool success) {
      _queueRobotConnected.add(MessageG2U_RobotConnected{robotID, success});
    };
    _signalHandles.emplace_back( CozmoEngineSignals::RobotConnectedSignal().ScopedSubscribe(cbRobotConnected) );
  
    auto cbRobotObservedObject = [](RobotID_t robotID,   u32       objectID,
                                    u16       topLeft_x, u16       topLeft_y,
                                    u16       width,     u16       height)
    {
      _queueRobotObservedObject.add(MessageG2U_RobotObservedObject{robotID, objectID,
        topLeft_x, topLeft_y, width, height});
    };
    _signalHandles.emplace_back( CozmoEngineSignals::RobotObservedObjectSignal().ScopedSubscribe(cbRobotObservedObject) );
  
    return RESULT_OK;
}

int cozmo_engine_host_destroy()
{
    if (host != nullptr) {
        delete host;
        host = nullptr;
        engine = nullptr;
    }
    return (int)BINDING_OK;
}

int cozmo_engine_host_force_add_robot(int robot_id, const char* robot_ip, bool robot_is_simulated)
{
    if (host == nullptr) {
        return (int)BINDING_ERROR_NOT_INITIALIZED;
    }
    
    host->ForceAddRobot((u32)robot_id, robot_ip, robot_is_simulated);
    return (int)BINDING_OK;
}

int cozmo_engine_host_is_robot_connected(bool* is_connected, int robot_id)
{
    if (host == nullptr) {
        return (int)BINDING_ERROR_NOT_INITIALIZED;
    }
    Cozmo::Robot* robot = host->GetRobotByID((u32)robot_id);
    *is_connected = (robot != nullptr);
    
    if (host->ConnectToRobot((u32)robot_id)) {
        robot = host->GetRobotByID((u32)robot_id);
        *is_connected = (robot != nullptr);
    }
    
    return (int)BINDING_OK;
}

int cozmo_engine_update(float currentTime)
{
    if (engine == nullptr) {
        return (int)BINDING_ERROR_NOT_INITIALIZED;
    }
    return (int)engine->Update(currentTime);
}

int cozmo_robot_drive_wheels(int robot_id, float left_wheel_speed_mmps, float right_wheel_speed_mmps)
{
    Cozmo::Robot* robot = host->GetRobotByID((u32)robot_id);
    if (robot == nullptr) {
        return (int)BINDING_ERROR_ROBOT_NOT_READY;
    }
    return (int)robot->DriveWheels((f32)left_wheel_speed_mmps, (f32)right_wheel_speed_mmps);
}

int cozmo_robot_stop_all_motors(int robot_id)
{
    Cozmo::Robot* robot = host->GetRobotByID((u32)robot_id);
    if (robot == nullptr) {
        return (int)BINDING_ERROR_ROBOT_NOT_READY;
    }
    return (int)robot->StopAllMotors();
}


//
// Message queuing and checking
//

bool cozmo_engine_check_for_robot_available(MessageG2U_RobotAvailable* msg)
{
  return _queueRobotAvailable.check(msg);
}

bool cozmo_engine_check_for_robot_connected(MessageG2U_RobotConnected* msg)
{
  return _queueRobotConnected.check(msg);
}

bool cozmo_engine_check_for_observed_object(MessageG2U_RobotObservedObject* msg)
{
  return _queueRobotObservedObject.check(msg);
}

