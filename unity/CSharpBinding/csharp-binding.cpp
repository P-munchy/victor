//
//  csharp-binding.h
//  CozmoGame
//
//  Created by Greg Nagel on 2/3/15.
//
//

#include "csharp-binding.h"

#include "anki/cozmo/game/cozmoGame.h"
#include "anki/cozmo/basestation/utils/parsingConstants/parsingConstants.h"
#include "anki/cozmo/shared/cozmoConfig.h"

#include "anki/common/basestation/jsonTools.h"

#include <algorithm>
#include <string>
#include <vector>

using namespace Anki;
using namespace Anki::Cozmo;

Cozmo::CozmoGame* game = nullptr;

std::deque<std::string> error_messages;


const char* ROBOT_ADVERTISING_HOST_IP = "127.0.0.1";
const char* VIZ_HOST_IP = "127.0.0.1";


// Queues for messages generated by signals coming out of the engine.
// Each of these can be polled at each tick using the associated
// "cozmo_engine_check_for_*" functions.

void add_log(std::string log_string)
{
    error_messages.push_back(log_string);
}

bool cozmo_has_log(int* receive_length)
{
    if (error_messages.empty()) {
        *receive_length = 0;
        return false;
    }
    *receive_length = (int)error_messages.back().length();
    return true;
}

void cozmo_pop_log(char* buffer, int buffer_length)
{
    if (error_messages.empty()) {
        return;
    }
    int length = std::min(buffer_length, (int)error_messages.back().length());
    std::memcpy(buffer, error_messages.back().data(), length);
    error_messages.pop_back();
}

void configure(Json::Value config)
{
  if(!config.isMember(AnkiUtil::kP_ADVERTISING_HOST_IP)) {
    config[AnkiUtil::kP_ADVERTISING_HOST_IP] = ROBOT_ADVERTISING_HOST_IP;
  }
  if(!config.isMember(AnkiUtil::kP_VIZ_HOST_IP)) {
    config[AnkiUtil::kP_VIZ_HOST_IP] = VIZ_HOST_IP;
  }
  if(!config.isMember(AnkiUtil::kP_ROBOT_ADVERTISING_PORT)) {
    config[AnkiUtil::kP_ROBOT_ADVERTISING_PORT] = ROBOT_ADVERTISING_PORT;
  }
  if(!config.isMember(AnkiUtil::kP_UI_ADVERTISING_PORT)) {
    config[AnkiUtil::kP_UI_ADVERTISING_PORT] = UI_ADVERTISING_PORT;
  }
  if(!config.isMember(AnkiUtil::kP_AS_HOST)) {
    config[AnkiUtil::kP_AS_HOST] = true;
  }
  
  // Get engine playback mode mode
  CozmoGame::PlaybackMode playbackMode = CozmoGame::LIVE_SESSION_NO_RECORD;
  int pmInt;
  if(JsonTools::GetValueOptional(config, AnkiUtil::kP_ENGINE_PLAYBACK_MODE, pmInt)) {
    playbackMode = (CozmoGame::PlaybackMode)pmInt;
    assert(playbackMode <= CozmoGame::PLAYBACK_SESSION);
  }
  
  if (playbackMode != CozmoGame::PLAYBACK_SESSION) {
    
    // Wait for at least one robot and UI device to connect
    config[AnkiUtil::kP_NUM_ROBOTS_TO_WAIT_FOR] = 1;
    config[AnkiUtil::kP_NUM_UI_DEVICES_TO_WAIT_FOR] = 1;
    
  } else {
    
    config[AnkiUtil::kP_NUM_ROBOTS_TO_WAIT_FOR] = 0;
    config[AnkiUtil::kP_NUM_UI_DEVICES_TO_WAIT_FOR] = 0;
    
  } // if (bm != BM_PLAYBACK_SESSION)
}

int cozmo_game_create(const char* configurationData)
{
    using namespace Cozmo;
  
    if (game != nullptr) {
        return (int)BINDING_ERROR_ALREADY_INITIALIZED;
    }
    
    if (configurationData == nullptr) {
        return (int)BINDING_ERROR_INVALID_CONFIGURATION;
    }
    
    Json::Reader reader;
    Json::Value config;
    if (!reader.parse(configurationData, configurationData + std::strlen(configurationData), config)) {
        add_log("Json Parsing Error: " + reader.getFormattedErrorMessages());
        return (int)BINDING_ERROR_INVALID_CONFIGURATION;
    }
  
    configure(config);
  
    CozmoGame* created_game = new CozmoGame();
  
    Result result = created_game->Init(config);
    if (result != RESULT_OK) {
      delete created_game;
      return (int)result;
    }
    
    game = created_game;
  
    return RESULT_OK;
}

int cozmo_game_destroy()
{
    if (game != nullptr) {
        delete game;
        game = nullptr;
    }
    return (int)BINDING_OK;
}

int cozmo_game_update(float currentTime)
{
    if (game == nullptr) {
        return (int)BINDING_ERROR_NOT_INITIALIZED;
    }
    game->Update(currentTime);
    return BINDING_OK;
}

