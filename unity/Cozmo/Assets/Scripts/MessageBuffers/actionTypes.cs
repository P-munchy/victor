// Autogenerated C# message buffer code.
// Source: anki/cozmo/messageBuffers/shared/actionTypes.clad
// Full command line: ../lib/anki/cozmo-engine/tools/anki-util/tools/message-buffers/emitters/CSharp_emitter.py -C ../lib/anki/cozmo-engine/clad/src --output-file ../unity/Cozmo/Assets/Scripts/MessageBuffers/actionTypes.cs anki/cozmo/messageBuffers/shared/actionTypes.clad

namespace Anki {

namespace Cozmo {

public enum RobotActionType
{
	COMPOUND = -2,	// -2
	UNKNOWN = -1,	// -1
	DRIVE_TO_POSE,	// 0
	DRIVE_TO_OBJECT,	// 1
	DRIVE_TO_PLACE_CARRIED_OBJECT,	// 2
	TURN_IN_PLACE,	// 3
	MOVE_HEAD_TO_ANGLE,	// 4
	PICKUP_OBJECT_LOW,	// 5
	PICKUP_OBJECT_HIGH,	// 6
	PLACE_OBJECT_LOW,	// 7
	PLACE_OBJECT_HIGH,	// 8
	ROLL_OBJECT_LOW,	// 9
	PICK_AND_PLACE_INCOMPLETE,	// 10
	CROSS_BRIDGE,	// 11
	ASCEND_OR_DESCEND_RAMP,	// 12
	MOUNT_CHARGER,	// 13
	TRAVERSE_OBJECT,	// 14
	DRIVE_TO_AND_TRAVERSE_OBJECT,	// 15
	FACE_OBJECT,	// 16
	VISUALLY_VERIFY_OBJECT,	// 17
	PLAY_ANIMATION,	// 18
	PLAY_SOUND,	// 19
	WAIT,	// 20
	MOVE_LIFT_TO_HEIGHT	// 21
};

public enum ActionResult
{
	SUCCESS = 0,	// 0
	RUNNING,	// 1
	FAILURE_TIMEOUT,	// 2
	FAILURE_PROCEED,	// 3
	FAILURE_RETRY,	// 4
	FAILURE_ABORT,	// 5
	CANCELLED	// 6
};

public class ActionCompletedStruct
{
	private int[] _objectIDs; // int_32[5]
	private byte _numObjects; // uint_8
	private string _animName; // string[uint_8]

	public int[] objectIDs
	{
		get {
			return _objectIDs;
		}
		set {
			if (value == null) {
				throw new System.ArgumentException("objectIDs fixed-length array is null. Must have a length of 5.", "value");
			}
			if (value.Length != 5) {
				throw new System.ArgumentException("objectIDs fixed-length array is the wrong size. Must have a length of 5.", "value");
			}
			_objectIDs = value;
		}
	}

	public byte numObjects { get { return _numObjects; } set { _numObjects = value; } }

	public string animName
	{
		get {
			return _animName;
		}
		set {
			if (!string.IsNullOrEmpty(value) && System.Text.Encoding.UTF8.GetByteCount(value) > 255) {
				throw new System.ArgumentException("animName string is too long. Must decode to less than or equal to 255 bytes.", "value");
			}
			_animName = value;
		}
	}


	/**** Constructors ****/

	public ActionCompletedStruct()
	{
		this.objectIDs = new int[5];
	}

	public ActionCompletedStruct(int[] objectIDs,
		byte numObjects,
		string animName)
	{
		this.objectIDs = objectIDs;
		this.numObjects = numObjects;
		this.animName = animName;
	}

	public ActionCompletedStruct(System.IO.Stream stream)
	{
		Unpack(stream);
	}

	public ActionCompletedStruct(System.IO.BinaryReader reader)
	{
		Unpack(reader);
	}

	public void Unpack(System.IO.Stream stream)
	{
		System.IO.BinaryReader reader = new System.IO.BinaryReader(stream);
		Unpack(reader);
	}

	public void Unpack(System.IO.BinaryReader reader)
	{
		_objectIDs = new int[5];
		for (int i = 0; i < 5; ++i) {
			_objectIDs[i] = reader.ReadInt32();
		}
		_numObjects = reader.ReadByte();
		int _animName_length = (int)reader.ReadByte();
		byte[] _animName_bytes = reader.ReadBytes(_animName_length);
		_animName = System.Text.Encoding.UTF8.GetString(_animName_bytes);
	}

	public void Pack(System.IO.Stream stream)
	{
		System.IO.BinaryWriter writer = new System.IO.BinaryWriter(stream);
		Pack(writer);
	}

	public void Pack(System.IO.BinaryWriter writer)
	{
		for (int i = 0; i < 5; ++i) {
			writer.Write((int)_objectIDs[i]);
		}
		writer.Write((byte)_numObjects);
		if (_animName != null) {
			byte[] _animName_bytes = System.Text.Encoding.UTF8.GetBytes(_animName);
			writer.Write((byte)_animName_bytes.Length);
			writer.Write(_animName_bytes);
		}
		else {
			writer.Write((byte)0);
		}
	}

	public int Size 
	{
		get {
			int result = 0;
			result += 5 * 4;
			result += 1; // uint_8
			result += 1; // uint_8
			if (animName != null) {
				result += System.Text.Encoding.UTF8.GetByteCount(animName);
			}
			return result;
		}
	}

	public static bool ArrayEquals<T>(System.Collections.Generic.IList<T> a1, System.Collections.Generic.IList<T> a2) {
		if (System.Object.ReferenceEquals(a1, a2))
			return true;

		if (System.Object.ReferenceEquals(a1, null) || System.Object.ReferenceEquals(a2, null))
			return false;

		if (a1.Count != a2.Count)
			return false;

		for (int i = 0; i < a1.Count; i++)
		{
			if (!a1[i].Equals(a2[i])) {
				return false;
			}
		}
		return true;
	}

	public static bool operator ==(ActionCompletedStruct a, ActionCompletedStruct b)
	{
		if (System.Object.ReferenceEquals(a, null))
		{
			return System.Object.ReferenceEquals(b, null);
		}

		return a.Equals(b);
	}

	public static bool operator !=(ActionCompletedStruct a, ActionCompletedStruct b)
	{
		return !(a == b);
	}

	public override bool Equals(System.Object obj)
	{
		return this.Equals(obj as ActionCompletedStruct);
	}

	public bool Equals(ActionCompletedStruct p)
	{
		if (System.Object.ReferenceEquals(p, null))
		{
			return false;
		}

		return ArrayEquals<int>(this._objectIDs,p._objectIDs)
			&& this._numObjects.Equals(p._numObjects)
			&& this._animName.Equals(p._animName);
	}

	public override int GetHashCode()
	{
		unchecked
		{
			int hash = 17;
			hash = hash * 23 + this._numObjects.GetHashCode();
			return hash;
		}
	}
}

} // namespace Cozmo

} // namespace Anki

